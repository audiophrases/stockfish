<!DOCTYPE html><html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chess Interface</title>
  <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">
  <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
  <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
  
<style>
  :root {
    color-scheme: dark;
  }

  * {
    box-sizing: border-box;
  }

  body {
    margin: 0;
    min-height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    background: radial-gradient(circle at top, #1a2032 0%, #070910 75%);
    font-family: "Inter", "Segoe UI", sans-serif;
    color: #eef1ff;
  }

  .container {
    width: min(94vw, 540px);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 26px;
  }

  .board-shell {
    width: 100%;
    background: rgba(8, 11, 20, 0.82);
    border: 1px solid rgba(255, 255, 255, 0.05);
    border-radius: 28px;
    padding: 24px 28px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
    --square-size: 8px;
  }

  #board {
    width: 100%;
  }

  .evaluation-nav {
    width: 100%;
    height: 32px;
    background: #0d111c;
    border-radius: 8px;
    padding: 4px;
    cursor: pointer;
    overflow: hidden;
    position: relative;
    -webkit-tap-highlight-color: transparent;
  }

  .evaluation-nav__track {
    width: 100%;
    height: 100%;
    border-radius: 6px;
    overflow: hidden;
    display: flex;
    align-items: center;
    position: relative;
  }

  .evaluation-nav__segment {
    height: 100%;
    flex-shrink: 0;
  }

  .evaluation-nav__segment_white {
    background: #e1e1e1;
  }

  .evaluation-nav__segment_black {
    background: #434343;
  }

  .evaluation-nav__segment_advantage-white {
    background: #9bd8ff;
  }

  .evaluation-nav__segment_advantage-black {
    background: #737373;
  }

  .evaluation-nav__segment_white.current {
    box-shadow: inset 0 0 0 2px #338cff;
  }

  .evaluation-nav__segment_black.current {
    box-shadow: inset 0 0 0 2px #338cff;
  }

  .evaluation-nav__progress-bar {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    background: #338cff;
    border-radius: 6px;
    opacity: 0.8;
    mix-blend-mode: screen;
  }

  .notation {
    width: 100%;
    background: #0d111c;
    border-radius: 12px;
    padding: 12px 18px;
    font-size: 15px;
    color: #a4a8bb;
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 16px;
    font-family: monospace;
  }

  .status {
    white-space: nowrap;
  }

  .fen-pgn {
    display: flex;
    gap: 16px;
    width: 100%;
    min-width: 0;
  }

  .fen, .pgn {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .fen {
    flex-shrink: 1;
  }
  
  .pgn {
    flex-shrink: 9999;
  }

  .controls {
    display: flex;
    gap: 8px;
    align-items: center;
    flex-wrap: wrap;
    justify-content: center;
  }

  .controls button {
    border: none;
    background: #2a3044;
    color: #eef1ff;
    border-radius: 8px;
    padding: 8px 14px;
    font: inherit;
    font-size: 14px;
    cursor: pointer;
    transition: background 0.1s ease;
  }

  .controls button:hover {
    background: #343b51;
  }
  
  .controls button:active {
    background: #3c445c;
  }

  .controls button.toggled {
    background: #338cff;
  }

  .edit-controls {
    background: #0d111c;
    border-radius: 12px;
    padding: 10px;
    display: none;
  }

  .edit-controls.visible {
    display: flex;
    gap: 10px;
    align-items: center;
  }

  .pieces {
    display: flex;
    gap: 4px;
  }

  .pieces img {
    width: 32px;
    height: 32px;
    padding: 2px;
    border-radius: 4px;
    cursor: pointer;
  }
  
  .pieces img.selected {
    background: rgba(255, 255, 255, 0.2);
  }

  body.piece-move-mode #board {
    cursor: pointer;
  }

  .divider {
    width: 1px;
    height: 24px;
    background: #2a3044;
  }
</style>

</head>
<body>

<div class="container">
  <div class="board-shell">
    <div id="board"></div>
    <div class="evaluation-nav" tabindex="0">
      <div class="evaluation-nav__track"></div>
      <div class="evaluation-nav__progress-bar"></div>
    </div>
    <div class="notation">
      <div class="status"></div>
      <div class="fen-pgn">
        <div class="fen"></div>
        <div class="pgn"></div>
      </div>
    </div>
  </div>
  <div class="controls">
    <button id="start-button">Start</button>
    <button id="prev-button">&lt;</button>
    <button id="replay-button">Replay</button>
    <button id="next-button">&gt;</button>
    <button id="end-button">End</button>
    <button id="flip-button">Flip</button>
    <button id="edit-button">Edit</button>
  </div>
  <div class="edit-controls">
    <div class="pieces">
      <img src="https://lichess1.org/assets/piece/alpha/wP.svg" data-piece="wP" alt="White Pawn">
      <img src="https://lichess1.org/assets/piece/alpha/wN.svg" data-piece="wN" alt="White Knight">
      <img src="https://lichess1.org/assets/piece/alpha/wB.svg" data-piece="wB" alt="White Bishop">
      <img src="https://lichess1.org/assets/piece/alpha/wR.svg" data-piece="wR" alt="White Rook">
      <img src="https://lichess1.org/assets/piece/alpha/wQ.svg" data-piece="wQ" alt="White Queen">
      <img src="https://lichess1.org/assets/piece/alpha/wK.svg" data-piece="wK" alt="White King">
    </div>
    <div class="divider"></div>
    <div class="pieces">
      <img src="https://lichess1.org/assets/piece/alpha/bP.svg" data-piece="bP" alt="Black Pawn">
      <img src="https://lichess1.org/assets/piece/alpha/bN.svg" data-piece="bN" alt="Black Knight">
      <img src="https://lichess1.org/assets/piece/alpha/bB.svg" data-piece="bB" alt="Black Bishop">
      <img src="https://lichess1.org/assets/piece/alpha/bR.svg" data-piece="bR" alt="Black Rook">
      <img src="https://lichess1.org/assets/piece/alpha/bQ.svg" data-piece="bQ" alt="Black Queen">
      <img src="https://lichess1.org/assets/piece/alpha/bK.svg" data-piece="bK" alt="Black King">
    </div>
    <div class="divider"></div>
    <button id="clear-board-button">Clear</button>
    <button id="start-pos-button">Start Pos</button>
  </div>
</div>

<script>
$(function() {
  let board = null;
  let game = new Chess();
  const moveHistory = [];
  let navigationIndex = 0;
  let replayInterval = null;
  let replayMode = false;
  let editMode = false;
  let pieceMovesMode = false;
  let selectedPiece = null;

  const audioMove = new Audio('https://sound.peal.io/lichess/move.ogg');
  const audioCapture = new Audio('https://sound.peal.io/lichess/capture.ogg');
  const boardElement = document.getElementById('board');
  const evaluationNavElement = document.querySelector('.evaluation-nav');
  const evalTrackElement = evaluationNavElement.querySelector('.evaluation-nav__track');
  const evalProgressBar = evaluationNavElement.querySelector('.evaluation-nav__progress-bar');
  const editControlsElement = document.querySelector('.edit-controls');
  const pieceElements = document.querySelectorAll('.pieces img');

  const onDragStart = (source, piece, position, orientation) => {
    if (game.game_over() || replayMode || editMode) {
      return false;
    }
    if ((game.turn() === 'w' && piece.search(/^b/) !== -1) ||
        (game.turn() === 'b' && piece.search(/^w/) !== -1)) {
      return false;
    }
  };

  const onDrop = (source, target) => {
    const move = game.move({
      from: source,
      to: target,
      promotion: 'q'
    });

    if (move === null) {
      return 'snapback';
    }

    if (moveHistory.length > navigationIndex) {
      moveHistory.splice(navigationIndex);
    }
    
    const moveTime = 1 + Math.random() * 4;
    move.time = moveTime;
    moveHistory.push(move);
    navigationIndex++;
    if (move.captured) {
      audioCapture.play();
    } else {
      audioMove.play();
    }
    updateStatus();
    scheduleEvaluationNavigationRender();
  };

  const onSnapEnd = () => {
    board.position(game.fen());
  };
  
  const updateStatus = () => {
    let status = '';
    let moveColor = 'White';
    if (game.turn() === 'b') {
      moveColor = 'Black';
    }

    if (game.in_checkmate()) {
      status = `Game over, ${moveColor} is in checkmate.`;
    } else if (game.in_draw()) {
      status = 'Game over, drawn position.';
    } else {
      status = `${moveColor} to move`;
      if (game.in_check()) {
        status += `, ${moveColor} is in check.`;
      }
    }

    $('.status').html(status);
    $('.fen').html(game.fen());
    const pgn = game.pgn();
    $('.pgn').html(pgn.replace(/(\d+\.\s)/g, ' $1').trim());
    
    const isStart = navigationIndex === 0;
    const isEnd = navigationIndex === moveHistory.length;
    $('#start-button').prop('disabled', isStart);
    $('#prev-button').prop('disabled', isStart);
    $('#next-button').prop('disabled', isEnd);
    $('#end-button').prop('disabled', isEnd);
    $('#replay-button').prop('disabled', isEnd);
  };
  
  const rebuildPosition = index => {
    if (replayMode) stopReplay();
    const targetFen = index === 0 ? 'start' : moveHistory[index - 1].after;
    board.position(targetFen, false);
    navigationIndex = index;
    const tempGame = new Chess();
    if (index > 0) {
      const pgn = moveHistory.slice(0, index).map(m => m.san);
      const result = tempGame.load_pgn(pgn.join(' '));
    }
    game = tempGame;
    updateStatus();
    scheduleEvaluationNavigationRender();
  };
  
  let evalNavRenderQueued = false;
  const scheduleEvaluationNavigationRender = () => {
    if (evalNavRenderQueued) return;
    evalNavRenderQueued = true;
    requestAnimationFrame(() => {
      renderEvaluationNavigation();
      evalNavRenderQueued = false;
    });
  };

  const renderEvaluationNavigation = () => {
    const totalTime = moveHistory.reduce((acc, move) => acc + move.time, 0);
    const avgTime = totalTime / moveHistory.length;
    let html = '';
    const segmentWidths = [];
    for (let i = 0; i < moveHistory.length; i++) {
      const move = moveHistory[i];
      const isWhiteMove = i % 2 === 0;
      const relativeWidth = Math.max(0.25, Math.min(2.5, move.time / avgTime));
      segmentWidths.push(relativeWidth);
    }
    const totalRelativeWidth = segmentWidths.reduce((acc, val) => acc + val, 0);
    for (let i = 0; i < moveHistory.length; i++) {
      const move = moveHistory[i];
      const isWhiteMove = i % 2 === 0;
      const width = segmentWidths[i] / totalRelativeWidth * 100;
      const isCurrent = i === navigationIndex - 1;
      html += `
        <div
          class="evaluation-nav__segment evaluation-nav__segment_${isWhiteMove ? 'white' : 'black'} ${isCurrent ? 'current' : ''}"
          style="width: ${width}%"
          data-index="${i + 1}"
        ></div>
      `;
    }
    evalTrackElement.innerHTML = html;
    
    let progress = 0;
    if (moveHistory.length > 0) {
      const currentTotalWidth = segmentWidths.slice(0, navigationIndex).reduce((acc, val) => acc + val, 0);
      progress = currentTotalWidth / totalRelativeWidth * 100;
    }
    evalProgressBar.style.width = `${progress}%`;
  };

  const stepForward = () => {
    const nextIndex = navigationIndex + 1;
    if (nextIndex > moveHistory.length) {
      stopReplay();
      return;
    }
    rebuildPosition(nextIndex);
  };

  const startReplay = () => {
    if (replayInterval) return;
    replayMode = true;
    $('#replay-button').text('Pause');
    $('#replay-button').addClass('toggled');
    if (navigationIndex === moveHistory.length) {
      rebuildPosition(0);
    }
    replayInterval = setInterval(stepForward, 1200);
  };

  const stopReplay = () => {
    if (!replayInterval) return;
    replayMode = false;
    $('#replay-button').text('Replay');
    $('#replay-button').removeClass('toggled');
    clearInterval(replayInterval);
    replayInterval = null;
  };

  const onPieceSelect = (notation, piece) => {
    if (!editMode) return;
    
    if (selectedPiece && selectedPiece.notation === notation) {
      selectedPiece = null;
      pieceMovesMode = false;
      document.body.classList.remove('piece-move-mode');
      piece.classList.remove('selected');
      return;
    }
    
    pieceElements.forEach(p => p.classList.remove('selected'));
    
    selectedPiece = { notation, element: piece };
    pieceMovesMode = true;
    document.body.classList.add('piece-move-mode');
    piece.classList.add('selected');
  };

  const syncEvalBarWidth = () => {
    const squareElement = boardElement.querySelector('.white-1a1b');
    if (!squareElement) return;
    const squareSize = squareElement.getBoundingClientRect().width;
    document.body.style.setProperty('--square-size', `${squareSize}px`);
    const totalWidth = squareSize * 8;
    evaluationNavElement.style.width = `${totalWidth}px`;
  };
  
  const evalBarResizeObserver = new ResizeObserver(syncEvalBarWidth);
  evalBarResizeObserver.observe(boardElement);

  const config = {
    draggable: true,
    position: 'start',
    onDragStart: onDragStart,
    onDrop: onDrop,
    onSnapEnd: onSnapEnd,
    pieceTheme: (piece) => `https://lichess1.org/assets/piece/alpha/${piece}.svg`,
  };
  board = Chessboard('board', config);
  updateStatus();
  
  $('#start-button').on('click', () => rebuildPosition(0));
  $('#prev-button').on('click', () => rebuildPosition(Math.max(0, navigationIndex - 1)));
  $('#next-button').on('click', () => rebuildPosition(Math.min(moveHistory.length, navigationIndex + 1)));
  $('#end-button').on('click', () => rebuildPosition(moveHistory.length));
  $('#flip-button').on('click', () => board.flip());
  $('#replay-button').on('click', () => replayMode ? stopReplay() : startReplay());
  $('#edit-button').on('click', () => {
    editMode = !editMode;
    $('#edit-button').toggleClass('toggled', editMode);
    editControlsElement.classList.toggle('visible', editMode);
    if (!editMode) {
      pieceElements.forEach(p => p.classList.remove('selected'));
      document.body.classList.remove('piece-move-mode');
      selectedPiece = null;
      pieceMovesMode = false;
    }
  });

  $('#clear-board-button').on('click', () => {
    if (!editMode) return;
    game.clear();
    board.position(game.fen(), false);
  });
  $('#start-pos-button').on('click', () => {
    if (!editMode) return;
    game.reset();
    board.position(game.fen(), false);
  });
  
  pieceElements.forEach(piece => {
    piece.addEventListener('click', () => onPieceSelect(piece.dataset.piece, piece));
  });

  boardElement.addEventListener('click', event => {
    if (!editMode || !pieceMovesMode || !selectedPiece) return;
    const square = event.target.closest('[data-square]');
    if (!square) return;

    const currentPiece = game.get(square.dataset.square);
    if (currentPiece && currentPiece.type === selectedPiece.notation[1].toLowerCase() && currentPiece.color === selectedPiece.notation[0]) {
      game.remove(square.dataset.square);
    } else {
      game.put({ type: selectedPiece.notation[1].toLowerCase(), color: selectedPiece.notation[0] }, square.dataset.square);
    }
    board.position(game.fen(), false);
  });

  $(window).off('resize.board').on('resize.board', () => {
    if (!board) return;
    board.resize();
    syncEvalBarWidth();
    scheduleEvaluationNavigationRender();
  });

  if (evaluationNavElement) {
    evaluationNavElement.addEventListener('click', event => {
      if (replayMode) stopReplay();
      if (editMode || pieceMovesMode) return;
      const segment = event.target.closest('.evaluation-nav__segment');
      if (!segment) return;
      const { index } = segment.dataset;
      const targetIndex = Number.parseInt(index, 10);
      if (!Number.isInteger(targetIndex)) return;
      if (targetIndex === navigationIndex) return;
      rebuildPosition(Math.max(0, Math.min(targetIndex, moveHistory.length)));
    });
    evaluationNavElement.addEventListener('keydown', event => {
      if (editMode || pieceMovesMode) return;
      let targetIndex = null;
      if (event.key === 'ArrowLeft') {
        targetIndex = Math.max(0, navigationIndex - 1);
      } else if (event.key === 'ArrowRight') {
        targetIndex = Math.min(moveHistory.length, navigationIndex + 1);
      } else if (event.key === 'Home') {
        targetIndex = 0;
      } else if (event.key === 'End') {
        targetIndex = moveHistory.length;
      }
      if (targetIndex === null || targetIndex === navigationIndex) return;
      event.preventDefault();
      rebuildPosition(targetIndex);
    });
  }

  // Initial render
  setTimeout(() => {
    syncEvalBarWidth();
    scheduleEvaluationNavigationRender();
  }, 100);
});
</script>
</body>
</html>

