<!DOCTYPE html><html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chess Interface</title>
  <style>
    :root {
      color-scheme: dark;
      --eval-bar-width: 100%;
    }

    body {
      font-family: "Inter", "Segoe UI", sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background-color: #000;
      margin: 0;
      padding: 24px;
      color: #eef0f6;
    }

    .container {
      width: 100%;
      max-width: 960px;
      display: flex;
      flex-direction: column;
      gap: 24px;
      align-items: stretch;
    }

    .board-shell {
      background: #808080;
      border-radius: 28px;
      padding: 28px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      box-shadow: 0 28px 60px rgba(3, 6, 16, 0.55);
    }

    .board-area {
      width: min(72vw, 440px);
      max-width: 440px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
    }

    .eval-bar {
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      gap: 8px;
    }

    #evaluation-graph-container {
      width: var(--eval-bar-width);
      height: 64px;
      border-radius: 12px;
      background: linear-gradient(180deg, #1a1c28 0%, #10121b 100%);
      border: 1px solid rgba(255, 255, 255, 0.08);
      overflow: hidden;
      margin: 0 auto;
    }

    #evaluation-graph {
      width: 100%;
      height: 100%;
      display: block;
      cursor: pointer;
    }

    #gauge {
      position: relative;
      flex: none;
      height: 18px;
      width: var(--eval-bar-width);
      margin: 0 auto;
      border-radius: 0;
      background: linear-gradient(90deg, #11131d 0%, #2f344b 100%);
      border: 1px solid rgba(255, 255, 255, 0.12);
      overflow: hidden;
      align-self: center;
      box-sizing: border-box;
    }

    #gauge-white {
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      background: linear-gradient(90deg, #d2d8f7 0%, #f3f5ff 100%);
      width: 50%;
      transition: width 0.35s ease;
      z-index: 1;
      border-radius: 0;
    }

    #gauge::after {
      content: '';
      position: absolute;
      top: 0;
      bottom: 0;
      left: 50%;
      width: 2px;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.65);
      box-shadow: 0 0 6px rgba(12, 14, 25, 0.45);
      z-index: 2;
      pointer-events: none;
    }

    #evaluation-label {
      font-size: 0.9rem;
      color: #d4d9eb;
      min-width: 0;
      text-align: center;
      font-weight: 600;
      width: 100%;
    }

    .board-container {
      width: 100%;
      display: flex;
      justify-content: center;
    }

    #board {
      width: 100%;
    }

    #info-line {
      width: 100%;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 12px;
      font-size: 0.98rem;
      color: #f3f6ff;
      font-weight: 600;
    }

    #status {
      margin: 0;
      white-space: nowrap;
    }

    .info-line-item {
      display: flex;
      gap: 6px;
      align-items: center;
      white-space: nowrap;
    }

    .info-line-item span:last-child {
      color: #dce1ff;
    }

    #controls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 12px;
    }

    button {
      margin: 0;
      padding: 10px 18px;
      border: none;
      border-radius: 14px;
      color: #fff;
      cursor: pointer;
      background: linear-gradient(135deg, #4856ff 0%, #232d97 100%);
      font-weight: 600;
      letter-spacing: 0.02em;
      transition: transform 0.15s ease, box-shadow 0.15s ease, filter 0.15s ease;
      min-width: 120px;
    }

    button:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 12px 24px rgba(35, 52, 158, 0.45);
    }

    button:disabled {
      background: rgba(84, 90, 128, 0.4);
      cursor: not-allowed;
      box-shadow: none;
    }

    #piece-moves-button {
      background: linear-gradient(135deg, #1dbfcc 0%, #136677 100%);
    }

    #flip-button {
      background: linear-gradient(135deg, #34c964 0%, #127035 100%);
    }

    #edit-button {
      background: linear-gradient(135deg, #ffd96f 0%, #e6a421 100%);
      color: #1d1d1d;
    }

    .highlight-selection {
      box-shadow: inset 0 0 0 3px #f2ff5f !important;
    }

    .highlight-move-from,
    .highlight-move-to {
      background: rgba(255, 255, 0, 0.38) !important;
    }

    .selected-spare-piece {
      box-shadow: 0 0 0 3px #f2ff5f inset;
      border-radius: 8px;
    }

    .move-rating {
      position: absolute;
      bottom: 6px;
      right: 6px;
      background: rgba(9, 12, 24, 0.82);
      color: #f6f9ff;
      font-size: 12px;
      padding: 3px 5px;
      border-radius: 6px;
      pointer-events: none;
      z-index: 5;
    }

    .board-container .chessboard-7492f {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }

    .board-container .board-b72b1 {
      order: 1;
    }

    .board-container .spare-pieces-top,
    .board-container .spare-pieces-bottom {
      order: 2;
      margin-top: 6px;
      display: none;
    }

    .board-container.editing .spare-pieces-top,
    .board-container.editing .spare-pieces-bottom {
      display: flex;
    }

    .board-container .spare-pieces-7492f {
      justify-content: center;
      gap: 6px;
    }

    .board-container.editing .spare-pieces-7492f {
      display: flex;
    }

    @media (max-width: 1024px) {
      .board-shell {
        padding: 24px;
      }
    }

    @media (max-width: 768px) {
      .board-area {
        gap: 16px;
      }

      .eval-bar {
        gap: 6px;
      }
    }

    @media (max-width: 640px) {
      body {
        padding: 16px;
      }

      .container {
        gap: 20px;
      }

      .board-area {
        width: min(86vw, 420px);
      }

      button {
        min-width: 110px;
        padding: 10px 16px;
        font-size: 0.92rem;
      }
    }

    @media (max-width: 420px) {
      #info-line {
        font-size: 0.9rem;
        gap: 8px;
      }
    }
  </style>
  <script src="libs/jquery.min.js"></script>
  <link href="libs/chessboard-1.0.0.min.css" rel="stylesheet">
  <script src="libs/chessboard-1.0.0.min.js"></script>
  <script src="libs/chess.min.js"></script>
</head>
<body>
  <div class="container">
    <div class="board-shell">
      <div class="board-area">
        <div class="eval-bar">
          <span id="evaluation-label"></span>
          <div id="evaluation-graph-container"><canvas id="evaluation-graph"></canvas></div>
          <div id="gauge"><div id="gauge-white"></div></div>
        </div>
        <div class="board-container">
          <div id="board"></div>
        </div>
      </div>
      <div id="info-line">
        <span id="status">Ready</span>
        <span class="info-line-item"><span>Best:</span><span id="best-move">Hidden</span></span>
        <span class="info-line-item"><span>Eval:</span><span id="evaluation">N/A</span></span>
      </div>
    </div>
    <div id="controls">
      <button id="prev-button" disabled>Prev</button>
      <button id="next-button" disabled>Next</button>
      <button id="best-move-button" disabled>Best</button>
      <button id="piece-moves-button">Piece</button>
      <button id="flip-button">Flip</button>
      <button id="edit-button">Edit</button>
      <button id="fen-button">FEN / PGN</button>
    </div>
  </div>
  <script>
    $(function() {
      let board, engine;
      const game = new Chess();
      const boardEl = $('#board');
      let baseFen = game.fen();
      let selectedSquare = null;
      let moveSourceSquare = null;
      let isPieceAnalysis = false;
      let freezeMode = false;
      let editMode = false;
      let pieceMovesMode = false;
      let orientation = 'white';
      let latestAnalysisFen = null;
      let shouldHighlightBest = false;
      let engineReady = false;
      let editSelectedPiece = null;
      let editSelectedSquare = null;
      let editSelectionSource = null;
      let bestMoveVisible = false;
      let moveHistory = [];
      let navigationIndex = 0;
      let autoPlayPending = false;
      let autoPlayTargetDepth = 20;
      let autoPlayFen = null;
      let currentBestMove = null;
      let currentDepth = 0;
      let pieceMoveRatings = new Map();
      let waitingForAutoBestMove = false;
      let autoMoveCandidate = null;
      const DEFAULT_DEPTH = 20;
      const DEFAULT_THREADS = 4;
      const DEFAULT_HASH_MB = 469;
      const AUTO_PLAY_MIN_WAIT_MS = 4000;
      let autoPlayRequestedAt = 0;
      let autoPlayDelayTimer = null;
      let autoPlayDepthSatisfied = false;
      const evaluationGraphCanvas = document.getElementById('evaluation-graph');
      const evaluationGraphCtx = evaluationGraphCanvas ? evaluationGraphCanvas.getContext('2d') : null;
      let evaluationTimeline = [];
      let backgroundEngine = null;
      let backgroundEngineReady = false;
      let backgroundEvaluationQueue = [];
      let backgroundCurrentTask = null;
      let backgroundPendingStart = false;
      let backgroundLastScore = null;
      let backgroundEvaluationToken = 0;
      let backgroundEvaluationCompleted = 0;
      let backgroundEvaluationTotal = 0;

      function ensureTimelineCapacity(size) {
        const target = Math.max(0, Math.floor(size));
        let extended = false;
        while (evaluationTimeline.length < target) {
          evaluationTimeline.push(null);
          extended = true;
        }
        return extended;
      }

      function clearEvaluationTimeline(initialSize = 1) {
        const size = Math.max(1, Math.floor(initialSize));
        evaluationTimeline = new Array(size).fill(null);
        renderEvaluationGraph();
      }

      function resetBackgroundEvaluationProgress() {
        backgroundEvaluationCompleted = 0;
        backgroundEvaluationTotal = 0;
        updateEvaluationProgressLabel();
      }

      function updateEvaluationProgressLabel() {
        if (backgroundEvaluationTotal > 0 && backgroundEvaluationCompleted < backgroundEvaluationTotal) {
          $('#evaluation-label').text(`Evaluating game (${backgroundEvaluationCompleted}/${backgroundEvaluationTotal})`);
        } else {
          $('#evaluation-label').text('');
        }
      }

      function createEvaluationEntryFromScore({ cp = null, mate = null, turn = 'w' }) {
        if (typeof mate === 'number') {
          const mateValueRaw = mate;
          const isNegativeZero = Object.is(mateValueRaw, -0);
          const rawSign = mateValueRaw > 0 ? 1 : mateValueRaw < 0 ? -1 : (isNegativeZero ? -1 : 1);
          let mateValue = mateValueRaw;
          if (turn === 'b') {
            mateValue = -mateValue;
          }
          if (mateValue === 0) {
            const gaugeSign = turn === 'b' ? -rawSign : rawSign;
            return { value: gaugeSign >= 0 ? 2000 : -2000, text: 'Checkmate' };
          }
          const matePrefix = mateValue > 0 ? '' : '-';
          return { value: mateValue > 0 ? 2000 : -2000, text: `Mate in ${matePrefix}${Math.abs(mateValue)}` };
        }

        if (typeof cp === 'number') {
          let cpValue = cp;
          if (turn === 'b') {
            cpValue = -cpValue;
          }
          const normalized = Math.max(-2000, Math.min(2000, cpValue));
          const prefix = cpValue > 0 ? '+' : '';
          return { value: normalized, text: `${prefix}${(cpValue / 100).toFixed(2)}` };
        }

        return null;
      }

      function cancelBackgroundEvaluation() {
        backgroundEvaluationToken += 1;
        const hadActiveTask = !!backgroundCurrentTask;
        backgroundEvaluationQueue = [];
        backgroundCurrentTask = null;
        backgroundLastScore = null;
        resetBackgroundEvaluationProgress();
        if (backgroundEngine && hadActiveTask) {
          backgroundPendingStart = true;
          backgroundEngine.postMessage('stop');
        } else {
          backgroundPendingStart = false;
        }
      }

      function processBackgroundQueue() {
        if (!backgroundEngineReady || backgroundPendingStart || backgroundCurrentTask) return;
        const nextTask = backgroundEvaluationQueue.shift();
        if (!nextTask || nextTask.token !== backgroundEvaluationToken) {
          if (!backgroundEvaluationQueue.length && backgroundEvaluationCompleted >= backgroundEvaluationTotal && backgroundEvaluationTotal > 0) {
            updateEvaluationProgressLabel();
          }
          return;
        }
        backgroundCurrentTask = nextTask;
        backgroundLastScore = null;
        const normalizedFen = normalizeFenTurn(nextTask.fen, nextTask.turn);
        backgroundEngine.postMessage('setoption name MultiPV value 1');
        backgroundEngine.postMessage(`position fen ${normalizedFen}`);
        backgroundEngine.postMessage(`go depth ${nextTask.depth || DEFAULT_DEPTH}`);
      }

      function queueBackgroundEvaluationTasks(tasks) {
        if (!Array.isArray(tasks) || !tasks.length) {
          cancelBackgroundEvaluation();
          return;
        }
        backgroundEvaluationToken += 1;
        const token = backgroundEvaluationToken;
        backgroundEvaluationQueue = tasks.map(task => ({ ...task, token }));
        backgroundCurrentTask = null;
        backgroundLastScore = null;
        backgroundEvaluationCompleted = 0;
        backgroundEvaluationTotal = tasks.length;
        updateEvaluationProgressLabel();
        if (!backgroundEngine) {
          initBackgroundEngine();
        }
        if (backgroundEngineReady && !backgroundPendingStart) {
          processBackgroundQueue();
        }
      }

      function initBackgroundEngine() {
        if (backgroundEngine) return;
        backgroundEngineReady = false;
        backgroundPendingStart = false;
        backgroundCurrentTask = null;
        backgroundLastScore = null;
        backgroundEngine = new Worker('./engine/stockfish.js');
        backgroundEngine.onmessage = e => {
          const line = String(e.data).trim();

          if (line === 'uciok') {
            backgroundEngine.postMessage('setoption name Threads value 1');
            backgroundEngine.postMessage('setoption name Hash value 128');
            backgroundEngine.postMessage('isready');
            return;
          }

          if (line === 'readyok') {
            backgroundEngineReady = true;
            processBackgroundQueue();
            return;
          }

          if (!line.length) return;

          if (backgroundPendingStart) {
            if (line.startsWith('bestmove')) {
              backgroundPendingStart = false;
              backgroundLastScore = null;
              processBackgroundQueue();
            }
            return;
          }

          if (line.startsWith('info')) {
            if (!backgroundCurrentTask || backgroundCurrentTask.token !== backgroundEvaluationToken) {
              return;
            }
            if (!line.includes('score')) return;

            const cpMatch = line.match(/score cp (-?\d+)/);
            const mateMatch = line.match(/score mate (-?\d+)/);
            if (mateMatch) {
              backgroundLastScore = { mate: parseInt(mateMatch[1], 10), turn: backgroundCurrentTask.turn };
            } else if (cpMatch) {
              backgroundLastScore = { cp: parseInt(cpMatch[1], 10), turn: backgroundCurrentTask.turn };
            }
            return;
          }

          if (!line.startsWith('bestmove')) return;

          if (!backgroundCurrentTask) {
            processBackgroundQueue();
            return;
          }

          if (backgroundCurrentTask.token !== backgroundEvaluationToken) {
            backgroundCurrentTask = null;
            backgroundLastScore = null;
            processBackgroundQueue();
            return;
          }

          const currentTask = backgroundCurrentTask;
          backgroundCurrentTask = null;
          let entry = null;
          if (backgroundLastScore) {
            entry = createEvaluationEntryFromScore({ cp: backgroundLastScore.cp ?? null, mate: backgroundLastScore.mate ?? null, turn: backgroundLastScore.turn || currentTask.turn });
          }
          if (!entry) {
            entry = { value: 0, text: 'N/A' };
          }
          setTimelineEntry(currentTask.index, entry);
          backgroundEvaluationCompleted = Math.min(backgroundEvaluationCompleted + 1, backgroundEvaluationTotal);
          if (currentTask.index === navigationIndex) {
            applyStoredEvaluationIfAvailable();
          }
          updateEvaluationProgressLabel();
          backgroundLastScore = null;
          processBackgroundQueue();
        };
        backgroundEngine.postMessage('uci');
      }

      function buildBackgroundTasksForGame() {
        const tasks = [];
        const evaluationGame = new Chess();
        if (!evaluationGame.load(baseFen)) {
          evaluationGame.reset();
        }
        tasks.push({ index: 0, fen: evaluationGame.fen(), turn: evaluationGame.turn(), depth: DEFAULT_DEPTH });
        for (let i = 0; i < moveHistory.length; i += 1) {
          const entry = moveHistory[i];
          if (!entry) continue;
          const moveConfig = { from: entry.from, to: entry.to };
          if (entry.promotion) {
            moveConfig.promotion = entry.promotion;
          }
          const applied = evaluationGame.move(moveConfig);
          if (!applied) break;
          tasks.push({ index: i + 1, fen: evaluationGame.fen(), turn: evaluationGame.turn(), depth: DEFAULT_DEPTH });
        }
        return tasks;
      }

      function scheduleFullGameEvaluation() {
        const tasks = buildBackgroundTasksForGame();
        queueBackgroundEvaluationTasks(tasks);
      }

      function setTimelineEntry(index, entry) {
        if (typeof index !== 'number' || index < 0) return;
        const extended = ensureTimelineCapacity(index + 1);
        evaluationTimeline[index] = entry;
        if (extended || entry !== undefined) {
          renderEvaluationGraph();
        }
      }

      function getTimelineEntry(index) {
        if (typeof index !== 'number' || index < 0 || index >= evaluationTimeline.length) {
          return null;
        }
        return evaluationTimeline[index];
      }

      function renderEvaluationGraph() {
        if (!evaluationGraphCanvas || !evaluationGraphCtx) return;
        const displayWidth = evaluationGraphCanvas.clientWidth;
        const displayHeight = evaluationGraphCanvas.clientHeight;
        if (!displayWidth || !displayHeight) return;
        const dpr = window.devicePixelRatio || 1;
        if (evaluationGraphCanvas.width !== displayWidth * dpr || evaluationGraphCanvas.height !== displayHeight * dpr) {
          evaluationGraphCanvas.width = displayWidth * dpr;
          evaluationGraphCanvas.height = displayHeight * dpr;
        }
        const ctx = evaluationGraphCtx;
        ctx.save();
        ctx.scale(dpr, dpr);
        ctx.clearRect(0, 0, displayWidth, displayHeight);
        ctx.fillStyle = '#10121b';
        ctx.fillRect(0, 0, displayWidth, displayHeight);

        const midY = displayHeight / 2;
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.22)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, midY);
        ctx.lineTo(displayWidth, midY);
        ctx.stroke();

        let values = [];
        let lastValue = 0;
        if (evaluationTimeline.length) {
          for (let i = 0; i < evaluationTimeline.length; i += 1) {
            const entry = evaluationTimeline[i];
            if (entry && typeof entry.value === 'number') {
              lastValue = entry.value;
            }
            values.push(lastValue);
          }
          if (values.length === 1) {
            values.push(lastValue);
          }
        } else {
          values = [0, 0];
        }

        const verticalScale = displayHeight / 2;
        const step = values.length > 1 ? displayWidth / (values.length - 1) : 0;

        ctx.beginPath();
        ctx.moveTo(0, midY);
        for (let i = 0; i < values.length; i += 1) {
          const x = step * i;
          const ratio = Math.max(-2000, Math.min(2000, values[i])) / 2000;
          const y = midY - ratio * verticalScale;
          ctx.lineTo(x, y);
        }
        ctx.lineTo(displayWidth, midY);
        ctx.closePath();
        ctx.fillStyle = 'rgba(243, 245, 255, 0.82)';
        ctx.fill();

        ctx.beginPath();
        for (let i = 0; i < values.length; i += 1) {
          const x = step * i;
          const ratio = Math.max(-2000, Math.min(2000, values[i])) / 2000;
          const y = midY - ratio * verticalScale;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
        ctx.stroke();

        const currentIdx = Math.max(0, Math.min(navigationIndex, values.length - 1));
        const cursorX = values.length > 1 ? (currentIdx / (values.length - 1)) * displayWidth : 0;
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.35)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(cursorX, 0);
        ctx.lineTo(cursorX, displayHeight);
        ctx.stroke();

        ctx.restore();
      }

      function setGaugeVisual(cp) {
        const clamped = Math.max(-2000, Math.min(2000, cp));
        const pct = ((clamped + 2000) / 4000) * 100;
        $('#gauge-white').css('width', pct + '%');
        return clamped;
      }

      function applyEvaluationResult(cpValue, displayText) {
        const normalized = setGaugeVisual(cpValue);
        $('#evaluation').text(displayText);
        setTimelineEntry(navigationIndex, { value: normalized, text: displayText });
      }

      function applyStoredEvaluationIfAvailable() {
        const entry = getTimelineEntry(navigationIndex);
        if (entry && typeof entry.value === 'number') {
          setGaugeVisual(entry.value);
          if (entry.text) {
            $('#evaluation').text(entry.text);
          }
        }
      }

      function syncEvalBarWidth() {
        const boardSurface = document.querySelector('.board-container .board-b72b1');
        const boardArea = document.querySelector('.board-area');
        if (!boardSurface || !boardArea) return;
        const boardWidth = boardSurface.getBoundingClientRect().width;
        if (boardWidth) {
          boardArea.style.setProperty('--eval-bar-width', `${Math.round(boardWidth)}px`);
        }
        renderEvaluationGraph();
      }

      function normalizeFenTurn(fen, turn) {
        if (typeof fen !== 'string') return fen;
        const trimmed = fen.trim();
        if (!trimmed.length) return fen;
        const parts = trimmed.split(/\s+/);
        if (parts.length < 2) return trimmed;
        parts[1] = turn === 'b' ? 'b' : 'w';
        return parts.join(' ');
      }

      function updateBestMoveDisplay() {
        if (!bestMoveVisible) {
          $('#best-move').text('Hidden');
          if (!pieceMovesMode) {
            clearHighlights();
          }
          return;
        }

        if (currentBestMove) {
          $('#best-move').text(currentBestMove);
          if (shouldHighlightBest && !pieceMovesMode) {
            visualize(currentBestMove);
          }
        } else {
          $('#best-move').text('...');
        }
      }

      function updateNavigationButtons() {
        const hasFutureMove = navigationIndex < moveHistory.length;
        const prevDisabled = navigationIndex === 0 || pieceMovesMode || editMode || waitingForAutoBestMove;
        const nextDisabled = autoPlayPending || waitingForAutoBestMove || pieceMovesMode || editMode || (!hasFutureMove && !engineReady);
        $('#prev-button').prop('disabled', prevDisabled);
        $('#next-button').prop('disabled', nextDisabled);
      }

      function recordMove(move) {
        if (!move) return;
        if (navigationIndex < moveHistory.length) {
          moveHistory = moveHistory.slice(0, navigationIndex);
          evaluationTimeline = evaluationTimeline.slice(0, navigationIndex + 1);
        }
        moveHistory.push({ from: move.from, to: move.to, promotion: move.promotion });
        navigationIndex = moveHistory.length;
        ensureTimelineCapacity(navigationIndex + 1);
        updateNavigationButtons();
        renderEvaluationGraph();
      }

      function resetHistory(newBaseFen = null) {
        moveHistory = [];
        navigationIndex = 0;
        autoPlayPending = false;
        waitingForAutoBestMove = false;
        autoMoveCandidate = null;
        autoPlayFen = null;
        autoPlayDepthSatisfied = false;
        cancelBackgroundEvaluation();
        if (autoPlayDelayTimer) {
          clearTimeout(autoPlayDelayTimer);
          autoPlayDelayTimer = null;
        }
        if (typeof newBaseFen === 'string' && newBaseFen.length) {
          baseFen = newBaseFen;
        }
        clearEvaluationTimeline(1);
        $('#evaluation').text('N/A');
        setGaugeVisual(0);
        updateNavigationButtons();
        renderEvaluationGraph();
      }

      function rebuildPosition(targetIndex) {
        const clamped = Math.max(0, Math.min(targetIndex, moveHistory.length));
        const loaded = game.load(baseFen);
        if (!loaded) {
          game.reset();
          baseFen = game.fen();
        }
        for (let i = 0; i < clamped; i += 1) {
          const entry = moveHistory[i];
          if (!entry) continue;
          const move = game.move({ from: entry.from, to: entry.to, promotion: entry.promotion || 'q' });
          if (!move) break;
        }
        navigationIndex = clamped;
        if (pieceMovesMode) {
          pieceMovesMode = false;
          freezeMode = false;
          $('#piece-moves-button').text('Piece');
        }
        moveSourceSquare = null;
        selectedSquare = null;
        updateNavigationButtons();
        renderBoard();
        updateStatus();
        applyStoredEvaluationIfAvailable();
        renderEvaluationGraph();
        requestAnalysis({ highlight: shouldHighlightBest && bestMoveVisible, revealBest: bestMoveVisible });
      }

      function applyAutoMove(uciMove) {
        if (!uciMove || uciMove === '(none)') {
          return;
        }
        const from = uciMove.slice(0, 2);
        const to = uciMove.slice(2, 4);
        const promotion = uciMove.length > 4 ? uciMove.slice(4, 5) : undefined;
        const move = game.move({ from, to, promotion });
        if (move) {
          moveSourceSquare = null;
          selectedSquare = null;
          recordMove(move);
          renderBoard();
          updateStatus();
          requestAnalysis({ highlight: shouldHighlightBest && bestMoveVisible, revealBest: bestMoveVisible });
        }
      }

  function clearSelectionHighlight() {
    boardEl.find('.highlight-selection').removeClass('highlight-selection');
  }

  function highlightSelection(square) {
    if (!square) return;
    boardEl.find(`.square-${square}`).addClass('highlight-selection');
  }

  function applySelectionHighlights() {
    clearSelectionHighlight();
    if (editMode) {
      if (editSelectionSource === 'board' && editSelectedSquare) {
        highlightSelection(editSelectedSquare);
      }
      return;
    }
    if (pieceMovesMode && selectedSquare) {
      highlightSelection(selectedSquare);
    } else if (!pieceMovesMode && moveSourceSquare) {
      highlightSelection(moveSourceSquare);
    }
  }

  function clearSpareSelectionHighlight() {
    $('.board-container .selected-spare-piece').removeClass('selected-spare-piece');
  }

  function applySpareSelection() {
    clearSpareSelectionHighlight();
    if (!editMode || editSelectionSource !== 'spare' || !editSelectedPiece) return;
    const pieceCode = `${editSelectedPiece.color}${editSelectedPiece.type.toUpperCase()}`;
    $('.board-container .spare-pieces-7492f .piece-417db').filter(`[data-piece='${pieceCode}']`).first().addClass('selected-spare-piece');
  }

  function clearEditSelection() {
    editSelectedPiece = null;
    editSelectedSquare = null;
    editSelectionSource = null;
    applySelectionHighlights();
    applySpareSelection();
  }

  function handleSparePieceClick(pieceCode) {
    if (!editMode || !pieceCode || pieceCode.length < 2) return;
    editSelectedPiece = { color: pieceCode[0], type: pieceCode[1].toLowerCase() };
    editSelectedSquare = null;
    editSelectionSource = 'spare';
    applySelectionHighlights();
    applySpareSelection();
  }

  function handleEditSquareClick(square) {
    if (!editMode) return;
    if (!square) return;

    const piece = game.get(square);

    if (!editSelectedPiece) {
      if (piece) {
        editSelectedPiece = { type: piece.type, color: piece.color };
        editSelectedSquare = square;
        editSelectionSource = 'board';
        applySelectionHighlights();
      }
      return;
    }

    if (editSelectionSource === 'spare') {
      game.remove(square);
      game.put({ type: editSelectedPiece.type, color: editSelectedPiece.color }, square);
      resetHistory(game.fen());
      renderBoard();
      updateStatus();
      requestAnalysis({ highlight: shouldHighlightBest && bestMoveVisible, revealBest: bestMoveVisible });
      return;
    }

    if (editSelectionSource === 'board') {
      const sourceSquare = editSelectedSquare;
      if (!sourceSquare) {
        clearEditSelection();
        return;
      }
      if (sourceSquare === square) {
        clearEditSelection();
        return;
      }

      const movingPiece = { type: editSelectedPiece.type, color: editSelectedPiece.color };
      game.remove(sourceSquare);
      game.remove(square);
      game.put(movingPiece, square);
      clearEditSelection();
      resetHistory(game.fen());
      renderBoard();
      updateStatus();
      requestAnalysis({ highlight: shouldHighlightBest && bestMoveVisible, revealBest: bestMoveVisible });
    }
  }

  function handleOutsideBoardClick(event) {
    if (!editMode) return;
    const $target = $(event.target);
    if ($target.closest('.board-container').length) return;
    if (editSelectionSource === 'board' && editSelectedSquare) {
      game.remove(editSelectedSquare);
      clearEditSelection();
      resetHistory(game.fen());
      renderBoard();
      updateStatus();
      requestAnalysis({ highlight: shouldHighlightBest && bestMoveVisible, revealBest: bestMoveVisible });
    } else if (editSelectionSource) {
      clearEditSelection();
    }
  }

  function handleSquareClick(square) {
    if (!square) return;
    if (editMode) {
      handleEditSquareClick(square);
      return;
    }

    if (pieceMovesMode) {
      selectedSquare = square;
      applySelectionHighlights();
      analyzeMoves();
      return;
    }

    if (freezeMode || game.game_over()) return;

    const piece = game.get(square);
    const turn = game.turn();

    if (!moveSourceSquare) {
      if (!piece || piece.color !== turn) return;
      moveSourceSquare = square;
      applySelectionHighlights();
      return;
    }

    if (moveSourceSquare === square) {
      moveSourceSquare = null;
      applySelectionHighlights();
      return;
    }

    clearHighlights();
    clearRatings();

    const move = game.move({ from: moveSourceSquare, to: square, promotion: 'q' });

    if (move) {
      recordMove(move);
      moveSourceSquare = null;
      renderBoard();
      updateStatus();
      requestAnalysis({ highlight: shouldHighlightBest && bestMoveVisible, revealBest: bestMoveVisible });
    } else {
      if (piece && piece.color === turn) {
        moveSourceSquare = square;
      }
      applySelectionHighlights();
    }
  }

  function renderBoard() {
    const cfg = {
      position: game.fen(),
      draggable: editMode,
      sparePieces: editMode,
      orientation: orientation,
      onDragStart: onDragStart,
      onDrop: onDrop,
      onSnapEnd: onSnapEnd,
      pieceTheme: p => {
        if (!p) return '';
        const color = p[0] === 'w' ? 'white' : 'black';
        const map = {K:'king',Q:'queen',R:'rook',B:'bishop',N:'knight',P:'pawn'};
        return `pieces/${color}-${map[p[1]]}.png`;
      }
    };
    if (board) board.destroy();
    board = Chessboard('board', cfg);
    $('.board-container').toggleClass('editing', editMode);
    board.resize();
    syncEvalBarWidth();
    requestAnimationFrame(() => {
      if (!board) return;
      board.resize();
      syncEvalBarWidth();
    });
    boardEl.off('click.square').on('click.square', 'div.square-55d63', function() {
      const cls = $(this).attr('class').split(/\s+/);
      const sq = cls.find(c => /^square-[a-h][1-8]$/.test(c));
      if (!sq) return;
      handleSquareClick(sq.replace('square-',''));
    });
    $('.board-container .spare-pieces-7492f').off('click.spare').on('click.spare', '.piece-417db', function() {
      const pieceCode = $(this).attr('data-piece');
      handleSparePieceClick(pieceCode);
    });
    applySelectionHighlights();
    applySpareSelection();
    if (!editMode && !pieceMovesMode && shouldHighlightBest) {
      const currentBest = $('#best-move').text().trim();
      if (/^[a-h][1-8][a-h][1-8]$/.test(currentBest)) {
        visualize(currentBest);
      }
    }
    updateNavigationButtons();
    updateBestMoveDisplay();
  }

  function updateStatus() {
    const turn = game.turn() === 'b' ? 'Black' : 'White';
    let txt = '';
    if (game.in_checkmate()) txt = `Game over, ${turn} in checkmate.`;
    else if (game.in_draw()) txt = 'Game over, drawn position';
    else txt = `${turn} to move${game.in_check() ? `, ${turn} is in check` : ''}`;
    $('#status').text(txt);
  }

  function onDragStart(src, piece) {
    if (editMode) return false;
    if (freezeMode) return false;
    return !game.game_over() && ((game.turn() === 'w' && piece[0] === 'w') || (game.turn() === 'b' && piece[0] === 'b'));
  }

  function onDrop(src, tgt, piece, newPos) {
    clearHighlights(); clearRatings();
    if (editMode) {
      game.clear();
      Object.entries(newPos).forEach(([sq,p]) => { if (p) game.put({type:p[1].toLowerCase(), color:p[0]}, sq); });
      resetHistory(game.fen());
      renderBoard(); updateStatus(); requestAnalysis({ highlight: shouldHighlightBest && bestMoveVisible, revealBest: bestMoveVisible });
      return;
    }
    if (freezeMode && !editMode) return 'snapback';
    const m = game.move({from:src,to:tgt,promotion:'q'});
    if (!m) return 'snapback';
    recordMove(m);
    renderBoard(); updateStatus(); requestAnalysis({ highlight: shouldHighlightBest && bestMoveVisible, revealBest: bestMoveVisible });
  }

  function onSnapEnd() { if (!editMode) board.position(game.fen()); }
  function clearHighlights() { boardEl.find('.highlight-move-from, .highlight-move-to').removeClass('highlight-move-from highlight-move-to'); }
  function clearRatings() {
    boardEl.find('.move-rating').remove();
    pieceMoveRatings.clear();
  }

  function initEngine() {
    engine = new Worker('./engine/stockfish.js');
    engine.onmessage = e => {
      const line = String(e.data).trim();

      if (line === 'uciok') {
        engine.postMessage(`setoption name Threads value ${DEFAULT_THREADS}`);
        engine.postMessage(`setoption name Hash value ${DEFAULT_HASH_MB}`);
        engine.postMessage('isready');
        return;
      }

      if (line === 'readyok') {
        engineReady = true;
        $('#best-move-button').prop('disabled', false);
        updateNavigationButtons();
        requestAnalysis({ highlight: shouldHighlightBest && bestMoveVisible, revealBest: bestMoveVisible });
        return;
      }

      if (!line.length) return;

      if (isPieceAnalysis && line.startsWith('info') && line.includes('multipv')) {
        const pvIndex = line.indexOf(' pv ');
        if (pvIndex === -1) return;
        const pvMoves = line.slice(pvIndex + 4).trim().split(' ');
        const moveKey = pvMoves[0];
        if (!moveKey) return;

        const cp = line.match(/score cp (-?\d+)/);
        const mate = line.match(/score mate (-?\d+)/);
        let displayScore = '';
        if (cp) {
          const cpValue = parseInt(cp[1], 10);
          const prefix = cpValue > 0 ? '+' : '';
          displayScore = `${prefix}${(cpValue / 100).toFixed(2)}`;
        } else if (mate) {
          displayScore = `M${mate[1]}`;
        }

        const destination = moveKey.slice(2, 4);
        let ratingEl = pieceMoveRatings.get(moveKey);
        if (!ratingEl) {
          const squareEl = boardEl.find(`.square-${destination}`);
          if (!squareEl.length) return;
          ratingEl = $('<div class="move-rating"></div>').appendTo(squareEl);
          pieceMoveRatings.set(moveKey, ratingEl);
        }
        if (displayScore) {
          ratingEl.text(displayScore);
        }
        return;
      }

      if (line.startsWith('bestmove')) {
        if (isPieceAnalysis) {
          isPieceAnalysis = false;
          engine.postMessage('setoption name MultiPV value 1');
          if (!pieceMovesMode) {
            requestAnalysis({ highlight: shouldHighlightBest && bestMoveVisible, revealBest: bestMoveVisible });
          }
          return;
        }

        if (!latestAnalysisFen || latestAnalysisFen !== game.fen()) {
          return;
        }

        const parts = line.split(' ');
        const move = parts[1];

        if (waitingForAutoBestMove) {
          const fallback = autoMoveCandidate && autoMoveCandidate !== '(none)' ? autoMoveCandidate : null;
          const moveToPlay = move && move !== '(none)' ? move : fallback;

          const finalizeAutoMove = () => {
            if (autoPlayDelayTimer) {
              clearTimeout(autoPlayDelayTimer);
              autoPlayDelayTimer = null;
            }
            waitingForAutoBestMove = false;
            autoMoveCandidate = null;
            autoPlayDepthSatisfied = false;
            if (moveToPlay) {
              applyAutoMove(moveToPlay);
            }
            updateNavigationButtons();
          };

          if (!moveToPlay) {
            finalizeAutoMove();
            return;
          }

          const elapsed = Date.now() - autoPlayRequestedAt;
          const remaining = Math.max(0, AUTO_PLAY_MIN_WAIT_MS - elapsed);

          if (!autoPlayDepthSatisfied || remaining <= 0) {
            finalizeAutoMove();
          } else {
            if (autoPlayDelayTimer) {
              clearTimeout(autoPlayDelayTimer);
            }
            autoPlayDelayTimer = setTimeout(() => {
              autoPlayDelayTimer = null;
              finalizeAutoMove();
            }, remaining);
          }
          return;
        }

        if (move && move !== '(none)') {
          currentBestMove = move;
          updateBestMoveDisplay();
        }
        return;
      }

      if (!line.startsWith('info') || !line.includes('score')) {
        return;
      }

      if (!latestAnalysisFen || latestAnalysisFen !== game.fen()) return;
      if (isPieceAnalysis) return;

      const depthMatch = line.match(/depth (\d+)/);
      if (depthMatch) {
        currentDepth = parseInt(depthMatch[1], 10);
      }

      const cpMatch = line.match(/score cp (-?\d+)/);
      const mateMatch = line.match(/score mate (-?\d+)/);
      const turn = game.turn();

      if (cpMatch) {
        let value = parseInt(cpMatch[1], 10);
        if (turn === 'b') {
          value = -value;
        }
        const prefix = value > 0 ? '+' : '';
        const displayScore = `${prefix}${(value / 100).toFixed(2)}`;
        applyEvaluationResult(value, displayScore);
      } else if (mateMatch) {
        const mateValueRaw = parseInt(mateMatch[1], 10);
        const isNegativeZero = Object.is(mateValueRaw, -0);
        const rawSign = mateValueRaw > 0 ? 1 : mateValueRaw < 0 ? -1 : (isNegativeZero ? -1 : 1);

        let mateValue = mateValueRaw;
        if (turn === 'b') {
          mateValue = -mateValue;
        }

        if (mateValue === 0) {
          const gaugeSign = turn === 'b' ? -rawSign : rawSign;
          applyEvaluationResult(gaugeSign >= 0 ? 2000 : -2000, 'Checkmate');
        } else {
          const matePrefix = mateValue > 0 ? '' : '-';
          const mateText = `Mate in ${matePrefix}${Math.abs(mateValue)}`;
          applyEvaluationResult(mateValue > 0 ? 2000 : -2000, mateText);
        }
      }

      const pvIndex = line.indexOf(' pv ');
      if (pvIndex !== -1) {
        const pvMoves = line.slice(pvIndex + 4).trim().split(' ');
        if (pvMoves.length) {
          currentBestMove = pvMoves[0];
          updateBestMoveDisplay();
        }
      }

      if (autoPlayPending && autoPlayFen === latestAnalysisFen && currentDepth >= autoPlayTargetDepth && currentBestMove && !game.game_over()) {
        autoPlayPending = false;
        autoPlayFen = null;
        autoPlayDepthSatisfied = true;
        waitingForAutoBestMove = true;
        autoMoveCandidate = currentBestMove;
        engine.postMessage('stop');
        updateNavigationButtons();
      }
    };
    engine.postMessage('uci');
  }

  function visualize(u) {
    clearHighlights();
    if (!u || u.length < 4) return;
    const from = u.slice(0, 2);
    const to = u.slice(2, 4);
    boardEl.find(`.square-${from}`).addClass('highlight-move-from');
    boardEl.find(`.square-${to}`).addClass('highlight-move-to');
  }

  function requestAnalysis(options = {}) {
    if (!engineReady || !engine) return;
    const {
      highlight = false,
      revealBest = false,
      depth = DEFAULT_DEPTH,
      autoPlay = false,
      searchMoves = null,
      multiPv = 1,
      pieceAnalysis = false
    } = options;

    latestAnalysisFen = game.fen();
    shouldHighlightBest = highlight && revealBest;
    isPieceAnalysis = pieceAnalysis;
    currentBestMove = null;
    currentDepth = 0;
    waitingForAutoBestMove = false;
    autoMoveCandidate = null;

    if (!pieceAnalysis && !pieceMovesMode) {
      clearHighlights();
    }
    if (!pieceAnalysis) {
      clearRatings();
    }

    if (autoPlay) {
      autoPlayPending = true;
      autoPlayTargetDepth = depth;
      autoPlayFen = latestAnalysisFen;
      autoPlayRequestedAt = Date.now();
      autoPlayDepthSatisfied = false;
      if (autoPlayDelayTimer) {
        clearTimeout(autoPlayDelayTimer);
        autoPlayDelayTimer = null;
      }
    } else if (!pieceAnalysis) {
      autoPlayPending = false;
      autoPlayFen = null;
      autoPlayDepthSatisfied = false;
      if (autoPlayDelayTimer) {
        clearTimeout(autoPlayDelayTimer);
        autoPlayDelayTimer = null;
      }
    }

    if (revealBest) {
      bestMoveVisible = true;
    } else if (!bestMoveVisible) {
      shouldHighlightBest = false;
    }

    if (pieceAnalysis) {
      $('#evaluation').text('...');
    } else {
      const stored = getTimelineEntry(navigationIndex);
      if (!stored || typeof stored.value !== 'number') {
        $('#evaluation').text('...');
      }
    }
    updateBestMoveDisplay();

    const normalizedFen = normalizeFenTurn(latestAnalysisFen, game.turn());

    engine.postMessage('stop');
    engine.postMessage(`setoption name MultiPV value ${multiPv}`);
    engine.postMessage(`position fen ${normalizedFen}`);
    if (searchMoves && searchMoves.length) {
      engine.postMessage(`go depth ${depth} searchmoves ${searchMoves.join(' ')}`);
    } else {
      engine.postMessage(`go depth ${depth}`);
    }
    updateNavigationButtons();
  }

  function analyzeMoves() {
    clearRatings();
    if (!selectedSquare) return;
    const moves = game.moves({ verbose: true }).filter(m => m.from === selectedSquare);
    if (!moves.length) return;
    clearHighlights();
    applySelectionHighlights();
    const searchMoves = moves.map(m => m.from + m.to + (m.promotion ? m.promotion : ''));
    requestAnalysis({
      depth: DEFAULT_DEPTH,
      searchMoves,
      multiPv: moves.length,
      pieceAnalysis: true
    });
  }

  // UI hooks
  $('#best-move-button').on('click', () => {
    bestMoveVisible = !bestMoveVisible;
    shouldHighlightBest = bestMoveVisible;
    $('#best-move-button').text(bestMoveVisible ? 'Hide Best' : 'Best');
    updateBestMoveDisplay();
    if (bestMoveVisible) {
      requestAnalysis({ highlight: shouldHighlightBest, revealBest: true });
    }
  });
  $('#prev-button').on('click', () => {
    if (navigationIndex === 0) return;
    rebuildPosition(navigationIndex - 1);
  });
  $('#next-button').on('click', () => {
    if (autoPlayPending) return;
    if (game.game_over()) return;
    if (navigationIndex < moveHistory.length) {
      rebuildPosition(navigationIndex + 1);
      return;
    }
    if (!engineReady) return;
    requestAnalysis({
      highlight: shouldHighlightBest && bestMoveVisible,
      revealBest: bestMoveVisible,
      depth: DEFAULT_DEPTH,
      autoPlay: true
    });
  });
  $('#piece-moves-button').on('click', () => {
    pieceMovesMode = !pieceMovesMode;
    freezeMode = pieceMovesMode;
    if (!pieceMovesMode) {
      requestAnalysis({ highlight: shouldHighlightBest && bestMoveVisible, revealBest: bestMoveVisible });
    }
    selectedSquare = null;
    moveSourceSquare = null;
    $('#piece-moves-button').text(pieceMovesMode ? 'Play' : 'Piece');
    clearHighlights();
    clearRatings();
    renderBoard();
    updateStatus();
  });
  $('#flip-button').on('click', () => {
    orientation = orientation === 'white' ? 'black' : 'white';
    renderBoard();
    updateStatus();
  });
  $('#edit-button').on('click', () => {
    editMode = !editMode;
    moveSourceSquare = null;
    selectedSquare = null;
    if (editMode) {
      $(document).on('click.editOutside', handleOutsideBoardClick);
      clearEditSelection();
      clearHighlights();
      clearRatings();
    } else {
      $(document).off('click.editOutside');
      clearEditSelection();
      requestAnalysis({ highlight: shouldHighlightBest && bestMoveVisible, revealBest: bestMoveVisible });
    }
    $('#edit-button').text(editMode ? 'Play' : 'Edit');
    renderBoard();
    updateStatus();
  });
  $('#fen-button').on('click', () => {
    const raw = prompt('Enter FEN or PGN');
    if (!raw) return;
    const trimmed = raw.trim();
    if (!trimmed.length) return;

    const looksLikePgn = /\d+\./.test(trimmed) || /\[\w+\s+".*"\]/.test(trimmed) || trimmed.includes('\n');

    const loadFen = () => {
      const fenTest = new Chess();
      if (!fenTest.load(trimmed)) {
        return false;
      }
      const canonicalFen = fenTest.fen();
      if (!game.load(canonicalFen)) {
        return false;
      }
      resetHistory(game.fen());
      return true;
    };

    const loadPgn = () => {
      let importGame = new Chess();
      let loaded = false;
      if (typeof importGame.load_pgn === 'function') {
        loaded = importGame.load_pgn(trimmed, { sloppy: true });
        if (!loaded) {
          importGame = new Chess();
          loaded = importGame.load_pgn(trimmed);
        }
      }
      if (!loaded) return false;

      const header = typeof importGame.header === 'function' ? importGame.header() : {};
      const history = importGame.history({ verbose: true }) || [];
      let initialFen = null;
      if (header && header.SetUp === '1' && header.FEN) {
        initialFen = header.FEN;
      }

      const baseCandidate = new Chess();
      if (initialFen) {
        if (!baseCandidate.load(initialFen)) {
          return false;
        }
      }
      const basePositionFen = baseCandidate.fen();
      const moves = history.map(m => ({ from: m.from, to: m.to, promotion: m.promotion }));

      const verificationGame = new Chess();
      if (!verificationGame.load(basePositionFen)) {
        return false;
      }
      for (const mv of moves) {
        const moveConfig = { from: mv.from, to: mv.to };
        if (mv.promotion) {
          moveConfig.promotion = mv.promotion;
        }
        const applied = verificationGame.move(moveConfig);
        if (!applied) {
          return false;
        }
      }

      resetHistory(basePositionFen);
      moveHistory = moves;
      navigationIndex = 0;
      clearEvaluationTimeline(moveHistory.length + 1);
      if (!game.load(basePositionFen)) {
        return false;
      }
      updateNavigationButtons();
      renderEvaluationGraph();
      return true;
    };

    const loaders = looksLikePgn ? [loadPgn, loadFen] : [loadFen, loadPgn];
    let loaded = false;
    for (const loader of loaders) {
      if (loader()) {
        loaded = true;
        break;
      }
    }

    if (!loaded) {
      alert('Invalid FEN or PGN');
      return;
    }

    moveSourceSquare = null;
    selectedSquare = null;
    editSelectedPiece = null;
    editSelectedSquare = null;
    editSelectionSource = null;
    applySelectionHighlights();
    applySpareSelection();
    renderBoard();
    updateStatus();
    updateNavigationButtons();
    requestAnalysis({ highlight: shouldHighlightBest && bestMoveVisible, revealBest: bestMoveVisible });
    scheduleFullGameEvaluation();
  });

  renderBoard();
  setGaugeVisual(0);
  initEngine();
  initBackgroundEngine();
  updateStatus();
  $(window).off('resize.board').on('resize.board', () => {
    if (!board) return;
    board.resize();
    syncEvalBarWidth();
  });

  if (evaluationGraphCanvas) {
    evaluationGraphCanvas.addEventListener('click', event => {
      if (editMode || pieceMovesMode) return;
      if (!evaluationTimeline || evaluationTimeline.length <= 1) return;
      const rect = evaluationGraphCanvas.getBoundingClientRect();
      if (!rect.width) return;
      const relativeX = Math.max(0, Math.min(rect.width, event.clientX - rect.left));
      const ratio = relativeX / rect.width;
      const targetIndex = Math.round(ratio * (evaluationTimeline.length - 1));
      if (targetIndex === navigationIndex) return;
      rebuildPosition(targetIndex);
    });
  }
});

  </script>
</body>
</html>