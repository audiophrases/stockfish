<!DOCTYPE html><html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chess Interface</title>
  
<style>
  :root {
    color-scheme: dark;
  }

  * {
    box-sizing: border-box;
  }

  body {
    margin: 0;
    min-height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    background: radial-gradient(circle at top, #1a2032 0%, #070910 75%);
    font-family: "Inter", "Segoe UI", sans-serif;
    color: #eef1ff;
  }

  .container {
    width: min(94vw, 540px);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 26px;
  }

  .board-shell {
    width: 100%;
    background: rgba(8, 11, 20, 0.82);
    border: 1px solid rgba(255, 255, 255, 0.05);
    border-radius: 28px;
    padding: 24px 28px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
    box-shadow: 0 40px 80px rgba(0, 0, 0, 0.55);
  }

  .board-area {
    width: 100%;
    display: flex;
    flex-direction: column;
    gap: 20px;
    align-items: center;
  }

  .board-container {
    width: 100%;
    display: flex;
    justify-content: center;
  }

  #board {
    width: 100%;
    max-width: 480px;
  }

  .visually-hidden {
    border: 0 !important;
    clip: rect(1px, 1px, 1px, 1px) !important;
    clip-path: inset(50%) !important;
    height: 1px !important;
    margin: -1px !important;
    overflow: hidden !important;
    padding: 0 !important;
    position: absolute !important;
    width: 1px !important;
    white-space: nowrap !important;
  }

  #info-line {
    display: flex;
    gap: 18px;
    align-items: center;
    justify-content: center;
  }

  #status {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 6px 12px;
    border-radius: 999px;
    background: rgba(255, 255, 255, 0.07);
    color: #d8ddff;
    font-size: 0.72rem;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    font-weight: 600;
    line-height: 1.1;
    transition: background 0.3s ease, color 0.3s ease, box-shadow 0.2s ease;
  }

  #status .status-text__label {
    line-height: 1.2;
  }

  #status[data-turn="white"] {
    color: #f4f6ff;
  }

  #status[data-turn="black"] {
    color: #b9c5ff;
  }

  #status[data-state="check"] {
    background: rgba(255, 147, 101, 0.18);
    color: #ffb08a;
    box-shadow: 0 0 0 1px rgba(255, 147, 101, 0.18);
  }

  #status[data-state="mate"] {
    background: rgba(255, 112, 145, 0.22);
    color: #ff7da1;
    box-shadow: 0 0 0 1px rgba(255, 112, 145, 0.18);
  }

  #status[data-state="draw"] {
    background: rgba(188, 196, 226, 0.18);
    color: #d9defa;
    box-shadow: 0 0 0 1px rgba(188, 196, 226, 0.18);
  }

  #status.is-editing {
    cursor: pointer;
    box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.24);
  }

  #status.is-editing:focus-visible {
    outline: 2px solid rgba(143, 165, 255, 0.7);
    outline-offset: 2px;
  }

  .info-line-item {
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .evaluation-indicator {
    --eval-scale: 0.5;
    position: relative;
    width: 140px;
    height: 8px;
    border-radius: 999px;
    background: rgba(255, 255, 255, 0.08);
    overflow: hidden;
    box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.05);
  }

  .evaluation-indicator::before {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(90deg, #69f0ff, #7b7dff 55%, #ff7ce8);
    transform: scaleX(var(--eval-scale));
    transform-origin: left center;
    transition: transform 0.35s ease;
  }

  .advantage-bar {
    position: relative;
    width: 100%;
    max-width: 320px;
    height: 12px;
    border-radius: 999px;
    overflow: hidden;
    background: rgba(255, 255, 255, 0.08);
    box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.05);
    display: block;
  }

  .advantage-bar[hidden] {
    display: none !important;
  }

  .advantage-bar__header,
  .advantage-bar__status,
  .advantage-bar__footer {
    display: none !important;
  }

  .advantage-bar__track {
    position: absolute;
    inset: 0;
    --white-ratio: 50%;
    background: linear-gradient(90deg, rgba(236, 244, 255, 0.85) 0%, rgba(236, 244, 255, 0.85) var(--white-ratio), rgba(18, 26, 44, 0.85) var(--white-ratio), rgba(18, 26, 44, 0.85) 100%);
  }

  .advantage-bar__track::after {
    content: '';
    position: absolute;
    top: -4px;
    bottom: -4px;
    width: 4px;
    border-radius: 8px;
    background: rgba(255, 255, 255, 0.6);
    left: calc(var(--white-ratio) - 2px);
    transition: left 0.35s ease;
  }

  .advantage-bar.is-white-favored {
    box-shadow: inset 0 0 0 1px rgba(165, 199, 255, 0.4), 0 12px 24px rgba(80, 140, 255, 0.25);
  }

  .advantage-bar.is-black-favored {
    box-shadow: inset 0 0 0 1px rgba(130, 110, 255, 0.4), 0 12px 24px rgba(130, 110, 255, 0.22);
  }

  .advantage-bar.is-balanced {
    box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.04);
  }

  .advantage-bar.is-loading .advantage-bar__track::after {
    animation: indicator-slide 1.1s ease-in-out infinite;
  }

  @keyframes indicator-slide {
    0% { opacity: 0.4; }
    50% { opacity: 1; }
    100% { opacity: 0.4; }
  }

  button {
    appearance: none;
    border: none;
    background: none;
    padding: 0;
    cursor: pointer;
  }

  #controls {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 16px;
    width: 100%;
  }

  .control-button {
    position: relative;
    width: 100%;
    min-height: 48px;
    border-radius: 16px;
    background: rgba(255, 255, 255, 0.08);
    color: #eef1ff;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 12px 16px;
    text-align: center;
    font-size: 0.95rem;
    font-weight: 600;
    line-height: 1.2;
    transition: transform 0.2s ease, background 0.2s ease, box-shadow 0.2s ease, color 0.2s ease;
    box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.04);
  }

  .control-button:hover:not(:disabled) {
    transform: translateY(-2px);
    background: rgba(122, 140, 255, 0.28);
    box-shadow: 0 10px 24px rgba(70, 90, 200, 0.35);
  }

  .control-button:disabled {
    cursor: not-allowed;
    opacity: 0.35;
    transform: none;
  }

  .control-button.is-active {
    background: rgba(122, 140, 255, 0.35);
    box-shadow: 0 12px 28px rgba(88, 120, 255, 0.38);
  }

  .control-button__label {
    display: block;
    width: 100%;
    pointer-events: none;
  }

  .probability-panel {
    width: 100%;
    max-width: 480px;
    background: rgba(10, 14, 26, 0.85);
    border-radius: 20px;
    padding: 18px;
    border: 1px solid rgba(255, 255, 255, 0.05);
    backdrop-filter: blur(8px);
  }

  .probability-panel[hidden] {
    display: none !important;
  }

  .probability-panel__graph {
    width: 100%;
    height: 140px;
    position: relative;
  }

  .engine-settings {
    width: 100%;
    background: rgba(10, 14, 26, 0.85);
    border-radius: 22px;
    padding: 20px 22px;
    border: 1px solid rgba(255, 255, 255, 0.05);
    backdrop-filter: blur(8px);
    display: flex;
    flex-direction: column;
    gap: 18px;
  }

  .engine-settings[hidden] {
    display: none !important;
  }

  .engine-settings__header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 12px;
  }

  .engine-settings__title {
    margin: 0;
    font-size: 1rem;
    font-weight: 600;
    color: #eef1ff;
  }

  .engine-settings__status {
    font-size: 0.85rem;
    letter-spacing: 0.04em;
    text-transform: uppercase;
    color: #9ca6cf;
  }

  .engine-settings__status[data-state="ready"] {
    color: #7fe7c4;
  }

  .engine-settings__status[data-state="loading"] {
    color: #f7d58b;
  }

  .engine-settings__status[data-state="error"] {
    color: #ff9aad;
  }

  .engine-settings__form {
    display: grid;
    gap: 14px;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  }

  .engine-field {
    display: flex;
    flex-direction: column;
    gap: 6px;
    font-size: 0.85rem;
    color: #c9cfef;
  }

  .engine-field__input {
    border-radius: 12px;
    border: 1px solid rgba(255, 255, 255, 0.08);
    background: rgba(17, 21, 32, 0.9);
    color: #eef1ff;
    padding: 10px 12px;
    font-size: 1rem;
    transition: border 0.2s ease, box-shadow 0.2s ease;
  }

  .engine-field__input:focus {
    outline: none;
    border-color: rgba(130, 148, 255, 0.6);
    box-shadow: 0 0 0 2px rgba(130, 148, 255, 0.25);
  }

  .engine-settings__actions {
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
  }

  .engine-action-button {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    border-radius: 14px;
    padding: 10px 18px;
    font-size: 0.92rem;
    font-weight: 600;
    line-height: 1.1;
    background: rgba(255, 255, 255, 0.08);
    color: #eef1ff;
    box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.06);
    transition: transform 0.2s ease, background 0.2s ease, box-shadow 0.2s ease, color 0.2s ease;
    min-height: 44px;
  }

  .engine-action-button:hover:not(:disabled) {
    transform: translateY(-2px);
    background: rgba(122, 140, 255, 0.28);
    box-shadow: 0 10px 24px rgba(70, 90, 200, 0.35);
  }

  .engine-action-button:disabled {
    cursor: not-allowed;
    opacity: 0.35;
    transform: none;
  }

  .engine-action-button--primary {
    background: linear-gradient(135deg, rgba(102, 126, 255, 0.85), rgba(136, 98, 255, 0.85));
    box-shadow: 0 14px 28px rgba(88, 120, 255, 0.38);
  }

  .engine-action-button__label {
    pointer-events: none;
  }

  .engine-settings__error {
    font-size: 0.85rem;
    color: #ff9aad;
  }

  .engine-settings__help {
    margin: -6px 0 0;
    font-size: 0.78rem;
    color: #9ca6cf;
    line-height: 1.5;
  }

  .evaluation-nav__graph {
    width: 100%;
    height: 100%;
  }

  .evaluation-nav__area {
    fill: rgba(130, 148, 255, 0.2);
  }

  .evaluation-nav__line {
    stroke: rgba(214, 222, 255, 0.85);
    stroke-width: 2;
  }

  .evaluation-nav__baseline {
    stroke: rgba(255, 255, 255, 0.14);
    stroke-width: 1;
    stroke-dasharray: 6 6;
  }

  .evaluation-nav__overlay {
    position: absolute;
    inset: 0;
    display: grid;
  }

  .evaluation-nav__segment {
    border: none;
    background: transparent;
    padding: 0;
    margin: 0;
    cursor: pointer;
  }

  .evaluation-nav__segment:hover,
  .evaluation-nav__segment.is-current {
    background: rgba(122, 140, 255, 0.18);
  }

  .evaluation-nav__marker {
    fill: #f5f7ff;
    stroke: rgba(122, 140, 255, 0.9);
    stroke-width: 2;
  }

  .highlight-selection {
    box-shadow: inset 0 0 0 3px #f2ff5f !important;
  }

  .highlight-move-from,
  .highlight-move-to {
    background: rgba(255, 255, 0, 0.38) !important;
  }

  .highlight-piece-move-target {
    background: rgba(118, 142, 255, 0.32) !important;
    box-shadow: inset 0 0 0 2px rgba(255, 255, 255, 0.22);
  }

  .selected-spare-piece {
    box-shadow: 0 0 0 3px #f2ff5f inset;
    border-radius: 8px;
  }

  .move-rating {
    position: absolute;
    bottom: 6px;
    right: 6px;
    background: rgba(9, 12, 24, 0.82);
    color: #f6f9ff;
    font-size: 12px;
    padding: 3px 5px;
    border-radius: 6px;
    pointer-events: none;
    z-index: 5;
  }

  .board-container .chessboard-7492f {
    display: flex;
    flex-direction: column;
    gap: 10px;
    align-items: center;
  }

  .board-container .board-b72b1 {
    order: 1;
  }

  .board-container .spare-pieces-top,
  .board-container .spare-pieces-bottom {
    order: 2;
    margin-top: 6px;
    display: none;
  }

  .board-container.editing .spare-pieces-top,
  .board-container.editing .spare-pieces-bottom {
    display: flex;
  }

  .board-container .spare-pieces-7492f {
    justify-content: center;
    gap: 6px;
  }

  .board-container.editing .spare-pieces-7492f {
    display: flex;
  }

  .board-container.editing .spare-pieces-7492f .piece-417db[data-piece^='b'] {
    background: rgba(255, 255, 255, 0.18);
    border-radius: 10px;
    padding: 4px;
  }

  @media (max-width: 640px) {
    .board-shell {
      padding: 18px 22px;
      border-radius: 24px;
    }

    .container {
      gap: 22px;
    }

    #board {
      max-width: 100%;
    }

    .evaluation-indicator {
      width: 110px;
    }
  }

  @media (max-width: 480px) {
    .container {
      width: min(98vw, 460px);
      gap: 18px;
    }

    .board-shell {
      padding: 14px 16px;
      border-radius: 22px;
    }

    #controls {
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
    }

    .control-button {
      border-radius: 14px;
      padding: 10px 12px;
      font-size: 0.88rem;
    }

    .engine-settings {
      padding: 16px 18px;
      border-radius: 18px;
    }

    .engine-settings__form {
      grid-template-columns: 1fr;
      gap: 12px;
    }
  }
</style>

  <script src="libs/jquery.min.js"></script>
  <link href="libs/chessboard-1.0.0.min.css" rel="stylesheet">
  <script src="libs/chessboard-1.0.0.min.js"></script>
  <script src="libs/chess.min.js"></script>
</head>
<body>
  <div class="container">
    <div class="board-shell">
      <div class="board-area">
        <div class="board-container">
          <div id="board"></div>
        </div>
        <div class="advantage-bar is-balanced advantage-bar--minimal" id="advantage-bar" aria-live="polite" aria-busy="false" aria-hidden="true" hidden>
          <div class="advantage-bar__header" aria-hidden="true">
            <span class="visually-hidden">Advantage</span>
            <span class="advantage-bar__status visually-hidden" id="advantage-status">Awaiting evaluation</span>
          </div>
          <div class="advantage-bar__track" id="advantage-track"></div>
          <div class="advantage-bar__footer" aria-hidden="true">
            <span class="advantage-bar__side advantage-bar__side--white">
              <span class="advantage-bar__side-label visually-hidden">White</span>
              <span class="advantage-bar__percent visually-hidden" id="advantage-white-percent">50%</span>
            </span>
            <span class="advantage-bar__side advantage-bar__side--black">
              <span class="advantage-bar__percent visually-hidden" id="advantage-black-percent">50%</span>
              <span class="advantage-bar__side-label visually-hidden">Black</span>
            </span>
          </div>
        </div>
      </div>

      <div id="info-line">
        <span id="status" class="status-text" role="status" aria-live="polite" data-turn="white" data-state="normal" aria-label="White to move">
          <span class="status-text__label">White to move</span>
        </span>
        <span class="info-line-item" id="evaluation-container" aria-hidden="true" hidden>
          <span id="evaluation" class="evaluation-indicator" role="img" aria-label="Eval: --" data-probability="0.5">
            <span class="visually-hidden">Eval: --</span>
          </span>
        </span>
      </div>
      <div class="probability-panel" id="probability-panel" hidden>
        <div class="probability-panel__graph" id="evaluation-nav" role="listbox" aria-label="Evaluation graph timeline"></div>
      </div>
    </div>
    <div id="controls">
      <button id="prev-button" class="control-button" type="button" disabled aria-label="Previous move">
        <span class="control-button__label" aria-hidden="true">Prev</span>
        <span class="visually-hidden">Previous move</span>
      </button>
      <button id="next-button" class="control-button" type="button" disabled aria-label="Next move">
        <span class="control-button__label" aria-hidden="true">Next</span>
        <span class="visually-hidden">Next move</span>
      </button>
      <button id="best-move-button" class="control-button" type="button" disabled aria-pressed="false" aria-label="Show best move">
        <span class="control-button__label" aria-hidden="true">Best</span>
        <span class="visually-hidden">Show best move</span>
      </button>
      <button id="advantage-toggle-button" class="control-button" type="button" aria-pressed="false" aria-label="Show advantage bar">
        <span class="control-button__label" aria-hidden="true">Gauge</span>
        <span class="visually-hidden">Show advantage bar</span>
      </button>
      <button id="probability-button" class="control-button" type="button" aria-pressed="false" aria-label="Show evaluation graph">
        <span class="control-button__label" aria-hidden="true">Graph</span>
        <span class="visually-hidden">Show evaluation graph</span>
      </button>
      <button id="piece-moves-button" class="control-button" type="button" aria-pressed="false" aria-label="Show piece moves">
        <span class="control-button__label" aria-hidden="true">Piece</span>
        <span class="visually-hidden">Show piece moves</span>
      </button>
      <button id="flip-button" class="control-button" type="button" aria-label="Flip board">
        <span class="control-button__label" aria-hidden="true">Flip</span>
        <span class="visually-hidden">Flip board</span>
      </button>
      <button id="edit-button" class="control-button" type="button" aria-pressed="false" aria-label="Enter edit mode">
        <span class="control-button__label" aria-hidden="true">Edit</span>
        <span class="visually-hidden">Enter edit mode</span>
      </button>
      <button id="fen-button" class="control-button" type="button" aria-label="Load FEN or PGN">
        <span class="control-button__label" aria-hidden="true">Input</span>
        <span class="visually-hidden">Load FEN or PGN</span>
      </button>
      <button id="engine-button" class="control-button" type="button" aria-pressed="false" aria-label="Show engine settings">
        <span class="control-button__label" aria-hidden="true">Engine</span>
        <span class="visually-hidden">Show engine settings</span>
      </button>
    </div>
    <section id="engine-settings" class="engine-settings" hidden aria-hidden="true">
      <div class="engine-settings__header">
        <h2 class="engine-settings__title">Engine</h2>
        <span id="engine-status" class="engine-settings__status" data-state="idle" aria-live="polite">Not started</span>
      </div>
      <form class="engine-settings__form" aria-label="Engine configuration">
        <label class="engine-field" for="engine-threads">
          <span class="engine-field__label">Threads</span>
          <input id="engine-threads" class="engine-field__input" name="threads" type="number" min="1" max="64" step="1" inputmode="numeric" value="4">
        </label>
        <label class="engine-field" for="engine-hash">
          <span class="engine-field__label">Hash (MB)</span>
          <input id="engine-hash" class="engine-field__input" name="hash" type="number" min="1" max="256" step="1" inputmode="numeric" value="128">
        </label>
        <label class="engine-field" for="engine-depth">
          <span class="engine-field__label">Depth</span>
          <input id="engine-depth" class="engine-field__input" name="depth" type="number" min="1" max="99" step="1" inputmode="numeric" value="24">
        </label>
      </form>
      <p class="engine-settings__help" id="engine-settings-help"></p>
      <div id="engine-error" class="engine-settings__error" role="alert" hidden></div>
      <div class="engine-settings__actions">
        <button type="button" id="engine-start-button" class="engine-action-button engine-action-button--primary">
          <span class="engine-action-button__label">Start</span>
        </button>
        <button type="button" id="engine-stop-button" class="engine-action-button" disabled>
          <span class="engine-action-button__label">Cease</span>
        </button>
      </div>
    </section>
  </div>
  <script>
  $(function() {
    let board, engine;
    const game = new Chess();
    const boardEl = $('#board');
    const advantageBarElement = document.getElementById('advantage-bar');
    const advantageTrackElement = document.getElementById('advantage-track');
    const advantageStatusElement = document.getElementById('advantage-status');
    const advantageWhiteElement = document.getElementById('advantage-white-percent');
    const advantageBlackElement = document.getElementById('advantage-black-percent');
    const advantageToggleButton = document.getElementById('advantage-toggle-button');
    const probabilityPanel = document.getElementById('probability-panel');
    const evaluationContainer = document.getElementById('evaluation-container');
    const evaluationElement = document.getElementById('evaluation');
    const bestMoveButtonElement = document.getElementById('best-move-button');
    const probabilityButtonElement = document.getElementById('probability-button');
    const pieceMovesButtonElement = document.getElementById('piece-moves-button');
    const editButtonElement = document.getElementById('edit-button');
    const engineButtonElement = document.getElementById('engine-button');
    const engineSettingsElement = document.getElementById('engine-settings');
    const engineStatusElement = document.getElementById('engine-status');
    const engineErrorElement = document.getElementById('engine-error');
    const engineHelpElement = document.getElementById('engine-settings-help');
    const engineStartButtonElement = document.getElementById('engine-start-button');
    const engineStopButtonElement = document.getElementById('engine-stop-button');
    const engineThreadsInput = document.getElementById('engine-threads');
    const engineHashInput = document.getElementById('engine-hash');
    const engineDepthInput = document.getElementById('engine-depth');
    const statusElement = document.getElementById('status');
    let baseFen = game.fen();
    let selectedSquare = null;
    let moveSourceSquare = null;
    let isPieceAnalysis = false;
    let freezeMode = false;
    let editMode = false;
    let pieceMovesMode = false;
    let orientation = 'white';
    let latestAnalysisFen = null;
    let shouldHighlightBest = false;
    let engineReady = false;
    let engineCommandQueue = [];
    let engineAwaitingReadyAfterStop = false;
    let editSelectedPiece = null;
    let editSelectedSquare = null;
    let editSelectionSource = null;
    let bestMoveVisible = false;
    let moveHistory = [];
    let navigationIndex = 0;
    
    // --- FIX: Added missing variable declaration ---
    let enginePanelVisible = false;

    const STOCKFISH_WORKER_VARIANTS = [{
      filename: 'stockfish-17.1-lite-single-03e3232.js',
      requiresThreadSupport: false
    }];
    const threadSupportAvailable = typeof(SharedArrayBuffer) === 'function';
    const selectedStockfishVariant = (() => {
      for (const variant of STOCKFISH_WORKER_VARIANTS) {
        if (!variant) continue;
        if (variant.requiresThreadSupport && !threadSupportAvailable) {
          continue;
        }
        return variant;
      }
      return null;
    })();
    const ENGINE_THREADS_MIN = 1;
    const ENGINE_THREADS_MAX = selectedStockfishVariant && selectedStockfishVariant.requiresThreadSupport === false ?
      1 :
      64;
    const DEFAULT_ANALYSIS_DEPTH = 24;
    const PGN_REPLAY_DEPTH = 12;
    const BACKGROUND_EVAL_DEPTH = 24;
    const PROBABILITY_GRAPH_DEPTH = 14;
    const AUTO_NEXT_MOVE_DEPTH = 22;
    const DEFAULT_THREADS = Math.min(4, ENGINE_THREADS_MAX);
    const DEFAULT_HASH_MB = 128;
    const MAX_USER_HASH_MB = 256;
    const MIN_HASH_CEILING_MB = 32;
    const BACKGROUND_HASH_MAX_MB = 64;
    const BACKGROUND_HASH_MIN_MB = 16;
    const engineConfig = {
      threads: DEFAULT_THREADS,
      hash: DEFAULT_HASH_MB,
      depth: DEFAULT_ANALYSIS_DEPTH
    };
    const ENGINE_AUTOSTART_DELAY_MS = 400;
    const ENGINE_AUTOSTART_MAX_ATTEMPTS = 3;
    const AUTO_PLAY_MIN_WAIT_MS = 4000;
    const REPLAY_STEP_DELAY_MS = 900;
    const PIECE_ANALYSIS_MODE_SEQUENTIAL = 'sequential';
    let autoPlayPending = false;
    let autoPlayTargetDepth = engineConfig.depth;
    let autoPlayFen = null;
    let currentBestMove = null;
    let currentDepth = 0;
    let pieceMoveRatings = new Map();
    let pieceAnalysisMode = null;
    let pieceAnalysisTurn = null;
    let pieceAnalysisQueue = [];
    let pieceAnalysisCurrentMove = null;
    let pieceAnalysisActiveRequestId = 0;
    let pieceAnalysisFen = null;
    let pieceAnalysisTargetDepth = 0;
    let pieceAnalysisWaitingForResult = false;
    let waitingForAutoBestMove = false;
    let autoMoveCandidate = null;
    let autoPlayRequestedAt = 0;
    let autoPlayDelayTimer = null;
    let autoPlayDepthSatisfied = false;
    const evaluationNavElement = document.getElementById('evaluation-nav');
    let advantageBarVisible = false;
    let probabilityPanelVisible = false;
    let evaluationTimeline = [];
    let engineStarting = false;
    let engineAutostartTimer = null;
    let engineAutostartScheduled = false;
    let engineAutostartAttempts = 0;
    let engineLastStartWasAutostart = false;
    let engineAutostartDisabled = false;

    function setButtonLabel(element, label) {
      if (!element || typeof label !== 'string') return;
      element.setAttribute('aria-label', label);
      const hidden = element.querySelector('.visually-hidden');
      if (hidden) hidden.textContent = label;
      const visible = element.querySelector('.control-button__label');
      if (visible) visible.textContent = label;
    }

    function setButtonActive(element, isActive, activeLabel, inactiveLabel) {
      if (!element) return;
      element.classList.toggle('is-active', !!isActive);
      if (element.hasAttribute('aria-pressed')) {
        element.setAttribute('aria-pressed', isActive ? 'true' : 'false');
      }
      if (isActive && activeLabel) {
        setButtonLabel(element, activeLabel);
      } else if (!isActive && inactiveLabel) {
        setButtonLabel(element, inactiveLabel);
      }
    }

    function syncBestMoveButton() {
      setButtonActive(bestMoveButtonElement, bestMoveVisible, 'Hide best move', 'Best');
    }

    function syncAdvantageButton() {
      setButtonActive(advantageToggleButton, advantageBarVisible, 'Hide advantage bar', 'Gauge');
    }

    function syncProbabilityButton() {
      setButtonActive(probabilityButtonElement, probabilityPanelVisible, 'Hide evaluation graph', 'Graph');
    }

    function syncPieceMovesButton() {
      setButtonActive(pieceMovesButtonElement, pieceMovesMode, 'Return to play mode', 'Piece');
    }

    function syncEditButton() {
      setButtonActive(editButtonElement, editMode, 'Exit edit mode', 'Edit');
    }

    function syncEngineButton() {
      setButtonActive(engineButtonElement, enginePanelVisible, 'Hide engine settings', 'Engine');
    }

    function syncEnginePanelVisibility() {
      if (!engineSettingsElement) return;
      if (enginePanelVisible) {
        engineSettingsElement.hidden = false;
        engineSettingsElement.setAttribute('aria-hidden', 'false');
      } else {
        engineSettingsElement.hidden = true;
        engineSettingsElement.setAttribute('aria-hidden', 'true');
      }
      syncEngineButton();
    }

    function setEngineStatusDisplay(state, label) {
      if (!engineStatusElement) return;
      const normalizedState = state || 'idle';
      engineStatusElement.dataset.state = normalizedState;
      engineStatusElement.textContent = label || '';
    }

    function setEngineErrorMessage(message) {
      if (!engineErrorElement) return;
      if (message) {
        engineErrorElement.hidden = false;
        engineErrorElement.textContent = message;
      } else {
        engineErrorElement.hidden = true;
        engineErrorElement.textContent = '';
      }
      engineErrorElement.dataset.source = '';
    }

    function resetEngineCommandQueue() {
      engineCommandQueue = [];
      engineAwaitingReadyAfterStop = false;
    }

    function postEngineCommand(command, options = {}) {
      if (!engine) return;
      const text = typeof command === 'string' ? command.trim() : '';
      if (!text) return;
      const {
        queueIfPending = true
      } = options;
      if (queueIfPending && engineAwaitingReadyAfterStop) {
        engineCommandQueue.push(text);
        return;
      }
      try {
        engine.postMessage(text);
      } catch (error) {
        console.warn(`Failed to send command to engine: ${text}`, error);
      }
    }

    function beginEngineReadyWait() {
      if (!engine || engineAwaitingReadyAfterStop) {
        return;
      }
      engineAwaitingReadyAfterStop = true;
      try {
        engine.postMessage('isready');
      } catch (error) {
        engineAwaitingReadyAfterStop = false;
        engineCommandQueue = [];
        console.warn('Failed to send isready command to engine', error);
      }
    }

    function queueEngineCommands(commands) {
      if (Array.isArray(commands)) {
        commands.forEach(cmd => postEngineCommand(cmd));
        return;
      }
      postEngineCommand(commands);
    }

    function resolveEngineReadyWait() {
      if (!engineAwaitingReadyAfterStop) {
        return;
      }
      const queued = engineCommandQueue.slice();
      engineCommandQueue = [];
      engineAwaitingReadyAfterStop = false;
      if (!engine || !queued.length) {
        return;
      }
      queued.forEach(cmd => postEngineCommand(cmd, {
        queueIfPending: false
      }));
    }

    function displayEngineConfigWarnings(result) {
      if (result && Array.isArray(result.warnings) && result.warnings.length) {
        setEngineErrorMessage(result.warnings.join(' '));
      } else if (engineErrorElement && engineErrorElement.dataset.source === 'config-warning') {
        setEngineErrorMessage('');
      }
      if (engineErrorElement) {
        engineErrorElement.dataset.source = result && result.warnings && result.warnings.length ? 'config-warning' : '';
      }
    }

    function clampInteger(value, min, max, fallback) {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) {
        return fallback;
      }
      const truncated = Math.floor(numeric);
      if (!Number.isFinite(truncated)) {
        return fallback;
      }
      const clamped = Math.max(min, Math.min(max, truncated));
      return clamped;
    }

    function getDeviceMemoryInGb() {
      if (typeof navigator !== 'undefined' && navigator) {
        const {
          deviceMemory
        } = navigator;
        const numeric = Number(deviceMemory);
        if (Number.isFinite(numeric) && numeric > 0) {
          return numeric;
        }
      }
      return null;
    }

    function formatDeviceMemoryGb(value) {
      if (!Number.isFinite(value) || value <= 0) {
        return null;
      }
      if (value >= 4) {
        return Math.round(value);
      }
      return Math.round(value * 10) / 10;
    }

    function resolveHashConstraints() {
      const deviceMemoryGb = getDeviceMemoryInGb();
      let ceiling = MAX_USER_HASH_MB;
      if (deviceMemoryGb !== null) {
        const derived = Math.floor(deviceMemoryGb * 64);
        if (derived > 0) {
          ceiling = Math.min(ceiling, Math.max(MIN_HASH_CEILING_MB, derived));
        }
      }
      ceiling = Math.max(MIN_HASH_CEILING_MB, ceiling);
      return {
        ceiling,
        deviceMemoryGb
      };
    }

    function computeBackgroundHashBudget(mainHash) {
      const {
        ceiling
      } = resolveHashConstraints();
      const quarter = Math.floor(ceiling / 4);
      return Math.max(BACKGROUND_HASH_MIN_MB, Math.min(BACKGROUND_HASH_MAX_MB, quarter));
    }

    // --- START: Added missing logic ---

    function updateStatus() {
      const turn = game.turn() === 'w' ? 'White' : 'Black';
      let state = 'normal';
      let statusText = `${turn} to move`;

      if (game.in_checkmate()) {
        statusText = `Checkmate! ${turn === 'White' ? 'Black' : 'White'} wins.`;
        state = 'mate';
      } else if (game.in_draw()) {
        statusText = 'Draw';
        state = 'draw';
      } else if (game.in_stalemate()) {
        statusText = 'Draw (Stalemate)';
        state = 'draw';
      } else if (game.in_threefold_repetition()) {
        statusText = 'Draw (Threefold Repetition)';
        state = 'draw';
      } else if (game.insufficient_material()) {
        statusText = 'Draw (Insufficient Material)';
        state = 'draw';
      } else if (game.in_check()) {
        statusText += ' (in check)';
        state = 'check';
      }

      const statusLabel = statusElement.querySelector('.status-text__label');
      if (statusLabel) {
        statusLabel.textContent = statusText;
      }
      statusElement.dataset.turn = game.turn() === 'w' ? 'white' : 'black';
      statusElement.dataset.state = state;

      // Update navigation buttons
      $('#prev-button').prop('disabled', navigationIndex <= 0);
      $('#next-button').prop('disabled', navigationIndex >= moveHistory.length - 1);
    }
    
    function startAnalysis() {
        if (!engineReady || game.game_over()) {
            bestMoveButtonElement.disabled = true;
            return;
        }
        bestMoveButtonElement.disabled = false;
        postEngineCommand(`position fen ${game.fen()}`);
        postEngineCommand(`go depth ${engineConfig.depth}`);
    }

    function onDragStart(source, piece) {
      if (game.game_over() || freezeMode || editMode ||
        (game.turn() === 'w' && piece.search(/^b/) !== -1) ||
        (game.turn() === 'b' && piece.search(/^w/) !== -1) ||
        (navigationIndex < moveHistory.length -1) // Can't move if navigating history
      ) {
        return false;
      }
    }

    function onDrop(source, target) {
      if (freezeMode) return 'snapback';
      
      const move = game.move({
        from: source,
        to: target,
        promotion: 'q' // NOTE: always promote to a queen for simplicity
      });

      if (move === null) {
        return 'snapback';
      }
      
      moveHistory.push(move);
      navigationIndex = moveHistory.length;

      updateStatus();
      startAnalysis();
    }

    function onSnapEnd() {
      board.position(game.fen());
    }
    
    // --- Board Initialization ---
    const boardConfig = {
      draggable: true,
      position: 'start',
      onDragStart: onDragStart,
      onDrop: onDrop,
      onSnapEnd: onSnapEnd,
      pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png'
    };
    board = Chessboard('board', boardConfig);
    
    updateStatus(); // Initial status update
    
    // --- Event Listeners for Controls ---
    $('#flip-button').on('click', () => {
        orientation = orientation === 'white' ? 'black' : 'white';
        board.orientation(orientation);
    });
    
    $('#edit-button').on('click', () => {
        editMode = !editMode;
        syncEditButton();
        board.resize(); // Re-renders board, useful for edit mode changes
    });
    
    $('#engine-button').on('click', () => {
        enginePanelVisible = !enginePanelVisible;
        syncEnginePanelVisibility();
    });

    $('#advantage-toggle-button').on('click', () => {
        advantageBarVisible = !advantageBarVisible;
        $('#advantage-bar').attr('hidden', !advantageBarVisible);
        syncAdvantageButton();
    });

    $('#probability-button').on('click', () => {
        probabilityPanelVisible = !probabilityPanelVisible;
        $('#probability-panel').attr('hidden', !probabilityPanelVisible);
        syncProbabilityButton();
    });

    $('#piece-moves-button').on('click', () => {
        pieceMovesMode = !pieceMovesMode;
        syncPieceMovesButton();
    });
    
    $('#best-move-button').on('click', () => {
        bestMoveVisible = !bestMoveVisible;
        syncBestMoveButton();
    });

    $('#prev-button').on('click', () => {
        if (navigationIndex > 0) {
            navigationIndex--;
            game.undo();
            board.position(game.fen());
            updateStatus();
        }
    });

    $('#next-button').on('click', () => {
        // This requires re-doing moves, which isn't simple with chess.js `undo`.
        // A proper implementation would replay from the start or store move objects.
        // For now, this button logic will be simplified.
        console.log("Next move functionality requires a more complex history management.");
    });
    
    $('#fen-button').on('click', () => {
        const fen = prompt("Enter FEN or PGN string:");
        if (fen) {
            const validFen = game.load(fen);
            if (validFen) {
                board.position(game.fen());
                moveHistory = [];
                navigationIndex = 0;
                updateStatus();
                startAnalysis();
            } else {
                alert("Invalid FEN or PGN string.");
            }
        }
    });
    
    // --- Engine Initialization ---
    function initializeEngine() {
        setEngineStatusDisplay('loading', 'Loading...');
        try {
            // Assuming stockfish worker file is in a 'js' subfolder
            engine = new Worker('js/stockfish.js');
            engine.onmessage = (event) => {
                const message = event.data;
                if (message === 'uciok') {
                    engineReady = true;
                    setEngineStatusDisplay('ready', 'Ready');
                    engineStopButtonElement.disabled = false;
                    engineStartButtonElement.disabled = true;
                    postEngineCommand('ucinewgame');
                    startAnalysis();
                } else if (message.startsWith('bestmove')) {
                    const bestMove = message.split(' ')[1];
                    currentBestMove = bestMove;
                    console.log(`Best move: ${bestMove}`);
                }
            };
            postEngineCommand('uci');
        } catch (error) {
            setEngineStatusDisplay('error', 'Error');
            console.error("Failed to load Stockfish engine:", error);
        }
    }
    
    $('#engine-start-button').on('click', initializeEngine);
    $('#engine-stop-button').on('click', () => {
        if (engine) {
            engine.terminate();
            engine = null;
            engineReady = false;
            setEngineStatusDisplay('idle', 'Not started');
            engineStopButtonElement.disabled = true;
            engineStartButtonElement.disabled = false;
        }
    });
    
    // Auto-start the engine for convenience
    initializeEngine();

    // --- END: Added missing logic ---
  });
</script>
</body>
</html>
