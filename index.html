<!DOCTYPE html><html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chess Interface</title>
  <style>
    :root {
      color-scheme: dark;
    }

    body {
      font-family: "Inter", "Segoe UI", sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background: radial-gradient(circle at top, #2b2f46 0%, #10121c 55%, #06070c 100%);
      margin: 0;
      padding: 24px;
      color: #eef0f6;
    }

    .container {
      width: 100%;
      max-width: 960px;
      display: flex;
      flex-direction: column;
      gap: 24px;
      align-items: stretch;
    }

    .board-shell {
      background: rgba(20, 20, 31, 0.94);
      border-radius: 28px;
      padding: 28px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      box-shadow: 0 28px 60px rgba(3, 6, 16, 0.55);
    }

    .eval-bar {
      width: 100%;
      display: flex;
      align-items: center;
      gap: 14px;
    }

    #gauge {
      position: relative;
      flex: 1 1 auto;
      height: 18px;
      border-radius: 999px;
      background: linear-gradient(90deg, #11131d 0%, #2f344b 100%);
      border: 1px solid rgba(255, 255, 255, 0.12);
      overflow: hidden;
    }

    #gauge-white {
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      background: linear-gradient(90deg, #d2d8f7 0%, #f3f5ff 100%);
      width: 50%;
      transition: width 0.35s ease;
    }

    #evaluation-label {
      font-size: 0.9rem;
      color: #d4d9eb;
      min-width: 70px;
      text-align: right;
      font-weight: 600;
    }

    .board-container {
      width: 100%;
      display: flex;
      justify-content: center;
    }

    #board {
      width: min(72vw, 440px);
      max-width: 440px;
    }

    #info-line {
      width: 100%;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 12px;
      font-size: 0.98rem;
      color: #f3f6ff;
      font-weight: 600;
    }

    #status {
      margin: 0;
      white-space: nowrap;
    }

    .info-line-item {
      display: flex;
      gap: 6px;
      align-items: center;
      white-space: nowrap;
    }

    .info-line-item span:last-child {
      color: #dce1ff;
    }

    #controls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 12px;
    }

    button {
      margin: 0;
      padding: 10px 18px;
      border: none;
      border-radius: 14px;
      color: #fff;
      cursor: pointer;
      background: linear-gradient(135deg, #4856ff 0%, #232d97 100%);
      font-weight: 600;
      letter-spacing: 0.02em;
      transition: transform 0.15s ease, box-shadow 0.15s ease, filter 0.15s ease;
      min-width: 120px;
    }

    button:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 12px 24px rgba(35, 52, 158, 0.45);
    }

    button:disabled {
      background: rgba(84, 90, 128, 0.4);
      cursor: not-allowed;
      box-shadow: none;
    }

    #piece-moves-button {
      background: linear-gradient(135deg, #1dbfcc 0%, #136677 100%);
    }

    #flip-button {
      background: linear-gradient(135deg, #34c964 0%, #127035 100%);
    }

    #edit-button {
      background: linear-gradient(135deg, #ffd96f 0%, #e6a421 100%);
      color: #1d1d1d;
    }

    .highlight-selection {
      box-shadow: inset 0 0 0 3px #f2ff5f !important;
    }

    .highlight-move-from,
    .highlight-move-to {
      background: rgba(255, 255, 0, 0.38) !important;
    }

    .move-rating {
      position: absolute;
      bottom: 6px;
      right: 6px;
      background: rgba(9, 12, 24, 0.82);
      color: #f6f9ff;
      font-size: 12px;
      padding: 3px 5px;
      border-radius: 6px;
      pointer-events: none;
      z-index: 5;
    }

    .board-container .chessboard-7492f {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }

    .board-container .board-b72b1 {
      order: 1;
    }

    .board-container .spare-pieces-top,
    .board-container .spare-pieces-bottom {
      order: 2;
      margin-top: 6px;
      display: none;
    }

    .board-container.editing .spare-pieces-top,
    .board-container.editing .spare-pieces-bottom {
      display: flex;
    }

    .board-container .spare-pieces-7492f {
      justify-content: center;
      gap: 6px;
    }

    .board-container.editing .spare-pieces-7492f {
      display: flex;
    }

    @media (max-width: 1024px) {
      .board-shell {
        padding: 24px;
      }
    }

    @media (max-width: 768px) {
      .eval-bar {
        flex-direction: column;
        align-items: stretch;
        gap: 8px;
      }

      #evaluation-label {
        text-align: left;
      }
    }

    @media (max-width: 640px) {
      body {
        padding: 16px;
      }

      .container {
        gap: 20px;
      }

      #board {
        width: min(86vw, 420px);
      }

      button {
        min-width: 110px;
        padding: 10px 16px;
        font-size: 0.92rem;
      }
    }

    @media (max-width: 420px) {
      #info-line {
        font-size: 0.9rem;
        gap: 8px;
      }
    }
  </style>
  <script src="libs/jquery.min.js"></script>
  <link href="libs/chessboard-1.0.0.min.css" rel="stylesheet">
  <script src="libs/chessboard-1.0.0.min.js"></script>
  <script src="libs/chess.min.js"></script>
</head>
<body>
  <div class="container">
    <div class="board-shell">
      <div class="eval-bar">
        <span id="evaluation-label">Advantage</span>
        <div id="gauge"><div id="gauge-white"></div></div>
      </div>
      <div class="board-container">
        <div id="board"></div>
      </div>
      <div id="info-line">
        <span id="status">Ready</span>
        <span class="info-line-item"><span>Best:</span><span id="best-move">N/A</span></span>
        <span class="info-line-item"><span>Eval:</span><span id="evaluation">N/A</span></span>
      </div>
    </div>
    <div id="controls">
      <button id="best-move-button" disabled>Best</button>
      <button id="piece-moves-button">Piece</button>
      <button id="flip-button">Flip</button>
      <button id="edit-button">Edit</button>
      <button id="fen-button">FEN</button>
    </div>
  </div>
  <script>
    $(function() {
      let board, engine;
      const game = new Chess();
      const boardEl = $('#board');
      let selectedSquare = null;
      let moveSourceSquare = null;
      let isPieceAnalysis = false;
      let freezeMode = false;
      let editMode = false;
      let pieceMovesMode = false;
      let orientation = 'white';
      let latestAnalysisFen = null;
      let shouldHighlightBest = true;
      let engineReady = false;

      function updateGauge(cp) {
        const clamped = Math.max(-2000, Math.min(2000, cp));
        const pct = ((clamped + 2000) / 4000) * 100;
        $('#gauge-white').css('width', pct + '%');
      }

  function clearSelectionHighlight() {
    boardEl.find('.highlight-selection').removeClass('highlight-selection');
  }

  function highlightSelection(square) {
    if (!square) return;
    boardEl.find(`.square-${square}`).addClass('highlight-selection');
  }

  function applySelectionHighlights() {
    clearSelectionHighlight();
    if (pieceMovesMode && selectedSquare) {
      highlightSelection(selectedSquare);
    } else if (!pieceMovesMode && moveSourceSquare) {
      highlightSelection(moveSourceSquare);
    }
  }

  function handleSquareClick(square) {
    if (!square) return;
    if (editMode) return;

    if (pieceMovesMode) {
      selectedSquare = square;
      applySelectionHighlights();
      analyzeMoves();
      return;
    }

    if (freezeMode || game.game_over()) return;

    const piece = game.get(square);
    const turn = game.turn();

    if (!moveSourceSquare) {
      if (!piece || piece.color !== turn) return;
      moveSourceSquare = square;
      applySelectionHighlights();
      return;
    }

    if (moveSourceSquare === square) {
      moveSourceSquare = null;
      applySelectionHighlights();
      return;
    }

    clearHighlights();
    clearRatings();

    const move = game.move({ from: moveSourceSquare, to: square, promotion: 'q' });

    if (move) {
      moveSourceSquare = null;
      renderBoard();
      updateStatus();
      requestAnalysis();
    } else {
      if (piece && piece.color === turn) {
        moveSourceSquare = square;
      }
      applySelectionHighlights();
    }
  }

  function renderBoard() {
    const cfg = {
      position: game.fen(),
      draggable: editMode,
      sparePieces: editMode,
      orientation: orientation,
      onDragStart: onDragStart,
      onDrop: onDrop,
      onSnapEnd: onSnapEnd,
      pieceTheme: p => {
        if (!p) return '';
        const color = p[0] === 'w' ? 'white' : 'black';
        const map = {K:'king',Q:'queen',R:'rook',B:'bishop',N:'knight',P:'pawn'};
        return `pieces/${color}-${map[p[1]]}.png`;
      }
    };
    if (board) board.destroy();
    board = Chessboard('board', cfg);
    $('.board-container').toggleClass('editing', editMode);
    board.resize();
    requestAnimationFrame(() => board && board.resize());
    boardEl.off('click.square').on('click.square', 'div.square-55d63', function() {
      const cls = $(this).attr('class').split(/\s+/);
      const sq = cls.find(c => /^square-[a-h][1-8]$/.test(c));
      if (!sq) return;
      handleSquareClick(sq.replace('square-',''));
    });
    applySelectionHighlights();
    if (!editMode && !pieceMovesMode && shouldHighlightBest) {
      const currentBest = $('#best-move').text().trim();
      if (/^[a-h][1-8][a-h][1-8]$/.test(currentBest)) {
        visualize(currentBest);
      }
    }
  }

  function updateStatus() {
    const turn = game.turn() === 'b' ? 'Black' : 'White';
    let txt = '';
    if (game.in_checkmate()) txt = `Game over, ${turn} in checkmate.`;
    else if (game.in_draw()) txt = 'Game over, drawn position';
    else txt = `${turn} to move${game.in_check() ? `, ${turn} is in check` : ''}`;
    $('#status').text(txt);
  }

  function onDragStart(src, piece) {
    if (editMode) return true;
    if (freezeMode) return false;
    return !game.game_over() && ((game.turn() === 'w' && piece[0] === 'w') || (game.turn() === 'b' && piece[0] === 'b'));
  }

  function onDrop(src, tgt, piece, newPos) {
    clearHighlights(); clearRatings();
    if (editMode) {
      game.clear();
      Object.entries(newPos).forEach(([sq,p]) => { if (p) game.put({type:p[1].toLowerCase(), color:p[0]}, sq); });
      renderBoard(); updateStatus(); requestAnalysis();
      return;
    }
    if (freezeMode && !editMode) return 'snapback';
    const m = game.move({from:src,to:tgt,promotion:'q'});
    if (!m) return 'snapback';
    renderBoard(); updateStatus(); requestAnalysis();
  }

  function onSnapEnd() { if (!editMode) board.position(game.fen()); }
  function clearHighlights() { boardEl.find('.highlight-move-from, .highlight-move-to').removeClass('highlight-move-from highlight-move-to'); }
  function clearRatings() { boardEl.find('.move-rating').remove(); }

  function initEngine() {
    engine = new Worker('./engine/stockfish.js');
    engine.onmessage = e => {
      const line = String(e.data).trim();

      if (line === 'uciok') {
        engine.postMessage('isready');
        return;
      }

      if (line === 'readyok') {
        engineReady = true;
        $('#best-move-button').prop('disabled', false);
        requestAnalysis();
        return;
      }

      if (isPieceAnalysis && line.startsWith('info') && line.includes('multipv')) {
        const cp = line.match(/score cp (-?\d+)/);
        const mate = line.match(/score mate (-?\d+)/);
        const pv = line.match(/pv ([a-h][1-8][a-h][1-8])/);
        if (pv) {
          const destination = pv[1].slice(2);
          const score = cp ? (parseInt(cp[1], 10) / 100).toFixed(2) : mate ? `M${mate[1]}` : '';
          boardEl.find(`.square-${destination}`).append(`<div class="move-rating">${score}</div>`);
        }
        return;
      }

      if (line.startsWith('bestmove')) {
        if (isPieceAnalysis) {
          isPieceAnalysis = false;
          engine.postMessage('setoption name MultiPV value 1');
          if (!pieceMovesMode) {
            requestAnalysis({ highlight: shouldHighlightBest });
          }
        } else if (latestAnalysisFen && latestAnalysisFen === game.fen()) {
          const parts = line.split(' ');
          const move = parts[1];
          const best = !move || move === '(none)' ? 'N/A' : move;
          $('#best-move').text(best);
          if (!move || move === '(none)') {
            clearHighlights();
          } else if (shouldHighlightBest) {
            visualize(move);
          }
        }
        return;
      }

      if (!isPieceAnalysis && line.includes('info depth') && line.includes('score')) {
        if (!latestAnalysisFen || latestAnalysisFen !== game.fen()) return;

        const cp2 = line.match(/score cp (-?\d+)/);
        const mate2 = line.match(/score mate (-?\d+)/);

        if (cp2) {
          const v = parseInt(cp2[1], 10);
          const prefix = v > 0 ? '+' : '';
          $('#evaluation').text(`${prefix}${(v / 100).toFixed(2)}`);
          updateGauge(v);
        } else if (mate2) {
          const mateScore = parseInt(mate2[1], 10);
          $('#evaluation').text(`Mate in ${mate2[1]}`);
          updateGauge(mateScore > 0 ? 2000 : -2000);
        }
      }
    };
    engine.postMessage('uci');
  }

  function visualize(u) {
    clearHighlights();
    if (!u || u.length < 4) return;
    const from = u.slice(0, 2);
    const to = u.slice(2, 4);
    boardEl.find(`.square-${from}`).addClass('highlight-move-from');
    boardEl.find(`.square-${to}`).addClass('highlight-move-to');
  }

  function requestAnalysis(options = {}) {
    if (!engineReady || !engine) return;
    const { highlight = true } = options;
    latestAnalysisFen = game.fen();
    shouldHighlightBest = highlight;
    isPieceAnalysis = false;
    clearHighlights();
    clearRatings();
    $('#best-move').text('...');
    $('#evaluation').text('...');
    engine.postMessage('stop');
    engine.postMessage('setoption name MultiPV value 1');
    engine.postMessage(`position fen ${latestAnalysisFen}`);
    engine.postMessage('go depth 15');
  }

  function analyzeMoves() {
    clearHighlights();
    clearRatings();
    if (!selectedSquare) return;
    const moves = game.moves({ verbose: true }).filter(m => m.from === selectedSquare);
    if (!moves.length) return;
    isPieceAnalysis = true;
    engine.postMessage('stop');
    engine.postMessage(`setoption name MultiPV value ${moves.length}`);
    engine.postMessage(`position fen ${game.fen()}`);
    engine.postMessage(`go depth 15 searchmoves ${moves.map(m => m.from + m.to).join(' ')}`);
  }

  // UI hooks
  $('#best-move-button').on('click', () => { requestAnalysis(); });
  $('#piece-moves-button').on('click', () => {
    pieceMovesMode = !pieceMovesMode;
    freezeMode = pieceMovesMode;
    if (!pieceMovesMode) {
      requestAnalysis();
    }
    selectedSquare = null;
    moveSourceSquare = null;
    $('#piece-moves-button').text(pieceMovesMode ? 'Play' : 'Piece');
    clearHighlights();
    clearRatings();
    renderBoard();
    updateStatus();
  });
  $('#flip-button').on('click', () => {
    orientation = orientation === 'white' ? 'black' : 'white';
    renderBoard();
    updateStatus();
  });
  $('#edit-button').on('click', () => {
    editMode = !editMode;
    if (!editMode) {
      moveSourceSquare = null;
      requestAnalysis();
    }
    $('#edit-button').text(editMode ? 'Play' : 'Edit');
    renderBoard();
    updateStatus();
  });
  $('#fen-button').on('click', () => {
    const fen = prompt('Enter FEN');
    if (!fen) return;
    const trimmed = fen.trim();
    const ok = game.load(trimmed);
    if (!ok) {
      alert('Invalid FEN');
      return;
    }
    moveSourceSquare = null;
    selectedSquare = null;
    renderBoard();
    updateStatus();
    requestAnalysis();
  });

  renderBoard();
  updateGauge(0);
  initEngine();
  updateStatus();
  $(window).off('resize.board').on('resize.board', () => { if (board) board.resize(); });
});

  </script>
</body>
</html>