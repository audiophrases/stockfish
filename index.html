<!DOCTYPE html><html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chess Interface</title>
  
<style>
  :root {
    color-scheme: dark;
  }

  * {
    box-sizing: border-box;
  }

  body {
    margin: 0;
    min-height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    background: radial-gradient(circle at top, #1a2032 0%, #070910 75%);
    font-family: "Inter", "Segoe UI", sans-serif;
    color: #eef1ff;
  }

  .container {
    width: min(94vw, 540px);
    display: flex;
    flex-direction: column;
    align-items: stretch;
    gap: 26px;
  }

  .responsive-layout {
    width: 100%;
    display: flex;
    flex-direction: column;
    gap: 28px;
  }

  .board-shell {
    width: 100%;
    background: rgba(8, 11, 20, 0.82);
    border: 1px solid rgba(255, 255, 255, 0.05);
    border-radius: 28px;
    padding: 24px 28px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
    box-shadow: 0 40px 80px rgba(0, 0, 0, 0.55);
  }

  .board-area {
    width: 100%;
    display: flex;
    flex-direction: column;
    gap: 20px;
    align-items: center;
  }

  .side-panel {
    width: 100%;
    display: flex;
    flex-direction: column;
    gap: 24px;
  }

  .side-panel__section {
    display: flex;
    flex-direction: column;
    gap: 16px;
  }

  .player-summary {
    display: inline-flex;
    align-items: baseline;
    gap: 8px;
    flex-wrap: wrap;
    padding: 12px 16px;
    border-radius: 16px;
    border: 1px solid rgba(255, 255, 255, 0.06);
    background: rgba(10, 14, 26, 0.85);
    color: #eef1ff;
    font-size: 0.95rem;
    line-height: 1.4;
    width: 100%;
    box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.02);
  }

  .player-summary__names {
    font-weight: 600;
  }

  .player-summary__divider {
    color: rgba(255, 255, 255, 0.28);
  }

  .player-summary__outcome {
    font-weight: 500;
    color: #b9c5ff;
  }

  .board-container {
    width: 100%;
    display: flex;
    justify-content: center;
  }

  #board {
    width: 100%;
    max-width: 480px;
  }

  .visually-hidden {
    border: 0 !important;
    clip: rect(1px, 1px, 1px, 1px) !important;
    clip-path: inset(50%) !important;
    height: 1px !important;
    margin: -1px !important;
    overflow: hidden !important;
    padding: 0 !important;
    position: absolute !important;
    width: 1px !important;
    white-space: nowrap !important;
  }

  #info-line {
    display: flex;
    align-items: center;
    gap: 14px;
    width: 100%;
    flex-wrap: wrap;
  }

  #status {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 6px 12px;
    border-radius: 999px;
    background: rgba(255, 255, 255, 0.07);
    color: #d8ddff;
    font-size: 0.72rem;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    font-weight: 600;
    line-height: 1.1;
    transition: background 0.3s ease, color 0.3s ease, box-shadow 0.2s ease;
  }

  #status .status-text__label {
    line-height: 1.2;
  }

  #status[data-turn="white"] {
    color: #f4f6ff;
  }

  #status[data-turn="black"] {
    color: #b9c5ff;
  }

  #status[data-state="check"] {
    background: rgba(255, 147, 101, 0.18);
    color: #ffb08a;
    box-shadow: 0 0 0 1px rgba(255, 147, 101, 0.18);
  }

  #status[data-state="mate"] {
    background: rgba(255, 112, 145, 0.22);
    color: #ff7da1;
    box-shadow: 0 0 0 1px rgba(255, 112, 145, 0.18);
  }

  #status[data-state="draw"] {
    background: rgba(188, 196, 226, 0.18);
    color: #d9defa;
    box-shadow: 0 0 0 1px rgba(188, 196, 226, 0.18);
  }

  #status.is-editing {
    cursor: pointer;
    box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.24);
  }

  #status.is-editing:focus-visible {
    outline: 2px solid rgba(143, 165, 255, 0.7);
    outline-offset: 2px;
  }

  .info-line-item {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
  }

  .info-line-item--gauge {
    flex: 1 1 160px;
    min-width: 0;
    justify-content: flex-end;
    gap: 12px;
    margin-left: auto;
  }

  .evaluation-indicator {
    --eval-scale: 0.5;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    min-width: 42px;
    padding: 3px 10px;
    border-radius: 999px;
    background: rgba(16, 22, 36, 0.85);
    border: 1px solid rgba(255, 255, 255, 0.12);
    color: #dbe1ff;
    font-size: 0.72rem;
    font-weight: 600;
    letter-spacing: 0.04em;
    font-variant-numeric: tabular-nums;
    text-transform: uppercase;
    line-height: 1;
    transition: background 0.3s ease, border-color 0.3s ease, color 0.3s ease;
  }

  .evaluation-indicator__value {
    display: inline-block;
    min-width: 3ch;
    text-align: center;
    letter-spacing: inherit;
  }

  .evaluation-indicator.is-white-favored {
    background: rgba(88, 124, 255, 0.22);
    border-color: rgba(150, 188, 255, 0.55);
    color: #f3f7ff;
  }

  .evaluation-indicator.is-black-favored {
    background: rgba(108, 90, 255, 0.16);
    border-color: rgba(174, 150, 255, 0.5);
    color: #e1deff;
  }

  .evaluation-indicator.is-balanced {
    background: rgba(255, 255, 255, 0.08);
    border-color: rgba(255, 255, 255, 0.12);
    color: #dbe1ff;
  }

  .advantage-bar {
    position: relative;
    flex: 1 1 auto;
    height: 10px;
    border-radius: 999px;
    overflow: hidden;
    background: rgba(10, 16, 28, 0.9);
    border: 1px solid rgba(255, 214, 102, 0.85);
    box-shadow: inset 0 0 0 1px rgba(120, 93, 14, 0.55);
    display: inline-block;
    min-width: 120px;
    transition: border-color 0.3s ease, box-shadow 0.3s ease, background 0.3s ease;
  }

  .advantage-bar[hidden] {
    display: none !important;
  }

  .advantage-bar__header,
  .advantage-bar__status,
  .advantage-bar__footer {
    display: none !important;
  }

  .advantage-bar__track {
    position: absolute;
    inset: 0;
    --white-ratio: 50%;
    background: linear-gradient(90deg, rgba(232, 240, 255, 0.92) 0%, rgba(232, 240, 255, 0.92) var(--white-ratio), rgba(19, 24, 40, 0.88) var(--white-ratio), rgba(19, 24, 40, 0.88) 100%);
    transition: background-position 0.35s ease;
  }

  .advantage-bar__track::after {
    content: '';
    position: absolute;
    top: 1px;
    bottom: 1px;
    width: 1px;
    left: calc(50% - 0.5px);
    background: rgba(255, 69, 58, 0.95);
    opacity: 0.9;
    pointer-events: none;
  }

  .advantage-bar.is-white-favored {
    border-color: rgba(255, 214, 102, 0.92);
    box-shadow: inset 0 0 0 1px rgba(199, 151, 20, 0.5);
    background: rgba(18, 30, 52, 0.9);
  }

  .advantage-bar.is-black-favored {
    border-color: rgba(255, 214, 102, 0.9);
    box-shadow: inset 0 0 0 1px rgba(185, 140, 16, 0.48);
    background: rgba(15, 16, 34, 0.92);
  }

  .advantage-bar.is-balanced {
    border-color: rgba(255, 214, 102, 0.85);
    box-shadow: inset 0 0 0 1px rgba(120, 93, 14, 0.55);
  }

  .advantage-bar.is-loading::before {
    content: '';
    position: absolute;
    inset: -1px;
    background: linear-gradient(90deg, transparent 0%, rgba(255, 255, 255, 0.25) 50%, transparent 100%);
    animation: indicator-slide 1.1s ease-in-out infinite;
    pointer-events: none;
    opacity: 0.6;
  }

  @keyframes indicator-slide {
    0% { transform: translateX(-60%); opacity: 0.1; }
    50% { transform: translateX(0%); opacity: 0.6; }
    100% { transform: translateX(60%); opacity: 0.1; }
  }

  @media (min-width: 1024px) and (orientation: landscape) {
    body {
      align-items: flex-start;
      padding: 48px 0;
    }

    .container {
      width: min(96vw, 1160px);
      margin: 0 auto;
    }

    .responsive-layout {
      flex-direction: row;
      align-items: flex-start;
      gap: 48px;
    }

    .board-shell {
      flex: 0 0 auto;
      max-width: 520px;
    }

    .side-panel {
      max-width: 420px;
      flex: 1 1 0%;
    }

    #info-line {
      justify-content: flex-start;
    }

    #board {
      max-width: 520px;
    }
  }

  button {
    appearance: none;
    border: none;
    background: none;
    padding: 0;
    cursor: pointer;
  }

  #controls {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 16px;
    width: 100%;
  }

  .control-button {
    position: relative;
    width: 100%;
    min-height: 48px;
    border-radius: 16px;
    background: rgba(255, 255, 255, 0.08);
    color: #eef1ff;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 12px 16px;
    text-align: center;
    font-size: 0.95rem;
    font-weight: 600;
    line-height: 1.2;
    transition: transform 0.2s ease, background 0.2s ease, box-shadow 0.2s ease, color 0.2s ease;
    box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.04);
  }

  .control-button:hover:not(:disabled) {
    transform: translateY(-2px);
    background: rgba(122, 140, 255, 0.28);
    box-shadow: 0 10px 24px rgba(70, 90, 200, 0.35);
  }

  .control-button:disabled {
    cursor: not-allowed;
    opacity: 0.35;
    transform: none;
  }

  .control-button.is-active {
    background: rgba(122, 140, 255, 0.35);
    box-shadow: 0 12px 28px rgba(88, 120, 255, 0.38);
  }

  .control-button__label {
    display: block;
    width: 100%;
    pointer-events: none;
  }

  .probability-panel {
    width: 100%;
    max-width: 480px;
    background: rgba(10, 14, 26, 0.85);
    border-radius: 20px;
    padding: 18px;
    border: 1px solid rgba(255, 255, 255, 0.05);
    backdrop-filter: blur(8px);
  }

  .probability-panel[hidden] {
    display: none !important;
  }

  .probability-panel__graph {
    width: 100%;
    height: 140px;
    position: relative;
  }

  .engine-settings {
    width: 100%;
    background: rgba(10, 14, 26, 0.85);
    border-radius: 22px;
    padding: 20px 22px;
    border: 1px solid rgba(255, 255, 255, 0.05);
    backdrop-filter: blur(8px);
    display: flex;
    flex-direction: column;
    gap: 18px;
  }

  .engine-settings[hidden] {
    display: none !important;
  }

  .engine-settings__header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 12px;
  }

  .engine-settings__title {
    margin: 0;
    font-size: 1rem;
    font-weight: 600;
    color: #eef1ff;
  }

  .engine-settings__status {
    font-size: 0.85rem;
    letter-spacing: 0.04em;
    text-transform: uppercase;
    color: #9ca6cf;
  }

  .engine-settings__status[data-state="ready"] {
    color: #7fe7c4;
  }

  .engine-settings__status[data-state="loading"] {
    color: #f7d58b;
  }

  .engine-settings__status[data-state="error"] {
    color: #ff9aad;
  }

  .engine-settings__form {
    display: grid;
    gap: 14px;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  }

  .engine-autostart-toggle {
    margin-top: 10px;
    display: inline-flex;
    align-items: center;
    gap: 10px;
    font-size: 0.85rem;
    color: #c9cfef;
    cursor: pointer;
  }

  .engine-autostart-toggle__input {
    width: 18px;
    height: 18px;
    accent-color: #7a8cff;
  }

  .engine-autostart-toggle__label {
    line-height: 1.4;
  }

  .engine-field {
    display: flex;
    flex-direction: column;
    gap: 6px;
    font-size: 0.85rem;
    color: #c9cfef;
  }

  .engine-field__input {
    border-radius: 12px;
    border: 1px solid rgba(255, 255, 255, 0.08);
    background: rgba(17, 21, 32, 0.9);
    color: #eef1ff;
    padding: 10px 12px;
    font-size: 1rem;
    transition: border 0.2s ease, box-shadow 0.2s ease;
  }

  .engine-field__input:focus {
    outline: none;
    border-color: rgba(130, 148, 255, 0.6);
    box-shadow: 0 0 0 2px rgba(130, 148, 255, 0.25);
  }

  .engine-settings__actions {
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
  }

  .engine-action-button {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    border-radius: 14px;
    padding: 10px 18px;
    font-size: 0.92rem;
    font-weight: 600;
    line-height: 1.1;
    background: rgba(255, 255, 255, 0.08);
    color: #eef1ff;
    box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.06);
    transition: transform 0.2s ease, background 0.2s ease, box-shadow 0.2s ease, color 0.2s ease;
    min-height: 44px;
  }

  .engine-action-button:hover:not(:disabled) {
    transform: translateY(-2px);
    background: rgba(122, 140, 255, 0.28);
    box-shadow: 0 10px 24px rgba(70, 90, 200, 0.35);
  }

  .engine-action-button:disabled {
    cursor: not-allowed;
    opacity: 0.35;
    transform: none;
  }

  .engine-action-button--primary {
    background: linear-gradient(135deg, rgba(102, 126, 255, 0.85), rgba(136, 98, 255, 0.85));
    box-shadow: 0 14px 28px rgba(88, 120, 255, 0.38);
  }

  .engine-action-button__label {
    pointer-events: none;
  }

  .engine-settings__error {
    font-size: 0.85rem;
    color: #ff9aad;
  }

  .engine-settings__help {
    margin: -6px 0 0;
    font-size: 0.78rem;
    color: #9ca6cf;
    line-height: 1.5;
  }

  #input-modal {
    position: fixed;
    inset: 0;
    display: grid;
    place-items: center;
    background: rgba(7, 9, 16, 0.72);
    backdrop-filter: blur(8px);
    z-index: 1000;
  }

  #input-modal[hidden] {
    display: none !important;
  }

  .input-modal__dialog {
    width: min(92vw, 420px);
    background: rgba(12, 16, 30, 0.96);
    border-radius: 20px;
    padding: 24px;
    display: flex;
    flex-direction: column;
    gap: 16px;
    box-shadow: 0 24px 64px rgba(0, 0, 0, 0.55);
  }

  .input-modal__title {
    margin: 0;
    font-size: 1.05rem;
    font-weight: 600;
    color: #eef1ff;
  }

  .input-modal__description {
    margin: 0;
    font-size: 0.85rem;
    color: #a9b3df;
    line-height: 1.5;
  }

  .input-modal__section {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }

  .input-modal__section + .input-modal__section {
    padding-top: 10px;
    border-top: 1px solid rgba(255, 255, 255, 0.08);
  }

  .input-modal__section--archive {
    gap: 14px;
  }

  .input-modal__subtitle {
    margin: 0;
    font-size: 0.94rem;
    font-weight: 600;
    color: #e5e9ff;
  }

  .input-modal__hint {
    margin: 0;
    font-size: 0.82rem;
    color: #9ca6cf;
    line-height: 1.4;
  }

  .input-modal__textarea {
    width: 100%;
    min-height: 140px;
    border-radius: 14px;
    border: 1px solid rgba(255, 255, 255, 0.12);
    background: rgba(17, 21, 32, 0.92);
    color: #eef1ff;
    padding: 12px 14px;
    font-size: 0.95rem;
    line-height: 1.5;
    resize: vertical;
  }

  .input-modal__actions {
    display: flex;
    justify-content: flex-end;
    gap: 12px;
  }

  .input-modal__button {
    border: none;
    border-radius: 12px;
    padding: 10px 18px;
    font-size: 0.92rem;
    font-weight: 600;
    cursor: pointer;
    transition: transform 0.2s ease, background 0.2s ease, box-shadow 0.2s ease;
  }

  .input-modal__button:focus-visible {
    outline: 2px solid rgba(122, 140, 255, 0.7);
    outline-offset: 2px;
  }

  .input-modal__button--cancel {
    background: rgba(255, 255, 255, 0.08);
    color: #d2d9ff;
  }

  .input-modal__button--submit {
    background: linear-gradient(135deg, rgba(102, 126, 255, 0.85), rgba(136, 98, 255, 0.85));
    color: #f6f8ff;
    box-shadow: 0 14px 28px rgba(88, 120, 255, 0.32);
  }

  .input-modal__button:hover {
    transform: translateY(-1px);
  }

  .input-modal__error {
    margin: -6px 0 0;
    font-size: 0.82rem;
    color: #ff9aad;
  }

  .archive-search__field {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  .archive-search__label {
    font-size: 0.8rem;
    color: #b1bcf3;
    text-transform: uppercase;
    letter-spacing: 0.08em;
  }

  .archive-search__input {
    border-radius: 12px;
    border: 1px solid rgba(255, 255, 255, 0.12);
    background: rgba(17, 21, 32, 0.92);
    color: #eef1ff;
    padding: 10px 12px;
    font-size: 0.95rem;
  }

  .archive-search__input::placeholder {
    color: rgba(226, 230, 255, 0.45);
  }

  .archive-search__input:focus-visible {
    outline: 2px solid rgba(122, 140, 255, 0.7);
    outline-offset: 2px;
  }

  .archive-search__buttons {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
  }

  .archive-search__button {
    border: none;
    border-radius: 999px;
    padding: 8px 16px;
    background: rgba(255, 255, 255, 0.08);
    color: #e6eaff;
    font-size: 0.84rem;
    font-weight: 600;
    cursor: pointer;
    transition: background 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease;
  }

  .archive-search__button:hover {
    background: rgba(255, 255, 255, 0.14);
    transform: translateY(-1px);
    box-shadow: 0 8px 18px rgba(60, 86, 210, 0.25);
  }

  .archive-search__button:focus-visible {
    outline: 2px solid rgba(122, 140, 255, 0.7);
    outline-offset: 2px;
  }

  .archive-search__button:disabled {
    opacity: 0.45;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
  }

  .archive-search__button:disabled:hover {
    background: rgba(255, 255, 255, 0.08);
  }

  .archive-search__status {
    margin: 0;
    min-height: 1.2em;
    font-size: 0.8rem;
    color: #b8c2ff;
  }

  .archive-search__status[data-state="loading"] {
    color: #d8ddff;
  }

  .archive-search__status[data-state="error"] {
    color: #ff9aad;
  }

  .archive-search__status[data-state="success"] {
    color: #8fe1ff;
  }

  .archive-search__results {
    margin: 0;
    padding: 0;
    list-style: none;
    border-radius: 16px;
    border: 1px solid rgba(255, 255, 255, 0.06);
    background: rgba(17, 21, 32, 0.75);
    overflow: hidden;
    max-height: 240px;
    overflow-y: auto;
  }

  .archive-search__results[hidden] {
    display: none !important;
  }

  .archive-search__result-item + .archive-search__result-item {
    border-top: 1px solid rgba(255, 255, 255, 0.05);
  }

  .archive-search__result-button {
    width: 100%;
    border: none;
    background: transparent;
    text-align: left;
    padding: 12px 16px;
    color: inherit;
    display: flex;
    flex-direction: column;
    gap: 4px;
    cursor: pointer;
    transition: background 0.2s ease;
  }

  .archive-search__result-button:hover,
  .archive-search__result-button:focus-visible {
    background: rgba(255, 255, 255, 0.08);
    outline: none;
  }

  .archive-search__result-primary {
    font-size: 0.88rem;
    font-weight: 600;
    color: #eef1ff;
  }

  .archive-search__result-meta {
    font-size: 0.75rem;
    color: #9ca6cf;
  }

  @media (prefers-reduced-motion: reduce) {
    *, *::before, *::after {
      animation-duration: 0.01ms !important;
      animation-iteration-count: 1 !important;
      transition-duration: 0.01ms !important;
      scroll-behavior: auto !important;
    }

    .indicator-slide {
      animation: none !important;
    }

    .control-button,
    .engine-action-button,
    .input-modal__button {
      transition: none !important;
    }

    .control-button:hover:not(:disabled),
    .engine-action-button:hover:not(:disabled),
    .input-modal__button:hover {
      transform: none !important;
      box-shadow: none !important;
    }
  }

  .evaluation-nav__graph {
    width: 100%;
    height: 100%;
  }

  .evaluation-nav__area {
    fill: rgba(130, 148, 255, 0.2);
  }

  .evaluation-nav__line {
    stroke: rgba(214, 222, 255, 0.85);
    stroke-width: 2;
  }

  .evaluation-nav__baseline {
    stroke: rgba(255, 255, 255, 0.14);
    stroke-width: 1;
    stroke-dasharray: 6 6;
  }

  .evaluation-nav__overlay {
    position: absolute;
    inset: 0;
    display: grid;
  }

  .evaluation-nav__segment {
    border: none;
    background: transparent;
    padding: 0;
    margin: 0;
    cursor: pointer;
  }

  .evaluation-nav__segment:hover,
  .evaluation-nav__segment.is-current {
    background: rgba(122, 140, 255, 0.18);
  }

  .evaluation-nav__marker {
    fill: #f5f7ff;
    stroke: rgba(122, 140, 255, 0.9);
    stroke-width: 2;
  }

  .highlight-selection {
    box-shadow: inset 0 0 0 3px #f2ff5f !important;
  }

  .highlight-move-from,
  .highlight-move-to {
    background: rgba(255, 255, 0, 0.38) !important;
  }

  .highlight-piece-move-target {
    background: rgba(118, 142, 255, 0.32) !important;
    box-shadow: inset 0 0 0 2px rgba(255, 255, 255, 0.22);
  }

  .selected-spare-piece {
    box-shadow: 0 0 0 3px #f2ff5f inset;
    border-radius: 8px;
  }

  .move-rating {
    position: absolute;
    bottom: 6px;
    right: 6px;
    background: rgba(9, 12, 24, 0.82);
    color: #f6f9ff;
    font-size: 12px;
    padding: 3px 5px;
    border-radius: 6px;
    pointer-events: none;
    z-index: 5;
  }

  .board-container .chessboard-7492f {
    display: flex;
    flex-direction: column;
    gap: 10px;
    align-items: center;
  }

  .board-container .board-b72b1 {
    order: 1;
  }

  .board-container .spare-pieces-top,
  .board-container .spare-pieces-bottom {
    order: 2;
    margin-top: 6px;
    display: none;
  }

  .board-container.editing .spare-pieces-top,
  .board-container.editing .spare-pieces-bottom {
    display: flex;
  }

  .board-container .spare-pieces-7492f {
    justify-content: center;
    gap: 6px;
  }

  .board-container.editing .spare-pieces-7492f {
    display: flex;
  }

  .board-container.editing .spare-pieces-7492f .piece-417db[data-piece^='b'] {
    background: rgba(255, 255, 255, 0.18);
    border-radius: 10px;
    padding: 4px;
  }

  @media (max-width: 640px) {
    .board-shell {
      padding: 18px 22px;
      border-radius: 24px;
    }

    .container {
      gap: 22px;
    }

    #board {
      max-width: 100%;
    }

  }

  @media (max-width: 480px) {
    .container {
      width: min(98vw, 460px);
      gap: 18px;
    }

    .board-shell {
      padding: 14px 16px;
      border-radius: 22px;
    }

    #controls {
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
    }

    .control-button {
      border-radius: 14px;
      padding: 10px 12px;
      font-size: 0.88rem;
    }

    .engine-settings {
      padding: 16px 18px;
      border-radius: 18px;
    }

    .engine-settings__form {
      grid-template-columns: 1fr;
      gap: 12px;
    }
  }
</style>

  <script src="libs/jquery.min.js" defer></script>
  <link href="libs/chessboard-1.0.0.min.css" rel="stylesheet">
  <script src="libs/chessboard-1.0.0.min.js" defer></script>
  <script src="libs/chess.min.js" defer></script>
</head>
<body>
  <div class="container">
    <div class="responsive-layout">
      <div class="board-shell">
        <div class="board-area">
          <div class="board-container">
            <div id="board"></div>
          </div>
        </div>
      </div>
      <aside class="side-panel">
        <div class="player-summary" id="player-summary" role="status" aria-live="polite" aria-atomic="true">
          <span class="player-summary__names" id="player-summary-names">White vs Black</span>
          <span class="player-summary__divider" aria-hidden="true">—</span>
          <span class="player-summary__outcome" id="player-summary-outcome">In progress</span>
        </div>
        <div class="side-panel__section">
          <div id="info-line">
            <span id="status" class="status-text" role="status" aria-live="polite" aria-atomic="true" data-turn="white" data-state="normal" aria-label="White to move">
              <span class="status-text__label">White to move</span>
            </span>
            <span class="info-line-item info-line-item--gauge" id="evaluation-container" aria-hidden="true" hidden>
              <span class="advantage-bar is-balanced advantage-bar--inline" id="advantage-bar" aria-live="polite" aria-busy="false" aria-atomic="true" aria-hidden="true" hidden>
                <span class="advantage-bar__track" id="advantage-track"></span>
              </span>
              <span id="evaluation" class="evaluation-indicator is-balanced" role="img" aria-label="Win chance --" data-probability="0.5" aria-live="off" aria-atomic="true">
                <span class="visually-hidden">Win chance --</span>
                <span class="evaluation-indicator__value" aria-hidden="true" data-visible-value>--</span>
              </span>
            </span>
          </div>
        </div>
        <span class="visually-hidden" id="advantage-status">Awaiting evaluation</span>
        <span class="visually-hidden" id="advantage-white-percent">50%</span>
        <span class="visually-hidden" id="advantage-black-percent">50%</span>
        <div class="probability-panel" id="probability-panel" hidden>
          <div class="probability-panel__graph" id="evaluation-nav" role="group" aria-label="Evaluation timeline"></div>
        </div>
        <div id="controls">
          <button id="prev-button" class="control-button" type="button" disabled aria-label="Previous move">
            <span class="control-button__label" aria-hidden="true">Prev</span>
            <span class="visually-hidden">Previous move</span>
          </button>
      <button id="next-button" class="control-button" type="button" disabled aria-label="Next move">
        <span class="control-button__label" aria-hidden="true">Next</span>
        <span class="visually-hidden">Next move</span>
      </button>
      <button id="best-move-button" class="control-button" type="button" disabled aria-pressed="false" aria-label="Show best move">
        <span class="control-button__label" aria-hidden="true">Best</span>
        <span class="visually-hidden">Show best move</span>
      </button>
      <button id="advantage-toggle-button" class="control-button" type="button" aria-pressed="false" aria-label="Show advantage bar">
        <span class="control-button__label" aria-hidden="true">Gauge</span>
        <span class="visually-hidden">Show advantage bar</span>
      </button>
      <button id="probability-button" class="control-button" type="button" aria-pressed="false" aria-label="Show evaluation graph">
        <span class="control-button__label" aria-hidden="true">Line</span>
        <span class="visually-hidden">Show evaluation graph</span>
      </button>
      <button id="piece-moves-button" class="control-button" type="button" aria-pressed="false" aria-label="Show piece moves">
        <span class="control-button__label" aria-hidden="true">Piece</span>
        <span class="visually-hidden">Show piece moves</span>
      </button>
      <button id="flip-button" class="control-button" type="button" aria-label="Flip board">
        <span class="control-button__label" aria-hidden="true">Flip</span>
        <span class="visually-hidden">Flip board</span>
      </button>
      <button id="edit-button" class="control-button" type="button" aria-pressed="false" aria-label="Enter edit mode">
        <span class="control-button__label" aria-hidden="true">Edit</span>
        <span class="visually-hidden">Enter edit mode</span>
      </button>
      <button id="fen-button" class="control-button" type="button" aria-label="Load FEN or PGN">
        <span class="control-button__label" aria-hidden="true">Input</span>
        <span class="visually-hidden">Load FEN or PGN</span>
      </button>
          <button id="engine-button" class="control-button" type="button" aria-pressed="false" aria-label="Show engine settings">
            <span class="control-button__label" aria-hidden="true">Engine</span>
            <span class="visually-hidden">Show engine settings</span>
          </button>
        </div>
        <section id="engine-settings" class="engine-settings" hidden aria-hidden="true">
      <div class="engine-settings__header">
        <h2 class="engine-settings__title">Engine</h2>
        <span id="engine-status" class="engine-settings__status" data-state="idle" aria-live="polite">Not started</span>
      </div>
      <form class="engine-settings__form" aria-label="Engine configuration">
        <label class="engine-field" for="engine-threads">
          <span class="engine-field__label">Threads</span>
          <input id="engine-threads" class="engine-field__input" name="threads" type="number" min="1" step="1" inputmode="numeric" value="1">
        </label>
        <label class="engine-field" for="engine-hash">
          <span class="engine-field__label">Hash (MB)</span>
          <input id="engine-hash" class="engine-field__input" name="hash" type="number" min="1" step="1" inputmode="numeric" value="469">
        </label>
        <label class="engine-field" for="engine-depth">
          <span class="engine-field__label">Depth</span>
          <input id="engine-depth" class="engine-field__input" name="depth" type="number" min="1" step="1" inputmode="numeric" value="20">
        </label>
      </form>
      <label class="engine-autostart-toggle" for="engine-autostart-toggle">
        <input id="engine-autostart-toggle" class="engine-autostart-toggle__input" type="checkbox" checked>
        <span class="engine-autostart-toggle__label">Start Stockfish automatically</span>
      </label>
      <p class="engine-settings__help" id="engine-settings-help"></p>
      <div id="engine-error" class="engine-settings__error" role="alert" hidden></div>
      <div class="engine-settings__actions">
        <button type="button" id="engine-start-button" class="engine-action-button engine-action-button--primary">
          <span class="engine-action-button__label">Start</span>
        </button>
          <button type="button" id="engine-stop-button" class="engine-action-button" disabled>
          <span class="engine-action-button__label">Cease</span>
        </button>
      </div>
        </section>
      </aside>
    </div>
    <div id="input-modal" role="dialog" aria-modal="true" aria-labelledby="input-modal-title" aria-describedby="input-modal-description" aria-hidden="true" hidden>
      <div class="input-modal__dialog">
        <h2 id="input-modal-title" class="input-modal__title">Load FEN or PGN</h2>
        <div class="input-modal__section input-modal__section--manual">
          <p id="input-modal-description" class="input-modal__description input-modal__hint">Paste a FEN position or PGN moves. Press Ctrl+Enter (or Cmd+Enter) to apply.</p>
          <textarea id="input-modal-text" class="input-modal__textarea" aria-describedby="input-modal-description input-modal-error"></textarea>
          <p id="input-modal-error" class="input-modal__error" role="alert" hidden></p>
        </div>
        <div class="input-modal__section input-modal__section--archive" id="archive-search-section">
          <h3 id="archive-search-title" class="input-modal__subtitle">Find a game by username</h3>
          <p class="input-modal__hint">Search recent games on Chess.com or Lichess, then choose a game to load its PGN.</p>
          <label class="archive-search__field" for="archive-username">
            <span class="archive-search__label">Username</span>
            <input id="archive-username" class="archive-search__input" type="text" inputmode="text" autocomplete="username" placeholder="e.g. MagnusCarlsen">
          </label>
          <div class="archive-search__buttons">
            <button type="button" id="archive-search-chesscom" class="archive-search__button">Chess.com</button>
            <button type="button" id="archive-search-lichess" class="archive-search__button">Lichess</button>
          </div>
          <p id="archive-status" class="archive-search__status" role="status" aria-live="polite"></p>
          <ul id="archive-results" class="archive-search__results" hidden aria-labelledby="archive-search-title"></ul>
        </div>
        <div class="input-modal__actions">
          <button type="button" id="input-modal-cancel" class="input-modal__button input-modal__button--cancel">Cancel</button>
          <button type="button" id="input-modal-apply" class="input-modal__button input-modal__button--submit">Apply</button>
        </div>
      </div>
    </div>
  </div>
  <script>
    (function setup() {
      function initialize() {
        const $ = window.jQuery;
        if (typeof $ !== 'function') {
          console.error('jQuery failed to load; the chess interface cannot initialize.');
          return;
        }
        const Chessboard = window.Chessboard;
        if (typeof Chessboard !== 'function') {
          console.error('Chessboard.js failed to load; the chess interface cannot initialize.');
          return;
        }
        const Chess = window.Chess;
        if (typeof Chess !== 'function') {
          console.error('Chess.js failed to load; the chess interface cannot initialize.');
          return;
        }
        let board, engine;
      let lastBoardConfig = { editMode: null, orientation: null };
      const game = new Chess();
      const boardEl = $('#board');
      const advantageBarElement = document.getElementById('advantage-bar');
      const advantageTrackElement = document.getElementById('advantage-track');
      const advantageStatusElement = document.getElementById('advantage-status');
      const advantageWhiteElement = document.getElementById('advantage-white-percent');
      const advantageBlackElement = document.getElementById('advantage-black-percent');
      const advantageToggleButton = document.getElementById('advantage-toggle-button');
      const playerSummaryElement = document.getElementById('player-summary');
      const playerSummaryNamesElement = document.getElementById('player-summary-names');
      const playerSummaryOutcomeElement = document.getElementById('player-summary-outcome');
      const prevButtonElement = document.getElementById('prev-button');
      const nextButtonElement = document.getElementById('next-button');
      const flipButtonElement = document.getElementById('flip-button');
      const probabilityPanel = document.getElementById('probability-panel');
      const evaluationContainer = document.getElementById('evaluation-container');
      const evaluationElement = document.getElementById('evaluation');
      const evaluationValueElement = evaluationElement ? evaluationElement.querySelector('[data-visible-value]') : null;
      const bestMoveButtonElement = document.getElementById('best-move-button');
      const probabilityButtonElement = document.getElementById('probability-button');
      const pieceMovesButtonElement = document.getElementById('piece-moves-button');
      const fenButtonElement = document.getElementById('fen-button');
      const editButtonElement = document.getElementById('edit-button');
      const engineButtonElement = document.getElementById('engine-button');
      const engineSettingsElement = document.getElementById('engine-settings');
      const engineStatusElement = document.getElementById('engine-status');
      const engineErrorElement = document.getElementById('engine-error');
      const engineHelpElement = document.getElementById('engine-settings-help');
      const engineStartButtonElement = document.getElementById('engine-start-button');
      const engineStopButtonElement = document.getElementById('engine-stop-button');
      const engineThreadsInput = document.getElementById('engine-threads');
      const engineHashInput = document.getElementById('engine-hash');
      const engineDepthInput = document.getElementById('engine-depth');
      const engineAutostartToggle = document.getElementById('engine-autostart-toggle');
      const inputModalElement = document.getElementById('input-modal');
      const inputModalTextarea = document.getElementById('input-modal-text');
      const inputModalApplyButton = document.getElementById('input-modal-apply');
      const inputModalCancelButton = document.getElementById('input-modal-cancel');
      const inputModalErrorElement = document.getElementById('input-modal-error');
      const archiveSearchSection = document.getElementById('archive-search-section');
      const archiveSearchInput = document.getElementById('archive-username');
      const archiveChesscomButton = document.getElementById('archive-search-chesscom');
      const archiveLichessButton = document.getElementById('archive-search-lichess');
      const archiveStatusElement = document.getElementById('archive-status');
      const archiveResultsElement = document.getElementById('archive-results');
      const statusElement = document.getElementById('status');
      const moveSoundElement = createAudioElement('sounds/move.mp3');
      const captureSoundElement = createAudioElement('sounds/capture.mp3');
      const CHESSBOARD_SELECTORS = Object.freeze({
        square: 'div.square-55d63',
        spareWrapper: '.spare-pieces-7492f',
        piece: '.piece-417db'
      });
      const sparePiecesContainerSelector = `.board-container ${CHESSBOARD_SELECTORS.spareWrapper}`;
      const sparePieceSelector = CHESSBOARD_SELECTORS.piece;
      const ARCHIVE_SEARCH_SOURCES = Object.freeze({ CHESSCOM: 'chesscom', LICHESS: 'lichess' });
      const DEFAULT_ARCHIVE_STATUS_MESSAGE = 'Enter a username, then choose Chess.com or Lichess to load recent games.';
      const ARCHIVE_SEARCH_LIMIT = 30;
      const CHESS_COM_MAX_ARCHIVES = 6;
      const DEFAULT_PLAYER_WHITE_NAME = 'White';
      const DEFAULT_PLAYER_BLACK_NAME = 'Black';
      const DEFAULT_PLAYER_OUTCOME_LABEL = 'In progress';
      const playerSummaryState = {
        white: DEFAULT_PLAYER_WHITE_NAME,
        black: DEFAULT_PLAYER_BLACK_NAME,
        outcomeLabel: DEFAULT_PLAYER_OUTCOME_LABEL,
        resultCode: '',
        locked: false
      };
      let archiveSearchEntries = [];
      let archiveSearchToken = 0;
      let archiveSearchAbortController = null;
      let archiveSearchLastSource = ARCHIVE_SEARCH_SOURCES.CHESSCOM;
      const ENGINE_AUTOSTART_STORAGE_KEY = 'stockfish-ui:engine-autostart-disabled';
      let baseFen = game.fen();
      let selectedSquare = null;
      let moveSourceSquare = null;
      let isPieceAnalysis = false;
      let freezeMode = false;
      let editMode = false;
      let pieceMovesMode = false;
      let orientation = 'white';
      let latestAnalysisFen = null;
      let lastAnalysisRequest = null;
      let lastObservedPositionFen = game.fen();
      let shouldHighlightBest = false;
      let engineReady = false;
      let engineCommandQueue = [];
      let engineAwaitingReadyAfterStop = false;
      let engineStopPending = false;
      let editSelectedPiece = null;
      let editSelectedSquare = null;
      let editSelectionSource = null;
      let bestMoveVisible = false;
      let moveHistory = [];
      let navigationIndex = 0;
      let enginePanelVisible = false;
      function createAudioElement(src) {
        if (typeof Audio !== 'function') {
          return null;
        }
        try {
          const audio = new Audio(src);
          audio.preload = 'auto';
          return audio;
        } catch (error) {
          console.warn('Failed to initialize audio element', error);
          return null;
        }
      }

      function playAudioClip(audio) {
        if (!audio) return;
        try {
          const clip = audio.cloneNode();
          const playPromise = clip.play();
          if (playPromise && typeof playPromise.catch === 'function') {
            playPromise.catch(() => {});
          }
        } catch (error) {
          console.warn('Failed to play audio clip', error);
        }
      }

      function playMoveSound(move) {
        if (!move) return;
        const flags = typeof move.flags === 'string' ? move.flags : '';
        const isCapture = flags.includes('c') || flags.includes('e');
        playAudioClip(isCapture ? captureSoundElement : moveSoundElement);
      }
      function sanitizePlayerName(name, fallback) {
        if (typeof name !== 'string') {
          return fallback;
        }
        const trimmed = name.trim();
        return trimmed.length ? trimmed : fallback;
      }

      function resolvePlayerOutcomeLabel(label) {
        if (typeof label !== 'string') {
          return DEFAULT_PLAYER_OUTCOME_LABEL;
        }
        const trimmed = label.trim();
        return trimmed.length ? trimmed : DEFAULT_PLAYER_OUTCOME_LABEL;
      }

      function buildPlayerSummaryOutcomeText() {
        const label = resolvePlayerOutcomeLabel(playerSummaryState.outcomeLabel);
        const code = typeof playerSummaryState.resultCode === 'string'
          ? playerSummaryState.resultCode.trim()
          : '';
        if (code && code !== '*') {
          return `${label} (${code})`;
        }
        return label;
      }

      function updatePlayerSummaryDisplay() {
        if (!playerSummaryElement) {
          return;
        }
        const namesText = `${playerSummaryState.white} vs ${playerSummaryState.black}`;
        const outcomeText = buildPlayerSummaryOutcomeText();
        if (playerSummaryNamesElement) {
          playerSummaryNamesElement.textContent = namesText;
        }
        if (playerSummaryOutcomeElement) {
          playerSummaryOutcomeElement.textContent = outcomeText;
        }
        if (!playerSummaryNamesElement || !playerSummaryOutcomeElement) {
          playerSummaryElement.textContent = `${namesText} — ${outcomeText}`;
        }
      }

      function resetPlayerSummaryState({
        white = DEFAULT_PLAYER_WHITE_NAME,
        black = DEFAULT_PLAYER_BLACK_NAME,
        label = DEFAULT_PLAYER_OUTCOME_LABEL,
        resultCode = '',
        locked = false
      } = {}) {
        playerSummaryState.white = sanitizePlayerName(white, DEFAULT_PLAYER_WHITE_NAME);
        playerSummaryState.black = sanitizePlayerName(black, DEFAULT_PLAYER_BLACK_NAME);
        playerSummaryState.outcomeLabel = resolvePlayerOutcomeLabel(label);
        const code = typeof resultCode === 'string' ? resultCode.trim() : '';
        playerSummaryState.resultCode = code && code !== '*' ? code : '';
        playerSummaryState.locked = Boolean(locked);
        updatePlayerSummaryDisplay();
      }

      function releasePlayerSummaryLock() {
        if (!playerSummaryState.locked) {
          return;
        }
        playerSummaryState.locked = false;
        playerSummaryState.outcomeLabel = DEFAULT_PLAYER_OUTCOME_LABEL;
        playerSummaryState.resultCode = '';
        updatePlayerSummaryDisplay();
      }

      function deriveOutcomeLabelFromTags(resultTag, terminationTag, finalSan) {
        const normalizedTermination = typeof terminationTag === 'string'
          ? terminationTag.trim().toLowerCase()
          : '';
        const normalizedResult = typeof resultTag === 'string'
          ? resultTag.trim()
          : '';
        const finalMoveSan = typeof finalSan === 'string' ? finalSan.trim() : '';
        const terminationIncludes = token => normalizedTermination.includes(token);
        if (terminationIncludes('resign')) {
          return 'Resignation';
        }
        if (terminationIncludes('time') || terminationIncludes('flag') || terminationIncludes('timeout') || terminationIncludes('forfeit')) {
          return 'Time';
        }
        if (terminationIncludes('mate')) {
          return 'Checkmate';
        }
        if (terminationIncludes('stalemate')) {
          return 'Stalemate';
        }
        if (terminationIncludes('agreed') || terminationIncludes('agreement')) {
          return 'Draw';
        }
        if (terminationIncludes('draw') || terminationIncludes('repetition') || terminationIncludes('50') || terminationIncludes('fifty') || terminationIncludes('insufficient') || terminationIncludes('material')) {
          return 'Draw';
        }
        if (terminationIncludes('abandon') || terminationIncludes('disconnect')) {
          return 'Abandoned';
        }
        if (normalizedTermination === 'normal' && finalMoveSan.includes('#')) {
          return 'Checkmate';
        }
        if (finalMoveSan.includes('#')) {
          return 'Checkmate';
        }
        if (normalizedResult === '1/2-1/2') {
          return 'Draw';
        }
        if (normalizedResult === '1-0' || normalizedResult === '0-1') {
          return 'Completed';
        }
        return DEFAULT_PLAYER_OUTCOME_LABEL;
      }

      function applyPlayerSummaryFromPgn(header, history) {
        const safeHeader = header && typeof header === 'object' ? header : {};
        const white = safeHeader.White || safeHeader.white || DEFAULT_PLAYER_WHITE_NAME;
        const black = safeHeader.Black || safeHeader.black || DEFAULT_PLAYER_BLACK_NAME;
        const resultTag = typeof safeHeader.Result === 'string' ? safeHeader.Result : '';
        const terminationTag = typeof safeHeader.Termination === 'string' ? safeHeader.Termination : '';
        const finalMove = Array.isArray(history) && history.length ? history[history.length - 1] : null;
        const finalSan = finalMove && typeof finalMove.san === 'string' ? finalMove.san : '';
        const outcomeLabel = deriveOutcomeLabelFromTags(resultTag, terminationTag, finalSan);
        const resultCode = resultTag && resultTag !== '*' ? resultTag : '';
        const shouldLock = Boolean(resultCode || outcomeLabel !== DEFAULT_PLAYER_OUTCOME_LABEL);
        resetPlayerSummaryState({ white, black, label: outcomeLabel, resultCode, locked: shouldLock });
      }

      function updatePlayerSummaryFromGame() {
        if (!playerSummaryElement) {
          return;
        }
        if (playerSummaryState.locked) {
          updatePlayerSummaryDisplay();
          return;
        }
        let outcomeLabel = DEFAULT_PLAYER_OUTCOME_LABEL;
        let resultCode = '';
        if (game.in_checkmate()) {
          outcomeLabel = 'Checkmate';
          resultCode = game.turn() === 'w' ? '0-1' : '1-0';
        } else if (game.in_draw() || game.in_stalemate()) {
          outcomeLabel = 'Draw';
          resultCode = '1/2-1/2';
        }
        playerSummaryState.outcomeLabel = outcomeLabel;
        playerSummaryState.resultCode = resultCode;
        updatePlayerSummaryDisplay();
      }

      updatePlayerSummaryDisplay();
        const STOCKFISH_WORKER_VARIANTS = [
   
          { filename: 'stockfish-nnue-16-single.js', requiresThreadSupport: false },
        
        ];
        const STOCKFISH_ENGINE_DIRECTORY = '.';
        const STOCKFISH_WORKER_DIRECTORIES = Object.freeze([
          STOCKFISH_ENGINE_DIRECTORY,
          'engines',
          'engine'
        ]);
        const threadSupportAvailable = supportsThreadedWorkers();
        const selectedStockfishVariant = (() => {
          for (const variant of STOCKFISH_WORKER_VARIANTS) {
            if (!variant) continue;
            if (variant.requiresThreadSupport && !threadSupportAvailable) {
              continue;
            }
            return variant;
          }
          return null;
        })();
        const primaryWorkerDirectory = (() => {
          const directories = Array.isArray(STOCKFISH_WORKER_DIRECTORIES)
            ? STOCKFISH_WORKER_DIRECTORIES
            : [STOCKFISH_WORKER_DIRECTORIES];
          for (const entry of directories) {
          if (typeof entry === 'string' && entry.trim().length) {
            return entry.trim();
          }
        }
        if (typeof STOCKFISH_ENGINE_DIRECTORY === 'string' && STOCKFISH_ENGINE_DIRECTORY.length) {
          return STOCKFISH_ENGINE_DIRECTORY;
        }
        return 'engine';
      })();
        const engineAssetsBaseDirectory = (() => {
          if (typeof primaryWorkerDirectory === 'string' && primaryWorkerDirectory.trim().length) {
            return primaryWorkerDirectory.trim();
          }
          if (typeof STOCKFISH_ENGINE_DIRECTORY === 'string' && STOCKFISH_ENGINE_DIRECTORY.trim().length) {
            return STOCKFISH_ENGINE_DIRECTORY.trim();
          }
          return '.';
        })();
        const normalizeEngineAssetPath = filename => {
          if (typeof filename !== 'string') {
            return null;
          }
          const trimmedFilename = filename.trim();
          if (!trimmedFilename.length) {
            return null;
          }
          const base = engineAssetsBaseDirectory;
          if (!base || base === '.' || base === './') {
            return trimmedFilename;
          }
          if (base.endsWith('/')) {
            return `${base}${trimmedFilename}`;
          }
          return `${base}/${trimmedFilename}`;
        };
        const variantForDefaultLocation = selectedStockfishVariant || (() => {
          for (const variant of STOCKFISH_WORKER_VARIANTS) {
            if (variant && typeof variant.filename === 'string' && variant.filename.trim().length) {
              return variant;
            }
          }
          return null;
        })();
        const workerFilenameForDefault = variantForDefaultLocation && typeof variantForDefaultLocation.filename === 'string'
          ? variantForDefaultLocation.filename
          : null;
        const defaultWorkerLocation = workerFilenameForDefault
          ? normalizeEngineAssetPath(workerFilenameForDefault)
          : null;
        const requiresThreadedVariant = !!(variantForDefaultLocation && variantForDefaultLocation.requiresThreadSupport);
        const defaultEngineAssetMap = (() => {
          if (!workerFilenameForDefault) {
            return new Map();
          }
          const assets = new Map();
          const wasmFilename = (() => {
            const wasmMatch = workerFilenameForDefault.match(/^(.*?)(?:\.worker)?\.js(\?.*)?$/i);
            if (!wasmMatch) {
              return null;
            }
            const [, baseName, query = ''] = wasmMatch;
            return `${baseName}.wasm${query}`;
          })();
          assets.set(workerFilenameForDefault, normalizeEngineAssetPath(workerFilenameForDefault));
          if (requiresThreadedVariant) {
            assets.set('stockfish.worker.js', normalizeEngineAssetPath('stockfish.worker.js'));
          }
          if (wasmFilename) {
            assets.set(wasmFilename, normalizeEngineAssetPath(wasmFilename));
          }
          return assets;
        })();
        const ENGINE_THREADS_MIN = 1;
        const DEFAULT_ANALYSIS_DEPTH = 20;
        const PGN_REPLAY_DEPTH = 20;
        const PGN_IMPORT_ANALYSIS_DEPTH = 20;
        const DEFAULT_THREADS = 3;
        const DEFAULT_HASH_MB = 469;
        const ENGINE_MEMORY_ERROR_FALLBACK_HASH_MB = DEFAULT_HASH_MB;
        if (typeof window !== 'undefined') {
          const stockfishWorkerPath = workerFilenameForDefault
            ? defaultEngineAssetMap.get(workerFilenameForDefault)
            : null;
          if (stockfishWorkerPath && (!window.STOCKFISH_WORKER_PATH || !String(window.STOCKFISH_WORKER_PATH).trim().length)) {
            window.STOCKFISH_WORKER_PATH = stockfishWorkerPath;
          }
          const existingWorkerPaths = (window.STOCKFISH_WORKER_PATHS && typeof window.STOCKFISH_WORKER_PATHS === 'object')
            ? window.STOCKFISH_WORKER_PATHS
            : {};
          for (const [assetName, assetPath] of defaultEngineAssetMap.entries()) {
            if (!assetName || !assetPath) continue;
            if (typeof existingWorkerPaths[assetName] !== 'string' || !existingWorkerPaths[assetName].trim().length) {
              existingWorkerPaths[assetName] = assetPath;
            }
          }
          window.STOCKFISH_WORKER_PATHS = existingWorkerPaths;
          const moduleConfig = (window.STOCKFISH && typeof window.STOCKFISH === 'object') ? window.STOCKFISH : {};
          if (!moduleConfig.locateFile) {
            moduleConfig.locateFile = (path, prefix) => {
              if (path && defaultEngineAssetMap.has(path)) {
                return defaultEngineAssetMap.get(path);
              }
              const normalizedPath = typeof path === 'string' ? path.trim() : '';
              if (!normalizedPath.length) {
                return path;
              }
              const resolved = normalizeEngineAssetPath(normalizedPath);
              return resolved || normalizedPath;
            };
          }
          if (stockfishWorkerPath && (!moduleConfig.mainScriptUrlOrBlob || !String(moduleConfig.mainScriptUrlOrBlob).trim().length)) {
            moduleConfig.mainScriptUrlOrBlob = stockfishWorkerPath;
          }
          if (stockfishWorkerPath && (!moduleConfig.workerPath || !String(moduleConfig.workerPath).trim().length)) {
            moduleConfig.workerPath = stockfishWorkerPath;
          }
          window.STOCKFISH = moduleConfig;
        }
        const engineConfig = {
          threads: DEFAULT_THREADS,
          hash: DEFAULT_HASH_MB,
          depth: DEFAULT_ANALYSIS_DEPTH
        };
      const ENGINE_AUTOSTART_DELAY_MS = 400;
      const ENGINE_AUTOSTART_MAX_ATTEMPTS = 3;
      const AUTO_PLAY_MIN_WAIT_MS = 4000;
      const MIN_THINK_TIME_MS = 3000;
      const REPLAY_STEP_DELAY_MS = 900;
      const PIECE_ANALYSIS_MODE_MULTIPV = 'multipv';
      let autoPlayPending = false;
      let autoPlayTargetDepth = engineConfig.depth;
      let autoPlayFen = null;
      let currentBestMove = null;
      let currentDepth = 0;
      let pieceMoveRatings = new Map();
      let pieceAnalysisMode = null;
      let pieceAnalysisTurn = null;
      let pieceAnalysisActiveRequestId = 0;
      let pieceAnalysisCurrentRequestId = 0;
      let pieceAnalysisPendingRequestId = 0;
      let pieceAnalysisFen = null;
      let pieceAnalysisTargetDepth = 0;
      let pieceAnalysisMoveSet = new Set();
      let pieceAnalysisResults = new Map();
      let pieceAnalysisSearchInFlight = false;
      let waitingForAutoBestMove = false;
      let autoMoveCandidate = null;
      let autoPlayRequestedAt = 0;
      let autoPlayDelayTimer = null;
      let autoPlayDepthSatisfied = false;
      let autoPlayMinThinkTimer = null;
      let pendingSearchContext = null;
      let currentSearchContext = null;
      function resetAutoPlayState() {
        if (autoPlayDelayTimer) {
          clearTimeout(autoPlayDelayTimer);
          autoPlayDelayTimer = null;
        }
        if (autoPlayMinThinkTimer) {
          clearTimeout(autoPlayMinThinkTimer);
          autoPlayMinThinkTimer = null;
        }
        waitingForAutoBestMove = false;
        autoMoveCandidate = null;
        autoPlayDepthSatisfied = false;
      }
      const evaluationNavElement = document.getElementById('evaluation-nav');
      let evaluationNavNeedsVisibleRender = false;
      let advantageBarVisible = false;
      let probabilityPanelVisible = false;
      let evaluationTimeline = [];
      let engineStarting = false;
      let engineAutostartTimer = null;
      let engineAutostartScheduled = false;
      let engineAutostartAttempts = 0;
      let engineLastStartWasAutostart = false;
      let engineAutostartDisabled = false;
      let lastFocusedElementBeforeModal = null;
      const storedAutostartPreference = readStoredAutostartPreference();
      if (storedAutostartPreference !== null) {
        engineAutostartDisabled = storedAutostartPreference;
      }
      if (engineAutostartToggle) {
        engineAutostartToggle.checked = !engineAutostartDisabled;
      }
      preloadPieceSprites();
      function preloadPieceSprites() {
        if (typeof Image !== 'function') {
          return;
        }
        const pieces = ['king', 'queen', 'rook', 'bishop', 'knight', 'pawn'];
        const colors = ['white', 'black'];
        colors.forEach(color => {
          pieces.forEach(piece => {
            const img = new Image();
            img.src = `pieces/${color}-${piece}.png`;
          });
        });
      }

      function readStoredAutostartPreference() {
        if (typeof window === 'undefined') {
          return null;
        }
        try {
          const storage = window.localStorage;
          if (!storage) return null;
          const value = storage.getItem(ENGINE_AUTOSTART_STORAGE_KEY);
          if (value === 'true') return true;
          if (value === 'false') return false;
        } catch (error) {
          return null;
        }
        return null;
      }

      function persistAutostartPreference() {
        if (typeof window === 'undefined') {
          return;
        }
        try {
          const storage = window.localStorage;
          if (!storage) return;
          storage.setItem(ENGINE_AUTOSTART_STORAGE_KEY, engineAutostartDisabled ? 'true' : 'false');
        } catch (error) {
          // Ignore storage errors (e.g., blocked cookies).
        }
      }

      function extractErrorMessage(error) {
        if (!error) return '';
        if (typeof error === 'string') {
          return error;
        }
        if (typeof error.message === 'string') {
          return error.message;
        }
        try {
          return String(error);
        } catch (stringifyError) {
          return '';
        }
      }

      function isMemoryAccessOutOfBoundsError(error) {
        const message = extractErrorMessage(error);
        if (!message) return false;
        return /memory access out of bounds/i.test(message);
      }

      function applyEngineMemoryFallback() {
        if (engineConfig.hash <= ENGINE_MEMORY_ERROR_FALLBACK_HASH_MB) {
          return false;
        }
        engineConfig.hash = ENGINE_MEMORY_ERROR_FALLBACK_HASH_MB;
        syncEngineInputs();
        return true;
      }

      function buildWorkerInitializationErrorMessage(error, context = {}) {
        const stage = context && context.stage === 'runtime' ? 'runtime' : 'load';
        const detail = extractErrorMessage(error) || 'Unable to initialize Stockfish worker.';
        const trimmedDetail = detail.trim();
        const normalizedDetail = trimmedDetail.length
          ? (trimmedDetail.endsWith('.') ? trimmedDetail : `${trimmedDetail}.`)
          : '';
        if (stage === 'runtime') {
          if (isMemoryAccessOutOfBoundsError(error)) {
            return 'Stockfish worker crashed. The engine ran out of memory while allocating its hash table. Reduce the Hash setting (e.g., 16 MB) and try again.';
          }
          return normalizedDetail
            ? `Stockfish worker crashed. ${normalizedDetail}`
            : 'Stockfish worker crashed.';
        }
          const baseGuidance = defaultWorkerLocation
            ? `Place the worker at ${defaultWorkerLocation} or set window.STOCKFISH_WORKER_PATH.`
            : 'Set window.STOCKFISH_WORKER_PATH to the Stockfish worker file.';
          const threadedGuidance = requiresThreadedVariant
            ? ' Threaded builds also require SharedArrayBuffer support. Serve the page with COOP/COEP headers so window.crossOriginIsolated is true, and ensure stockfish.worker.js and the NNUE wasm file are accessible next to the worker script.'
            : '';
          const guidance = `${baseGuidance}${threadedGuidance}`.trim();
          return normalizedDetail ? `${normalizedDetail} ${guidance}` : guidance;
      }

      function determineWorkerErrorStage(event, message) {
        if (!event) return 'load';
        if (typeof WebAssembly !== 'undefined' && typeof WebAssembly.RuntimeError === 'function') {
          if (event.error instanceof WebAssembly.RuntimeError) {
            return 'runtime';
          }
        }
        if (typeof message === 'string' && message.includes('RuntimeError')) {
          return 'runtime';
        }
        return 'load';
      }

      function setButtonLabel(element, label) {
        if (!element || typeof label !== 'string') return;
        element.setAttribute('aria-label', label);
        const hidden = element.querySelector('.visually-hidden');
        if (hidden) {
          hidden.textContent = label;
        }
      }

      function setButtonActive(element, isActive, activeLabel, inactiveLabel) {
        if (!element) return;
        element.classList.toggle('is-active', !!isActive);
        if (element.hasAttribute('aria-pressed')) {
          element.setAttribute('aria-pressed', isActive ? 'true' : 'false');
        }
        if (isActive && activeLabel) {
          setButtonLabel(element, activeLabel);
        } else if (!isActive && inactiveLabel) {
          setButtonLabel(element, inactiveLabel);
        }
      }

      function syncBestMoveButton() {
        setButtonActive(bestMoveButtonElement, bestMoveVisible, 'Hide best move', 'Show best move');
      }

      function syncAdvantageButton() {
        setButtonActive(advantageToggleButton, advantageBarVisible, 'Hide advantage bar', 'Show advantage bar');
      }

      function syncProbabilityButton() {
        setButtonActive(probabilityButtonElement, probabilityPanelVisible, 'Hide evaluation graph', 'Show evaluation graph');
      }

      function syncPieceMovesButton() {
        setButtonActive(pieceMovesButtonElement, pieceMovesMode, 'Return to play mode', 'Show piece moves');
      }

      function syncEditButton() {
        setButtonActive(editButtonElement, editMode, 'Exit edit mode', 'Enter edit mode');
      }

      function syncEngineButton() {
        setButtonActive(engineButtonElement, enginePanelVisible, 'Hide engine settings', 'Show engine settings');
      }

      function syncEnginePanelVisibility() {
        if (!engineSettingsElement) return;
        if (enginePanelVisible) {
          engineSettingsElement.hidden = false;
          engineSettingsElement.setAttribute('aria-hidden', 'false');
        } else {
          engineSettingsElement.hidden = true;
          engineSettingsElement.setAttribute('aria-hidden', 'true');
        }
        syncEngineButton();
      }

      function setEngineStatusDisplay(state, label) {
        if (!engineStatusElement) return;
        const normalizedState = state || 'idle';
        engineStatusElement.dataset.state = normalizedState;
        engineStatusElement.textContent = label || '';
      }

      function setEngineErrorMessage(message, options = {}) {
        if (!engineErrorElement) return;
        const { source = '', force = false } = options || {};
        const currentSource = engineErrorElement.dataset.source || '';
        if (!message && !force && currentSource === 'engine-error') {
          return;
        }
        if (message) {
          engineErrorElement.hidden = false;
          engineErrorElement.textContent = message;
          engineErrorElement.setAttribute('aria-hidden', 'false');
        } else {
          engineErrorElement.hidden = true;
          engineErrorElement.textContent = '';
          engineErrorElement.setAttribute('aria-hidden', 'true');
        }
        engineErrorElement.dataset.source = source;
      }

      function deactivateLastAnalysisRequest() {
        if (lastAnalysisRequest) {
          lastAnalysisRequest.active = false;
        }
      }

      function invalidateAnalysisCache() {
        deactivateLastAnalysisRequest();
        lastAnalysisRequest = null;
      }

      function normalizeSearchMovesForCache(value) {
        if (!value) {
          return '';
        }
        if (Array.isArray(value)) {
          return value.filter(move => typeof move === 'string' && move.length).join(' ');
        }
        if (typeof value === 'string') {
          return value.trim();
        }
        return '';
      }

      function createAnalysisRequestCacheEntry({
        fen,
        pieceAnalysis = false,
        searchMoves = null,
        multiPv = 1,
        autoPlay = false,
        depth = engineConfig.depth
      }) {
        const numericDepth = Number(depth);
        const resolvedDepth = Number.isFinite(numericDepth)
          ? Math.max(1, Math.floor(numericDepth))
          : engineConfig.depth;
        const numericMultiPv = Number(multiPv);
        const resolvedMultiPv = Number.isFinite(numericMultiPv)
          ? Math.max(1, Math.floor(numericMultiPv))
          : 1;
        return {
          fen: typeof fen === 'string' ? fen : '',
          pieceAnalysis: !!pieceAnalysis,
          searchMoves: normalizeSearchMovesForCache(searchMoves),
          multiPv: resolvedMultiPv,
          autoPlay: !!autoPlay,
          depth: resolvedDepth
        };
      }

      function analysisRequestsMatch(a, b) {
        if (!a || !b) return false;
        return a.fen === b.fen
          && a.pieceAnalysis === b.pieceAnalysis
          && a.searchMoves === b.searchMoves
          && a.multiPv === b.multiPv
          && a.autoPlay === b.autoPlay
          && a.depth === b.depth;
      }

      function markAnalysisRequestActive(entry) {
        if (!entry) {
          lastAnalysisRequest = null;
          return;
        }
        lastAnalysisRequest = { ...entry, active: true };
      }

      function updateLastObservedFen(fen) {
        if (typeof fen === 'string' && fen.length) {
          lastObservedPositionFen = fen;
        }
      }

      function resetEngineCommandQueue() {
        engineCommandQueue = [];
        engineAwaitingReadyAfterStop = false;
        engineStopPending = false;
        invalidateAnalysisCache();
        pendingSearchContext = null;
        currentSearchContext = null;
      }

      function activatePendingSearchContext(command) {
        if (typeof command !== 'string' || !command.trim().startsWith('go')) {
          return;
        }
        const now = Date.now();
        const context = pendingSearchContext
          ? { ...pendingSearchContext }
          : { type: 'analysis', metadata: {} };
        currentSearchContext = { ...context, startedAt: now };
        pendingSearchContext = null;
        if (currentSearchContext.type === 'piece') {
          pieceAnalysisSearchInFlight = true;
          if (pieceAnalysisPendingRequestId) {
            pieceAnalysisCurrentRequestId = pieceAnalysisPendingRequestId;
            pieceAnalysisPendingRequestId = 0;
          }
        }
      }

      function postEngineCommand(command, options = {}) {
        if (!engine) return;
        const text = typeof command === 'string' ? command.trim() : '';
        if (!text) return;
        const { queueIfPending = true } = options;
        const willQueue = queueIfPending && engineAwaitingReadyAfterStop;
        if (willQueue) {
          engineCommandQueue.push(text);
          return;
        }
        try {
          engine.postMessage(text);
          if (text.startsWith('go ')) {
            activatePendingSearchContext(text);
          }
        } catch (error) {
          console.warn(`Failed to send command to engine: ${text}`, error);
        }
      }

      function beginEngineReadyWait() {
        if (!engine || engineAwaitingReadyAfterStop) {
          return;
        }
        engineAwaitingReadyAfterStop = true;
        try {
          engine.postMessage('isready');
        } catch (error) {
          engineAwaitingReadyAfterStop = false;
          engineCommandQueue = [];
          console.warn('Failed to send isready command to engine', error);
        }
      }

      function queueEngineCommands(commands) {
        if (Array.isArray(commands)) {
          commands.forEach(cmd => postEngineCommand(cmd));
          return;
        }
        postEngineCommand(commands);
      }

      function resolveEngineReadyWait() {
        if (!engineAwaitingReadyAfterStop) {
          return;
        }
        const queued = engineCommandQueue.slice();
        engineCommandQueue = [];
        engineAwaitingReadyAfterStop = false;
        if (!engine || !queued.length) {
          return;
        }
        queued.forEach(cmd => postEngineCommand(cmd, { queueIfPending: false }));
      }

      function displayEngineConfigWarnings(result) {
        if (result && Array.isArray(result.warnings) && result.warnings.length) {
          setEngineErrorMessage(result.warnings.join(' '), { source: 'config-warning' });
        } else if (engineErrorElement && engineErrorElement.dataset.source === 'config-warning') {
          setEngineErrorMessage('', { source: '' });
        }
      }

      function computeBackgroundHashBudget(mainHash) {
        const numericHash = Number(mainHash);
        if (!Number.isFinite(numericHash)) {
          return Math.max(1, Math.floor(engineConfig.hash));
        }
        return Math.max(1, Math.floor(numericHash));
      }

      function applyEngineConfig(config = {}) {
        const previousThreads = engineConfig.threads;
        const previousHash = engineConfig.hash;
        const previousDepth = engineConfig.depth;
        const warnings = [];
        const fallbackThreads = previousThreads >= ENGINE_THREADS_MIN ? previousThreads : ENGINE_THREADS_MIN;
        let threads = Number(config.threads);
        if (!Number.isFinite(threads) || threads < ENGINE_THREADS_MIN) {
          threads = fallbackThreads;
        } else {
          threads = Math.floor(threads);
        }
        const fallbackHash = previousHash >= 1 ? previousHash : 1;
        let hash = Number(config.hash);
        if (!Number.isFinite(hash) || hash < 1) {
          hash = fallbackHash;
        } else {
          hash = Math.floor(hash);
        }
        const fallbackDepth = previousDepth >= 1 ? previousDepth : 1;
        let depth = Number(config.depth);
        if (!Number.isFinite(depth) || depth < 1) {
          depth = fallbackDepth;
        } else {
          depth = Math.floor(depth);
        }
        engineConfig.threads = threads;
        engineConfig.hash = hash;
        engineConfig.depth = depth;
        autoPlayTargetDepth = depth;
        replayTargetDepth = depth;
        syncEngineInputs();
        const changed = threads !== previousThreads || hash !== previousHash || depth !== previousDepth;
        return { threads, hash, depth, changed, warnings };
      }

      function syncEngineInputs() {
        if (engineThreadsInput) {
          engineThreadsInput.removeAttribute('max');
          engineThreadsInput.value = engineConfig.threads;
        }
        if (engineHashInput) {
          engineHashInput.removeAttribute('max');
          engineHashInput.value = engineConfig.hash;
        }
        if (engineDepthInput) {
          engineDepthInput.removeAttribute('max');
          engineDepthInput.value = engineConfig.depth;
        }
        updateEngineHashHelp();
      }

      function updateEngineHashHelp() {
        if (!engineHelpElement) return;
        engineHelpElement.textContent = '';
      }

      function updateEngineControls(options = {}) {
        const { loading = false } = options;
        const hasWorker = !!engine;
        if (engineStartButtonElement) {
          engineStartButtonElement.disabled = loading;
          if (loading) {
            engineStartButtonElement.setAttribute('aria-busy', 'true');
          } else {
            engineStartButtonElement.removeAttribute('aria-busy');
          }
          const labelElement = engineStartButtonElement.querySelector('.engine-action-button__label') || engineStartButtonElement;
          if (labelElement) {
            if (loading) {
              labelElement.textContent = 'Starting…';
            } else if (hasWorker) {
              labelElement.textContent = 'Restart engine';
            } else {
              labelElement.textContent = 'Start engine';
            }
          }
        }
        if (engineStopButtonElement) {
          engineStopButtonElement.disabled = !hasWorker || loading;
          const stopLabel = engineStopButtonElement.querySelector('.engine-action-button__label') || engineStopButtonElement;
          if (stopLabel) {
            stopLabel.textContent = 'Stop engine';
          }
        }
      }

      function cancelEngineAutostart() {
        if (engineAutostartTimer) {
          clearTimeout(engineAutostartTimer);
          engineAutostartTimer = null;
        }
        engineAutostartScheduled = false;
      }

      function scheduleEngineAutostart(options = {}) {
        const { immediate = false, resetAttempts = false, delay = ENGINE_AUTOSTART_DELAY_MS } = options || {};
        if (engineAutostartDisabled) {
          return;
        }
        if (resetAttempts) {
          engineAutostartAttempts = 0;
        }
        if (engineReady || engineStarting || engineAutostartScheduled) {
          return;
        }
        if (engineAutostartAttempts >= ENGINE_AUTOSTART_MAX_ATTEMPTS) {
          return;
        }
        engineAutostartScheduled = true;
        const triggerStart = () => {
          engineAutostartScheduled = false;
          if (engineReady || engineStarting) {
            return;
          }
          if (engineAutostartAttempts >= ENGINE_AUTOSTART_MAX_ATTEMPTS) {
            return;
          }
          engineAutostartAttempts += 1;
          startEngine({ autostart: true });
        };
        if (immediate) {
          triggerStart();
        } else {
          const timeout = Math.max(0, Number(delay) || 0);
          const scheduleFn = (typeof window !== 'undefined' && typeof window.setTimeout === 'function') ? window.setTimeout : setTimeout;
          engineAutostartTimer = scheduleFn(triggerStart, timeout);
        }
      }
      const stockfishOverridePath = typeof window !== 'undefined'
        ? (window.STOCKFISH_WORKER_PATH || (window.STOCKFISH && window.STOCKFISH.workerPath) || null)
        : null;
      const stockfishWorkerPathOverrides = (() => {
        if (typeof window === 'undefined') {
          return null;
        }
        const sources = [];
        if (window.STOCKFISH_WORKER_PATHS && typeof window.STOCKFISH_WORKER_PATHS === 'object') {
          sources.push(window.STOCKFISH_WORKER_PATHS);
        }
        if (window.STOCKFISH && window.STOCKFISH.workerPaths && typeof window.STOCKFISH.workerPaths === 'object') {
          sources.push(window.STOCKFISH.workerPaths);
        }
        if (!sources.length) {
          return null;
        }
        const map = new Map();
        const appendOverride = (key, value) => {
          if (!key) return;
          const normalizedKey = String(key).toLowerCase();
          if (typeof value === 'string') {
            const trimmed = value.trim();
            if (trimmed.length) {
              map.set(normalizedKey, [trimmed]);
            }
            return;
          }
          if (Array.isArray(value)) {
            const normalizedValues = value
              .map(entry => (typeof entry === 'string' ? entry.trim() : ''))
              .filter(entry => entry.length);
            if (normalizedValues.length) {
              map.set(normalizedKey, normalizedValues);
            }
          }
        };
        for (const source of sources) {
          if (!source) continue;
          for (const [key, value] of Object.entries(source)) {
            appendOverride(key, value);
          }
        }
        return map.size ? map : null;
      })();

      function supportsThreadedWorkers() {
        if (typeof window === 'undefined') {
          return true;
        }
        if (window.crossOriginIsolated !== true) {
          return false;
        }
        return typeof SharedArrayBuffer === 'function' && typeof Atomics === 'object';
      }

      function buildWorkerCandidatePaths(filename) {
        const normalizedFilename = typeof filename === 'string' ? filename.trim() : '';
        if (!normalizedFilename.length) {
          return [];
        }
        const directories = (() => {
          const entries = [];
          if (Array.isArray(STOCKFISH_WORKER_DIRECTORIES)) {
            for (const value of STOCKFISH_WORKER_DIRECTORIES) {
              if (typeof value === 'string' && value.trim().length) {
                entries.push(value.trim());
              }
            }
          } else if (typeof STOCKFISH_WORKER_DIRECTORIES === 'string' && STOCKFISH_WORKER_DIRECTORIES.trim().length) {
            entries.push(STOCKFISH_WORKER_DIRECTORIES.trim());
          }
          if (typeof STOCKFISH_ENGINE_DIRECTORY === 'string' && STOCKFISH_ENGINE_DIRECTORY.trim().length) {
            entries.push(STOCKFISH_ENGINE_DIRECTORY.trim());
          }
          entries.push('engine', 'engine2', '.');
          return entries;
        })();
        const seen = new Set();
        const candidates = [];
        const addCandidate = candidate => {
          if (!candidate || seen.has(candidate)) {
            return;
          }
          seen.add(candidate);
          candidates.push(candidate);
        };
        const appendDirectoryCandidates = directory => {
          if (typeof directory !== 'string') {
            return;
          }
          const trimmed = directory.trim();
          if (!trimmed.length || trimmed === '.') {
            addCandidate(`./${normalizedFilename}`);
            addCandidate(normalizedFilename);
            return;
          }
          const normalizedDirectory = trimmed.replace(/^\.\//, '').replace(/\/+$/, '');
          if (!normalizedDirectory.length) {
            addCandidate(`./${normalizedFilename}`);
            addCandidate(normalizedFilename);
            return;
          }
          addCandidate(`./${normalizedDirectory}/${normalizedFilename}`);
          addCandidate(`${normalizedDirectory}/${normalizedFilename}`);
        };
        directories.forEach(appendDirectoryCandidates);
        addCandidate(`./${normalizedFilename}`);
        addCandidate(normalizedFilename);
        return candidates;
      }

      let engineWorkerCandidatesCache = null;

      function getStockfishWorkerOverrideCandidates() {
        const overrides = new Set();
        if (stockfishWorkerPathOverrides) {
          for (const value of stockfishWorkerPathOverrides.values()) {
            if (!Array.isArray(value)) {
              continue;
            }
            for (const entry of value) {
              if (typeof entry === 'string' && entry.trim().length) {
                overrides.add(entry.trim());
              }
            }
          }
        }
        if (typeof stockfishOverridePath === 'string' && stockfishOverridePath.trim().length) {
          overrides.add(stockfishOverridePath.trim());
        }
        return overrides.size ? Array.from(overrides) : null;
      }

      function getEngineWorkerCandidates() {
        if (Array.isArray(engineWorkerCandidatesCache) && engineWorkerCandidatesCache.length) {
          return engineWorkerCandidatesCache;
        }
        const seen = new Set();
        const candidates = [];
        const addCandidate = value => {
          if (!value || seen.has(value)) {
            return;
          }
          seen.add(value);
          candidates.push(value);
        };

        const overrideCandidates = getStockfishWorkerOverrideCandidates();
        if (overrideCandidates && overrideCandidates.length) {
          overrideCandidates.forEach(addCandidate);
        }

        const variantsToConsider = (() => {
          const availableVariants = Array.isArray(STOCKFISH_WORKER_VARIANTS)
            ? STOCKFISH_WORKER_VARIANTS.filter(Boolean)
            : [];
          if (!selectedStockfishVariant) {
            return availableVariants;
          }
          const prioritized = [selectedStockfishVariant];
          for (const variant of availableVariants) {
            if (variant === selectedStockfishVariant) {
              continue;
            }
            prioritized.push(variant);
          }
          return prioritized;
        })();
        for (const variant of variantsToConsider) {
          if (!variant) {
            continue;
          }
          const { filename, requiresThreadSupport } = variant;
          if (requiresThreadSupport && !threadSupportAvailable) {
            continue;
          }
          const variantCandidates = buildWorkerCandidatePaths(filename);
          for (const candidate of variantCandidates) {
            addCandidate(candidate);
          }
        }

        if (!candidates.length && overrideCandidates && overrideCandidates.length) {
          overrideCandidates.forEach(addCandidate);
        }

        if (!candidates.length && typeof defaultWorkerLocation === 'string' && defaultWorkerLocation.length) {
          addCandidate(defaultWorkerLocation);
        }

        engineWorkerCandidatesCache = candidates.slice();
        return engineWorkerCandidatesCache;
      }

      function resolveWorkerCandidate(path) {
        try {
          const { origin, pathname } = window.location;
          let basePath = pathname || '/';

          if (!basePath.endsWith('/')) {
            const lastSegment = basePath.split('/').pop();
            if (lastSegment && !lastSegment.includes('.')) {
              basePath += '/';
            }
          }

          const baseUrl = `${origin}${basePath}`;
          return new URL(path, baseUrl).toString();
        } catch (error) {
          return path;
        }
      }

      function createStockfishWorker() {
        if (typeof Worker !== 'function') {
          throw new Error('Web Workers are not supported in this environment.');
        }
        let lastError = null;
        const candidates = getEngineWorkerCandidates();
        for (const candidate of candidates) {
          const absoluteCandidate = resolveWorkerCandidate(candidate);
          try {
            const worker = new Worker(absoluteCandidate);
            worker.addEventListener('error', event => {
              console.error(`Stockfish worker error (${absoluteCandidate})`, event?.message || event);
            });
            return worker;
          } catch (error) {
            console.error(`Failed to start Stockfish worker from ${absoluteCandidate}`, error);
            lastError = error;
          }
        }
        throw lastError || new Error('Unable to initialize Stockfish worker.');
      }
      if (advantageBarElement) {
        advantageBarElement.hidden = true;
        advantageBarElement.style.display = 'none';
        advantageBarElement.setAttribute('aria-hidden', 'true');
      }
      if (evaluationContainer) {
        evaluationContainer.hidden = true;
        evaluationContainer.style.display = 'none';
        evaluationContainer.setAttribute('aria-hidden', 'true');
      }
      if (evaluationElement) {
        const defaultLabel = 'Win chance --';
        const hiddenLabel = evaluationElement.querySelector('.visually-hidden');
        if (hiddenLabel) hiddenLabel.textContent = defaultLabel;
        evaluationElement.setAttribute('aria-label', defaultLabel);
        evaluationElement.dataset.probability = '0.5';
        evaluationElement.style.setProperty('--eval-scale', '0.5');
        if (evaluationValueElement) {
          evaluationValueElement.textContent = '--';
        }
        setEvaluationLiveMode(false);
      }
      syncBestMoveButton();
      syncAdvantageButton();
      syncProbabilityButton();
      syncPieceMovesButton();
      syncEditButton();
      if (probabilityPanel) {
        probabilityPanel.hidden = true;
        probabilityPanel.setAttribute('aria-hidden', 'true');
      }
      let lastAdvantageRatio = 0.5;
      function setEvaluationText(text, probability = null) {
        if (!evaluationElement) return;
        const label = typeof text === 'string' ? text : '';
        const hiddenLabel = evaluationElement.querySelector('.visually-hidden');
        if (hiddenLabel) {
          hiddenLabel.textContent = label;
        }
        evaluationElement.setAttribute('aria-label', label);
        let displayValue = '--';
        const hasProbability = typeof probability === 'number' && !Number.isNaN(probability);
        if (hasProbability) {
          const clamped = Math.max(0, Math.min(1, Number(probability) || 0));
          evaluationElement.dataset.probability = clamped.toString();
          evaluationElement.style.setProperty('--eval-scale', clamped.toString());
          if (label && !label.includes('--')) {
            displayValue = formatWinProbability(clamped);
          }
        } else if (label && !label.includes('--')) {
          displayValue = label;
        }
        if (evaluationValueElement) {
          evaluationValueElement.textContent = displayValue;
        } else if (!hiddenLabel) {
          evaluationElement.textContent = displayValue;
        }
      }

      function setEvaluationLiveMode(isVisible) {
        if (!evaluationElement) return;
        evaluationElement.setAttribute('aria-live', isVisible ? 'polite' : 'off');
      }

      function clearInputModalError() {
        if (!inputModalErrorElement) return;
        inputModalErrorElement.hidden = true;
        inputModalErrorElement.textContent = '';
      }

      function showInputModalError(message) {
        if (!inputModalErrorElement) return;
        const text = typeof message === 'string' && message.trim().length
          ? message.trim()
          : 'Invalid FEN or PGN.';
        inputModalErrorElement.hidden = false;
        inputModalErrorElement.textContent = text;
      }

      function getInputModalFocusableElements() {
        if (!inputModalElement) {
          return [];
        }
        const selectors = [
          'button:not([disabled])',
          'input:not([disabled])',
          'textarea:not([disabled])',
          'select:not([disabled])',
          '[tabindex]:not([tabindex="-1"])',
          'a[href]'
        ];
        const candidates = Array.from(inputModalElement.querySelectorAll(selectors.join(',')));
        return candidates.filter(element => {
          if (!element || typeof element.focus !== 'function') {
            return false;
          }
          if (element.getAttribute && element.getAttribute('aria-hidden') === 'true') {
            return false;
          }
          if ('disabled' in element && element.disabled) {
            return false;
          }
          if (typeof window !== 'undefined' && typeof window.getComputedStyle === 'function') {
            const style = window.getComputedStyle(element);
            if (style && (style.visibility === 'hidden' || style.display === 'none')) {
              return false;
            }
          }
          return true;
        });
      }

      function trapInputModalFocus(event) {
        if (!inputModalElement || event.key !== 'Tab') {
          return;
        }
        const focusable = getInputModalFocusableElements();
        if (!focusable.length) {
          return;
        }
        const first = focusable[0];
        const last = focusable[focusable.length - 1];
        if (event.shiftKey) {
          if (document.activeElement === first || !focusable.includes(document.activeElement)) {
            event.preventDefault();
            last.focus();
          }
        } else if (document.activeElement === last) {
          event.preventDefault();
          first.focus();
        }
      }

      function setArchiveStatus(message, options = {}) {
        if (!archiveStatusElement) {
          return;
        }
        const { state = 'idle' } = options || {};
        const text = typeof message === 'string' ? message : '';
        archiveStatusElement.textContent = text;
        if (state) {
          archiveStatusElement.setAttribute('data-state', state);
        } else {
          archiveStatusElement.removeAttribute('data-state');
        }
      }

      function getArchiveSourceLabel(source) {
        switch (source) {
          case ARCHIVE_SEARCH_SOURCES.CHESSCOM:
            return 'Chess.com';
          case ARCHIVE_SEARCH_SOURCES.LICHESS:
            return 'Lichess';
          default:
            return 'the selected source';
        }
      }

      function describeArchiveUsername(username) {
        const trimmed = typeof username === 'string' ? username.trim() : '';
        return trimmed.length ? `“${trimmed}”` : 'that username';
      }

      function clearArchiveResults() {
        archiveSearchEntries = [];
        if (archiveResultsElement) {
          archiveResultsElement.innerHTML = '';
          archiveResultsElement.hidden = true;
          archiveResultsElement.removeAttribute('aria-busy');
        }
        if (archiveSearchSection) {
          archiveSearchSection.setAttribute('data-has-results', 'false');
        }
      }

      function extractPgnTagValue(pgn, tagName) {
        if (typeof pgn !== 'string' || typeof tagName !== 'string') {
          return '';
        }
        const pattern = new RegExp(`\\[${tagName}\\s+"([^\"]*)"\\]`, 'i');
        const match = pattern.exec(pgn);
        if (!match) {
          return '';
        }
        return match[1].trim();
      }

      function formatArchiveDate(dateTag, timeTag) {
        if (typeof dateTag !== 'string') {
          return '';
        }
        const match = dateTag.match(/^(\d{4})\.(\d{2})\.(\d{2})$/);
        if (!match) {
          return '';
        }
        const [, year, month, day] = match;
        if (year.includes('?') || month.includes('?') || day.includes('?')) {
          return '';
        }
        const isoDate = `${year}-${month}-${day}`;
        const hasTime = typeof timeTag === 'string' && /^\d{2}:\d{2}:\d{2}$/.test(timeTag);
        const date = hasTime
          ? new Date(`${isoDate}T${timeTag}Z`)
          : new Date(`${isoDate}T00:00:00Z`);
        if (Number.isNaN(date.getTime())) {
          return '';
        }
        try {
          const options = { dateStyle: 'medium' };
          if (hasTime) {
            options.timeStyle = 'short';
          }
          return new Intl.DateTimeFormat(undefined, options).format(date);
        } catch (error) {
          const iso = date.toISOString();
          return hasTime ? iso.replace('T', ' ').replace(/Z$/, '') : iso.slice(0, 10);
        }
      }

      function formatArchiveResultTitle(entry) {
        if (!entry) {
          return 'View game';
        }
        const pgn = typeof entry.pgn === 'string' ? entry.pgn : '';
        const white = extractPgnTagValue(pgn, 'White') || 'White';
        const black = extractPgnTagValue(pgn, 'Black') || 'Black';
        return `${white} vs ${black}`;
      }

      function formatArchiveResultMeta(entry) {
        if (!entry) {
          return '';
        }
        const pgn = typeof entry.pgn === 'string' ? entry.pgn : '';
        const metaParts = [];
        const seen = new Set();
        const addPart = value => {
          if (!value) {
            return;
          }
          const normalized = value.toLowerCase();
          if (seen.has(normalized)) {
            return;
          }
          seen.add(normalized);
          metaParts.push(value);
        };
        const result = extractPgnTagValue(pgn, 'Result');
        if (result && result !== '*') {
          addPart(result);
        }
        const formattedDate = formatArchiveDate(
          extractPgnTagValue(pgn, 'Date'),
          extractPgnTagValue(pgn, 'UTCTime')
        );
        if (formattedDate) {
          addPart(formattedDate);
        }
        const event = extractPgnTagValue(pgn, 'Event');
        if (event) {
          addPart(event);
        }
        const siteTag = extractPgnTagValue(pgn, 'Site');
        const sourceLabel = entry.sourceLabel || '';
        if (siteTag && (!sourceLabel || siteTag.toLowerCase() !== sourceLabel.toLowerCase())) {
          addPart(siteTag);
        }
        if (sourceLabel) {
          addPart(sourceLabel);
        }
        return metaParts.join(' • ');
      }

      function renderArchiveResults(entries) {
        archiveSearchEntries = Array.isArray(entries)
          ? entries.slice(0, ARCHIVE_SEARCH_LIMIT)
          : [];
        if (!archiveResultsElement) {
          return;
        }
        archiveResultsElement.innerHTML = '';
        archiveResultsElement.removeAttribute('aria-busy');
        if (!archiveSearchEntries.length) {
          archiveResultsElement.hidden = true;
          if (archiveSearchSection) {
            archiveSearchSection.setAttribute('data-has-results', 'false');
          }
          return;
        }
        const fragment = document.createDocumentFragment();
        archiveSearchEntries.forEach((entry, index) => {
          const item = document.createElement('li');
          item.className = 'archive-search__result-item';
          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'archive-search__result-button';
          button.setAttribute('data-archive-index', String(index));
          const title = formatArchiveResultTitle(entry);
          const meta = formatArchiveResultMeta(entry);
          const primary = document.createElement('span');
          primary.className = 'archive-search__result-primary';
          primary.textContent = title;
          button.appendChild(primary);
          if (meta) {
            const metaElement = document.createElement('span');
            metaElement.className = 'archive-search__result-meta';
            metaElement.textContent = meta;
            button.appendChild(metaElement);
          }
          const tooltipParts = [title, meta, entry && entry.url ? entry.url : '', 'Click to load this game']
            .filter(part => typeof part === 'string' && part.trim().length);
          if (tooltipParts.length) {
            button.title = tooltipParts.join(' • ');
          }
          item.appendChild(button);
          fragment.appendChild(item);
        });
        archiveResultsElement.appendChild(fragment);
        archiveResultsElement.hidden = false;
        if (archiveSearchSection) {
          archiveSearchSection.setAttribute('data-has-results', 'true');
        }
      }

      function setArchiveButtonsDisabled(disabled) {
        const buttons = [archiveChesscomButton, archiveLichessButton];
        buttons.forEach(button => {
          if (button) {
            button.disabled = !!disabled;
          }
        });
      }

      function isAbortError(error) {
        if (!error) {
          return false;
        }
        if (error.name === 'AbortError') {
          return true;
        }
        return error.code === 'ABORT_ERR';
      }

      function buildArchiveErrorMessage(source, error, username) {
        const sourceLabel = getArchiveSourceLabel(source);
        if (error && error.code === 'not_found') {
          return `${sourceLabel} user ${describeArchiveUsername(username)} was not found.`;
        }
        if (error && error.code === 'rate_limited') {
          return `${sourceLabel} temporarily rate limited the request. Please try again later.`;
        }
        const status = error && (error.status || error.statusCode);
        if (status) {
          return `Unable to load games from ${sourceLabel} (status ${status}).`;
        }
        const detail = extractErrorMessage(error);
        if (detail) {
          return `Unable to load games from ${sourceLabel}: ${detail}`;
        }
        return `Unable to load games from ${sourceLabel}.`;
      }

      async function fetchChessComGames(username, { signal } = {}) {
        const normalizedUsername = typeof username === 'string' ? username.trim().toLowerCase() : '';
        if (!normalizedUsername.length) {
          return [];
        }
        const archivesUrl = `https://api.chess.com/pub/player/${encodeURIComponent(normalizedUsername)}/games/archives`;
        const archivesResponse = await fetch(archivesUrl, {
          signal,
          headers: { Accept: 'application/json' },
          cache: 'no-store'
        });
        if (!archivesResponse.ok) {
          const error = new Error('Chess.com request failed.');
          error.status = archivesResponse.status;
          if (archivesResponse.status === 404) {
            error.code = 'not_found';
            error.message = 'Chess.com user not found.';
          } else if (archivesResponse.status === 429) {
            error.code = 'rate_limited';
          }
          throw error;
        }
        let archivesPayload = null;
        try {
          archivesPayload = await archivesResponse.json();
        } catch (parseError) {
          if (isAbortError(parseError)) {
            throw parseError;
          }
          const error = new Error('Unexpected response from Chess.com.');
          throw error;
        }
        const archives = Array.isArray(archivesPayload && archivesPayload.archives)
          ? archivesPayload.archives.slice().reverse()
          : [];
        if (!archives.length) {
          return [];
        }
        const games = [];
        const consideredArchives = archives.slice(0, CHESS_COM_MAX_ARCHIVES);
        for (const archiveUrl of consideredArchives) {
          if (games.length >= ARCHIVE_SEARCH_LIMIT) {
            break;
          }
          if (!archiveUrl) {
            continue;
          }
          const monthResponse = await fetch(archiveUrl, {
            signal,
            headers: { Accept: 'application/json' },
            cache: 'no-store'
          });
          if (!monthResponse.ok) {
            if (monthResponse.status === 404) {
              continue;
            }
            const error = new Error('Chess.com archive request failed.');
            error.status = monthResponse.status;
            if (monthResponse.status === 429) {
              error.code = 'rate_limited';
            }
            throw error;
          }
          let monthPayload = null;
          try {
            monthPayload = await monthResponse.json();
          } catch (parseError) {
            if (isAbortError(parseError)) {
              throw parseError;
            }
            continue;
          }
          const monthGames = Array.isArray(monthPayload && monthPayload.games)
            ? monthPayload.games.slice().reverse()
            : [];
          for (const game of monthGames) {
            if (games.length >= ARCHIVE_SEARCH_LIMIT) {
              break;
            }
            if (!game || typeof game.pgn !== 'string') {
              continue;
            }
            const trimmedPgn = game.pgn.trim();
            if (!trimmedPgn.length) {
              continue;
            }
            games.push({
              pgn: trimmedPgn,
              url: typeof game.url === 'string' ? game.url : '',
              source: ARCHIVE_SEARCH_SOURCES.CHESSCOM,
              sourceLabel: 'Chess.com'
            });
          }
        }
        return games;
      }

      async function fetchLichessGames(username, { signal } = {}) {
        const trimmedUsername = typeof username === 'string' ? username.trim() : '';
        if (!trimmedUsername.length) {
          return [];
        }
        const params = new URLSearchParams({
          max: String(ARCHIVE_SEARCH_LIMIT),
          moves: 'true',
          pgnInJson: 'true',
          clocks: 'false',
          evals: 'false',
          opening: 'true'
        });
        const lichessUrl = `https://lichess.org/api/games/user/${encodeURIComponent(trimmedUsername)}?${params.toString()}`;
        const lichessResponse = await fetch(lichessUrl, {
          signal,
          headers: { Accept: 'application/x-ndjson' },
          cache: 'no-store'
        });
        if (!lichessResponse.ok) {
          const error = new Error('Lichess request failed.');
          error.status = lichessResponse.status;
          if (lichessResponse.status === 404) {
            error.code = 'not_found';
            error.message = 'Lichess user not found.';
          } else if (lichessResponse.status === 429) {
            error.code = 'rate_limited';
          }
          throw error;
        }
        const text = await lichessResponse.text();
        if (!text || !text.trim().length) {
          return [];
        }
        const games = [];
        const lines = text.split(/\r?\n/);
        for (const line of lines) {
          if (games.length >= ARCHIVE_SEARCH_LIMIT) {
            break;
          }
          const trimmed = line.trim();
          if (!trimmed.length) {
            continue;
          }
          let parsed = null;
          try {
            parsed = JSON.parse(trimmed);
          } catch (parseError) {
            continue;
          }
          if (!parsed || typeof parsed.pgn !== 'string') {
            continue;
          }
          const trimmedPgn = parsed.pgn.trim();
          if (!trimmedPgn.length) {
            continue;
          }
          let gameUrl = '';
          if (typeof parsed.url === 'string' && parsed.url.trim().length) {
            gameUrl = parsed.url.trim();
          } else if (typeof parsed.id === 'string' && parsed.id.trim().length) {
            gameUrl = `https://lichess.org/${parsed.id.trim()}`;
          }
          games.push({
            pgn: trimmedPgn,
            url: gameUrl,
            source: ARCHIVE_SEARCH_SOURCES.LICHESS,
            sourceLabel: 'Lichess'
          });
        }
        return games;
      }

      async function handleArchiveSearch(source) {
        const targetSource = source || ARCHIVE_SEARCH_SOURCES.CHESSCOM;
        archiveSearchLastSource = targetSource;
        if (!archiveSearchInput) {
          return;
        }
        const username = archiveSearchInput.value.trim();
        if (!username.length) {
          setArchiveStatus('Enter a username to search.', { state: 'error' });
          archiveSearchInput.focus();
          return;
        }
        clearInputModalError();
        if (archiveSearchAbortController && typeof archiveSearchAbortController.abort === 'function') {
          archiveSearchAbortController.abort();
        }
        const controller = typeof AbortController === 'function' ? new AbortController() : null;
        if (controller) {
          archiveSearchAbortController = controller;
        } else {
          archiveSearchAbortController = null;
        }
        const signal = controller ? controller.signal : undefined;
        const requestToken = ++archiveSearchToken;
        setArchiveButtonsDisabled(true);
        clearArchiveResults();
        if (archiveResultsElement) {
          archiveResultsElement.setAttribute('aria-busy', 'true');
        }
        const sourceLabel = getArchiveSourceLabel(targetSource);
        setArchiveStatus(`Loading recent ${sourceLabel} games…`, { state: 'loading' });
        try {
          const games = targetSource === ARCHIVE_SEARCH_SOURCES.LICHESS
            ? await fetchLichessGames(username, { signal })
            : await fetchChessComGames(username, { signal });
          if (archiveSearchToken !== requestToken) {
            return;
          }
          archiveSearchAbortController = null;
          if (!Array.isArray(games) || !games.length) {
            clearArchiveResults();
            setArchiveStatus(`No recent ${sourceLabel} games found for ${describeArchiveUsername(username)}.`, { state: 'empty' });
            return;
          }
          renderArchiveResults(games);
          const count = archiveSearchEntries.length;
          const descriptor = count === 1 ? 'game' : 'games';
          setArchiveStatus(`Loaded ${count} ${descriptor} from ${sourceLabel} for ${describeArchiveUsername(username)}.`, { state: 'success' });
        } catch (error) {
          if (isAbortError(error)) {
            return;
          }
          if (archiveSearchToken !== requestToken) {
            return;
          }
          archiveSearchAbortController = null;
          clearArchiveResults();
          const message = buildArchiveErrorMessage(targetSource, error, username);
          setArchiveStatus(message, { state: 'error' });
        } finally {
          setArchiveButtonsDisabled(false);
          if (archiveResultsElement) {
            archiveResultsElement.removeAttribute('aria-busy');
          }
        }
      }

      function handleArchiveResultSelection(entry) {
        if (!entry || typeof entry.pgn !== 'string' || !entry.pgn.trim().length) {
          showInputModalError('Unable to load the selected game.');
          return;
        }
        clearInputModalError();
        const result = importPositionFromText(entry.pgn);
        if (!result || result.success !== true) {
          const message = result && typeof result.error === 'string' ? result.error : 'Unable to load the selected game.';
          showInputModalError(message);
          return;
        }
        closeInputModal();
      }

      function initializeArchiveSearch() {
        if (archiveStatusElement) {
          setArchiveStatus(DEFAULT_ARCHIVE_STATUS_MESSAGE, { state: 'idle' });
        }
        if (archiveResultsElement) {
          archiveResultsElement.hidden = archiveSearchEntries.length === 0;
        }
        if (archiveSearchSection) {
          archiveSearchSection.setAttribute('data-has-results', archiveSearchEntries.length ? 'true' : 'false');
        }
      }

      function openInputModal(presetText = '') {
        if (!inputModalElement) return;
        lastFocusedElementBeforeModal = document.activeElement && typeof document.activeElement.focus === 'function'
          ? document.activeElement
          : null;
        inputModalElement.hidden = false;
        inputModalElement.setAttribute('aria-hidden', 'false');
        clearInputModalError();
        if (archiveStatusElement && (!archiveStatusElement.textContent || !archiveStatusElement.textContent.trim().length)) {
          setArchiveStatus(DEFAULT_ARCHIVE_STATUS_MESSAGE, { state: 'idle' });
        }
        if (archiveResultsElement) {
          archiveResultsElement.hidden = archiveSearchEntries.length === 0;
        }
        if (inputModalTextarea) {
          inputModalTextarea.value = typeof presetText === 'string' ? presetText : '';
          requestAnimationFrame(() => {
            inputModalTextarea.focus();
            inputModalTextarea.select();
          });
        }
      }

      function closeInputModal(options = {}) {
        if (!inputModalElement) return;
        const { restoreFocus = true } = options || {};
        if (archiveSearchAbortController && typeof archiveSearchAbortController.abort === 'function') {
          archiveSearchAbortController.abort();
        }
        archiveSearchAbortController = null;
        archiveSearchToken += 1;
        setArchiveButtonsDisabled(false);
        if (archiveResultsElement) {
          archiveResultsElement.removeAttribute('aria-busy');
        }
        inputModalElement.hidden = true;
        inputModalElement.setAttribute('aria-hidden', 'true');
        if (inputModalTextarea) {
          inputModalTextarea.value = '';
        }
        clearInputModalError();
        if (restoreFocus && lastFocusedElementBeforeModal && typeof lastFocusedElementBeforeModal.focus === 'function') {
          lastFocusedElementBeforeModal.focus();
        }
        lastFocusedElementBeforeModal = null;
      }

      function handleInputModalSubmit() {
        if (!inputModalTextarea) return;
        const rawInput = inputModalTextarea.value;
        const result = importPositionFromText(rawInput);
        if (!result || result.success !== true) {
          const message = result && typeof result.error === 'string' ? result.error : 'Invalid FEN or PGN.';
          showInputModalError(message);
          return;
        }
        closeInputModal();
      }

      function formatEvaluationLabel(probability) {
        return `Win chance ${formatWinProbability(probability)}`;
      }

      function deriveWhiteWinProbability(entry) {
        if (!entry) {
          return 0.5;
        }
        if (typeof entry.whiteWinProbability === 'number' && !Number.isNaN(entry.whiteWinProbability)) {
          return clampProbability(entry.whiteWinProbability);
        }
        if (entry.type === 'mate' && entry.winningSide) {
          return entry.winningSide === 'white' ? 1 : 0;
        }
        if (typeof entry.cp === 'number' && !Number.isNaN(entry.cp)) {
          return calculateWhiteWinProbabilityFromCp(entry.cp);
        }
        if (typeof entry.value === 'number' && !Number.isNaN(entry.value)) {
          return calculateWhiteWinProbabilityFromCp(entry.value);
        }
        return 0.5;
      }

      function updateEvaluationDisplay(entry) {
        if (!entry) {
          setEvaluationText('Win chance --', 0.5);
          return;
        }
        const probability = deriveWhiteWinProbability(entry);
        setEvaluationText(formatEvaluationLabel(probability), probability);
      }
      let backgroundEngine = null;
      let backgroundEngineReady = false;
      let backgroundEvaluationQueue = [];
      let backgroundCurrentTask = null;
      let backgroundPendingStart = false;
      let backgroundLastScore = null;
      let backgroundEvaluationToken = 0;
      let backgroundEvaluationCompleted = 0;
      let backgroundEvaluationTotal = 0;
      let replayMode = false;
      let replayTargetDepth = engineConfig.depth;
      let replayPendingIndex = null;
      let replayAdvanceScheduled = false;
      let replayTimer = null;
      let pendingReplayStart = null;
      let lastImportWasPgn = false;
      function ensureTimelineCapacity(size) {
        const target = Math.max(0, Math.floor(size));
        let extended = false;
        while (evaluationTimeline.length < target) {
          evaluationTimeline.push(null);
          extended = true;
        }
        return extended;
      }

      function clearEvaluationTimeline(initialSize = 1) {
        const size = Math.max(1, Math.floor(initialSize));
        evaluationTimeline = new Array(size).fill(null);
        scheduleEvaluationNavigationRender();
      }

      function resetBackgroundEvaluationProgress() {
        backgroundEvaluationCompleted = 0;
        backgroundEvaluationTotal = 0;
        updateEvaluationProgressLabel();
      }

      function updateEvaluationProgressLabel() {
        // Intentionally left blank – the probability graph no longer shows textual status updates.
      }

      // Logistic scale matching the Lichess win probability model for centipawn scores.
      const LICHESS_WIN_PROBABILITY_SCALE = 0.00368208;

      function capitalizeWord(word) {
        if (typeof word !== 'string' || !word.length) return '';
        return word.charAt(0).toUpperCase() + word.slice(1);
      }

      function clampProbability(probability) {
        if (typeof probability !== 'number' || Number.isNaN(probability)) {
          return 0.5;
        }
        return Math.max(0, Math.min(1, probability));
      }

      function calculateWhiteWinProbabilityFromCp(cp) {
        if (typeof cp !== 'number' || Number.isNaN(cp)) {
          return 0.5;
        }
        const limited = Math.max(-2000, Math.min(2000, cp));
        const exponent = -LICHESS_WIN_PROBABILITY_SCALE * limited;
        const probability = 1 / (1 + Math.exp(exponent));
        return clampProbability(probability);
      }

      function formatWinProbability(probability) {
        const clamped = clampProbability(probability);
        const percentValue = Math.round(clamped * 1000) / 10;
        const hasFraction = Math.abs(percentValue - Math.round(percentValue)) > 0.001;
        const formatted = hasFraction ? percentValue.toFixed(1) : Math.round(percentValue).toString();
        return `${formatted}%`;
      }

      function computeAdvantageRatio(entry) {
        if (!entry) {
          return Math.max(0, Math.min(1, lastAdvantageRatio));
        }

        if (typeof entry.whiteWinProbability === 'number' && !Number.isNaN(entry.whiteWinProbability)) {
          return clampProbability(entry.whiteWinProbability);
        }

        if (entry.type === 'mate') {
          if (entry.winningSide === 'white') return 1;
          if (entry.winningSide === 'black') return 0;
          return 0.5;
        }

        if (typeof entry.value === 'number' && !Number.isNaN(entry.value)) {
          const bounded = Math.max(-2000, Math.min(2000, entry.value));
          return (bounded + 2000) / 4000;
        }

        return Math.max(0, Math.min(1, lastAdvantageRatio));
      }

      function updateAdvantageBar(entry, { neutral = false, message = null } = {}) {
        if (!advantageBarElement || !advantageTrackElement) return;

        let ratio = neutral ? 0.5 : Math.max(0, Math.min(1, lastAdvantageRatio));
        let summary = message || (neutral ? 'Awaiting evaluation' : (advantageStatusElement ? advantageStatusElement.textContent || '' : ''));

        if (entry) {
          ratio = computeAdvantageRatio(entry);
          const fallback = entry.winningSide ? `${capitalizeWord(entry.winningSide)} edge` : 'Balanced';
          summary = entry.shortText || entry.text || fallback;
        } else if (!entry && !message && neutral) {
          summary = 'Awaiting evaluation';
        }

        ratio = Math.max(0, Math.min(1, ratio));
        lastAdvantageRatio = ratio;

        const whitePercentLabel = formatWinProbability(ratio);
        const blackPercentLabel = formatWinProbability(1 - ratio);

        advantageTrackElement.style.setProperty('--white-ratio', `${(ratio * 100).toFixed(2)}%`);
        if (advantageWhiteElement) {
          advantageWhiteElement.textContent = whitePercentLabel;
        }
        if (advantageBlackElement) {
          advantageBlackElement.textContent = blackPercentLabel;
        }
        if (advantageStatusElement) {
          advantageStatusElement.textContent = summary || '';
        }
        if (advantageBarElement) {
          const isWhiteFavored = ratio >= 0.53;
          const isBlackFavored = ratio <= 0.47;
          advantageBarElement.classList.toggle('is-white-favored', isWhiteFavored);
          advantageBarElement.classList.toggle('is-black-favored', isBlackFavored);
          advantageBarElement.classList.toggle('is-balanced', !isWhiteFavored && !isBlackFavored);
          if (evaluationElement) {
            evaluationElement.classList.toggle('is-white-favored', isWhiteFavored);
            evaluationElement.classList.toggle('is-black-favored', isBlackFavored);
            evaluationElement.classList.toggle('is-balanced', !isWhiteFavored && !isBlackFavored);
          }
        }
      }

      function setAdvantageBarLoading(isLoading, { reset = true } = {}) {
        if (!advantageBarElement) return;
        advantageBarElement.classList.toggle('is-loading', !!isLoading);
        advantageBarElement.setAttribute('aria-busy', isLoading ? 'true' : 'false');
        if (isLoading) {
          updateAdvantageBar(null, { neutral: !!reset, message: 'Analyzing...' });
        }
      }

      function describeCentipawnAdvantage(cp) {
        const abs = Math.abs(cp);
        if (abs < 15) {
          return { leadingSide: null, summary: 'Level position', category: 'level' };
        }
        const side = cp > 0 ? 'white' : 'black';
        if (abs < 50) {
          return { leadingSide: side, summary: 'has a microscopic edge', category: 'tiny' };
        }
        if (abs < 120) {
          return { leadingSide: side, summary: 'has a small advantage', category: 'small' };
        }
        if (abs < 250) {
          return { leadingSide: side, summary: 'is better', category: 'better' };
        }
        if (abs < 400) {
          return { leadingSide: side, summary: 'is winning', category: 'winning' };
        }
        return { leadingSide: side, summary: 'is completely winning', category: 'crushing' };
      }

      function buildEvaluationEntryFromScore({ cp = null, mate = null, turn = 'w' }) {
        const activeTurn = turn === 'b' ? 'b' : 'w';

        if (typeof mate === 'number' && !Number.isNaN(mate)) {
          const mateValueRaw = mate;
          const isNegativeZero = Object.is(mateValueRaw, -0);
          const rawSign = mateValueRaw > 0 ? 1 : mateValueRaw < 0 ? -1 : (isNegativeZero ? -1 : 1);
          let mateValue = mateValueRaw;
          if (activeTurn === 'b') {
            mateValue = -mateValue;
          }

          if (mateValue === 0) {
            const winningSide = activeTurn === 'w' ? 'black' : 'white';
            const gaugeSign = winningSide === 'white' ? 1 : -1;
            const label = `${capitalizeWord(winningSide)} has delivered checkmate · 100% win chance`;
            const whiteWinProbability = winningSide === 'white' ? 1 : 0;
            return {
              value: gaugeSign >= 0 ? 2000 : -2000,
              text: label,
              shortText: 'Mate',
              type: 'mate',
              matePly: 0,
              winningSide,
              whiteWinProbability,
              raw: { mate: mateValueRaw, turn: activeTurn }
            };
          }

          const winningSide = mateValue > 0 ? 'white' : 'black';
          const absMoves = Math.abs(mateValue);
          const label = `${capitalizeWord(winningSide)} mates in ${absMoves} · 100% win chance`;
          const shortText = mateValue > 0 ? `M${absMoves}` : `M-${absMoves}`;
          const whiteWinProbability = winningSide === 'white' ? 1 : 0;
          return {
            value: mateValue > 0 ? 2000 : -2000,
            text: label,
            shortText,
            type: 'mate',
            matePly: absMoves,
            winningSide,
            whiteWinProbability,
            raw: { mate: mateValueRaw, turn: activeTurn }
          };
        }

        if (typeof cp === 'number' && !Number.isNaN(cp)) {
          let cpValue = cp;
          if (activeTurn === 'b') {
            cpValue = -cpValue;
          }
          const normalized = Math.max(-2000, Math.min(2000, cpValue));
          const descriptor = describeCentipawnAdvantage(cpValue);
          const prefix = cpValue > 0 ? '+' : cpValue < 0 ? '' : '';
          const cpDisplay = `${prefix}${(cpValue / 100).toFixed(2)}`;
          const cpLabel = `${cpDisplay} pawns`;
          const whiteWinProbability = calculateWhiteWinProbabilityFromCp(cpValue);
          const blackWinProbability = 1 - whiteWinProbability;
          const favoredSide = descriptor.leadingSide;
          const favoredProbability = favoredSide === 'white'
            ? whiteWinProbability
            : favoredSide === 'black'
              ? blackWinProbability
              : whiteWinProbability;
          const probabilitySummary = favoredSide
            ? `${formatWinProbability(favoredProbability)} win chance`
            : `Win chances W ${formatWinProbability(whiteWinProbability)} · B ${formatWinProbability(blackWinProbability)}`;
          const summary = descriptor.leadingSide
            ? `${capitalizeWord(descriptor.leadingSide)} ${descriptor.summary}`
            : descriptor.summary;
          return {
            value: normalized,
            text: `${summary} · ${probabilitySummary} (${cpLabel})`,
            shortText: `W ${formatWinProbability(whiteWinProbability)} · ${cpDisplay}`,
            type: 'cp',
            cp: cpValue,
            winningSide: descriptor.leadingSide,
            advantageCategory: descriptor.category,
            whiteWinProbability,
            raw: { cp, turn: activeTurn }
          };
        }

        return null;
      }

      function cancelBackgroundEvaluation() {
        backgroundEvaluationToken += 1;
        const hadActiveTask = !!backgroundCurrentTask;
        backgroundEvaluationQueue = [];
        backgroundCurrentTask = null;
        backgroundLastScore = null;
        resetBackgroundEvaluationProgress();
        if (backgroundEngine && hadActiveTask) {
          backgroundPendingStart = true;
          backgroundEngine.postMessage('stop');
        } else {
          backgroundPendingStart = false;
        }
      }

      function processBackgroundQueue() {
        if (!backgroundEngine || !backgroundEngineReady || backgroundPendingStart || backgroundCurrentTask) return;
        const nextTask = backgroundEvaluationQueue.shift();
        if (!nextTask || nextTask.token !== backgroundEvaluationToken) {
          if (!backgroundEvaluationQueue.length && backgroundEvaluationCompleted >= backgroundEvaluationTotal && backgroundEvaluationTotal > 0) {
            updateEvaluationProgressLabel();
          }
          return;
        }
        backgroundCurrentTask = nextTask;
        backgroundLastScore = null;
        const normalizedFen = normalizeFenTurn(nextTask.fen, nextTask.turn);
        const safeFen = sanitizeFenForStockfish(normalizedFen);
        backgroundEngine.postMessage('setoption name MultiPV value 1');
        backgroundEngine.postMessage('ucinewgame');
        backgroundEngine.postMessage(`position fen ${safeFen}`);
        const depth = typeof nextTask.depth === 'number' ? nextTask.depth : engineConfig.depth;
        backgroundEngine.postMessage(`go depth ${depth}`);
      }

      function queueBackgroundEvaluationTasks(tasks) {
        if (!Array.isArray(tasks) || !tasks.length) {
          cancelBackgroundEvaluation();
          return;
        }
        if (!engineReady) {
          cancelBackgroundEvaluation();
          scheduleEngineAutostart();
          return;
        }
        backgroundEvaluationToken += 1;
        const token = backgroundEvaluationToken;
        backgroundEvaluationQueue = tasks.map(task => ({ ...task, token }));
        backgroundCurrentTask = null;
        backgroundLastScore = null;
        backgroundEvaluationCompleted = 0;
        backgroundEvaluationTotal = tasks.length;
        updateEvaluationProgressLabel();
        if (!backgroundEngine) {
          initBackgroundEngine();
        }
        if (backgroundEngineReady && !backgroundPendingStart) {
          processBackgroundQueue();
        }
      }

      function shutdownBackgroundEngine() {
        cancelBackgroundEvaluation();
        backgroundPendingStart = false;
        backgroundEngineReady = false;
        backgroundCurrentTask = null;
        backgroundLastScore = null;
        if (backgroundEngine) {
          try {
            backgroundEngine.postMessage('stop');
          } catch (error) {
            console.warn('Failed to stop background engine', error);
          }
          try {
            backgroundEngine.terminate();
          } catch (terminateError) {
            console.warn('Failed to terminate background engine', terminateError);
          }
        }
        backgroundEngine = null;
      }

      function restartBackgroundEngine() {
        shutdownBackgroundEngine();
        if (!engine) {
          return;
        }
        initBackgroundEngine();
      }

      function initBackgroundEngine() {
        if (backgroundEngine) return;
        backgroundEngineReady = false;
        backgroundPendingStart = false;
        backgroundCurrentTask = null;
        backgroundLastScore = null;
        try {
          backgroundEngine = createStockfishWorker();
        } catch (error) {
          const friendlyMessage = buildWorkerInitializationErrorMessage(error, { stage: 'load' });
          console.error('Failed to initialize background Stockfish worker', friendlyMessage, error);
          backgroundEngine = null;
          return;
        }
        backgroundEngine.addEventListener('error', event => {
          const message = event && event.message ? event.message : 'Unknown error';
          const errorForMessage = event && event.error instanceof Error
            ? event.error
            : new Error(message || 'Unknown background Stockfish worker error');
          const errorStage = determineWorkerErrorStage(event, message);
          const friendlyMessage = buildWorkerInitializationErrorMessage(errorForMessage, { stage: errorStage });
          if (errorStage === 'runtime' && isMemoryAccessOutOfBoundsError(errorForMessage)) {
            applyEngineMemoryFallback();
          }
          console.error('Background Stockfish worker error', friendlyMessage, event);
        });
        backgroundEngine.onmessage = e => {
          const line = String(e.data).trim();

          if (line === 'uciok') {
            backgroundEngine.postMessage(`setoption name Threads value ${engineConfig.threads}`);
            const backgroundHash = computeBackgroundHashBudget(engineConfig.hash);
            if (backgroundHash !== null) {
              backgroundEngine.postMessage(`setoption name Hash value ${backgroundHash}`);
            }
            backgroundEngine.postMessage('isready');
            return;
          }

          if (line === 'readyok') {
            backgroundEngineReady = true;
            processBackgroundQueue();
            return;
          }

          if (!line.length) return;

          if (backgroundPendingStart) {
            if (line.startsWith('bestmove')) {
              backgroundPendingStart = false;
              backgroundLastScore = null;
              processBackgroundQueue();
            }
            return;
          }

          if (line.startsWith('info')) {
            if (!backgroundCurrentTask || backgroundCurrentTask.token !== backgroundEvaluationToken) {
              return;
            }
            if (!line.includes('score')) return;

            const cpMatch = line.match(/score cp (-?\d+)/);
            const mateMatch = line.match(/score mate (-?\d+)/);
            if (mateMatch) {
              backgroundLastScore = { mate: parseInt(mateMatch[1], 10), turn: backgroundCurrentTask.turn };
            } else if (cpMatch) {
              backgroundLastScore = { cp: parseInt(cpMatch[1], 10), turn: backgroundCurrentTask.turn };
            }
            return;
          }

          if (!line.startsWith('bestmove')) return;

          if (!backgroundCurrentTask) {
            processBackgroundQueue();
            return;
          }

          if (backgroundCurrentTask.token !== backgroundEvaluationToken) {
            backgroundCurrentTask = null;
            backgroundLastScore = null;
            processBackgroundQueue();
            return;
          }

          const currentTask = backgroundCurrentTask;
          backgroundCurrentTask = null;
          let entry = null;
          if (backgroundLastScore) {
            entry = buildEvaluationEntryFromScore({ cp: backgroundLastScore.cp ?? null, mate: backgroundLastScore.mate ?? null, turn: backgroundLastScore.turn || currentTask.turn });
          }
          if (!entry) {
            entry = { value: 0, text: 'N/A' };
          }
          setTimelineEntry(currentTask.index, entry);
          backgroundEvaluationCompleted = Math.min(backgroundEvaluationCompleted + 1, backgroundEvaluationTotal);
          if (currentTask.index === navigationIndex) {
            applyStoredEvaluationIfAvailable();
          }
          updateEvaluationProgressLabel();
          backgroundLastScore = null;
          processBackgroundQueue();
        };
        backgroundEngine.postMessage('uci');
      }

      function buildBackgroundTasksForGame(depthOverride = engineConfig.depth) {
        const tasks = [];
        const evaluationGame = new Chess();
        if (!evaluationGame.load(baseFen)) {
          evaluationGame.reset();
        }
        const evaluationDepth = typeof depthOverride === 'number' && depthOverride > 0
          ? depthOverride
          : engineConfig.depth;
        tasks.push({ index: 0, fen: evaluationGame.fen(), turn: evaluationGame.turn(), depth: evaluationDepth });
        for (let i = 0; i < moveHistory.length; i += 1) {
          const entry = moveHistory[i];
          if (!entry) continue;
          const moveConfig = { from: entry.from, to: entry.to };
          if (entry.promotion) {
            moveConfig.promotion = entry.promotion;
          }
          const applied = evaluationGame.move(moveConfig);
          if (!applied) break;
          tasks.push({ index: i + 1, fen: evaluationGame.fen(), turn: evaluationGame.turn(), depth: evaluationDepth });
        }
        return tasks;
      }

      function scheduleFullGameEvaluation() {
        const tasks = buildBackgroundTasksForGame();
        queueBackgroundEvaluationTasks(tasks);
      }

      function scheduleProbabilityEvaluation(depth = engineConfig.depth) {
        const tasks = buildBackgroundTasksForGame(depth);
        queueBackgroundEvaluationTasks(tasks);
      }

      function setTimelineEntry(index, entry) {
        if (typeof index !== 'number' || index < 0) return;
        const extended = ensureTimelineCapacity(index + 1);
        if (entry && typeof entry === 'object') {
          const normalizedValue = typeof entry.value === 'number' ? clampEvaluationValue(entry.value) : null;
          evaluationTimeline[index] = { ...entry, value: normalizedValue };
        } else {
          evaluationTimeline[index] = entry;
        }
        if (extended || entry !== undefined) {
          scheduleEvaluationNavigationRender();
        }
      }

      function getTimelineEntry(index) {
        if (typeof index !== 'number' || index < 0 || index >= evaluationTimeline.length) {
          return null;
        }
        return evaluationTimeline[index];
      }

      function clampEvaluationValue(cp) {
        if (typeof cp !== 'number' || Number.isNaN(cp)) return 0;
        return Math.max(-2000, Math.min(2000, cp));
      }

      function renderEvaluationNavigation() {
        if (!evaluationNavElement) return;
        const totalSegments = Math.max(1, evaluationTimeline.length);
        const bounds = evaluationNavElement.getBoundingClientRect();
        let width = Math.round(evaluationNavElement.clientWidth || bounds.width);
        let height = Math.round(evaluationNavElement.clientHeight || bounds.height);
        if (!width || !height) {
          evaluationNavNeedsVisibleRender = true;
          return;
        }
        evaluationNavNeedsVisibleRender = false;
        evaluationNavElement.innerHTML = '';

        const segmentWidth = totalSegments > 0 ? width / totalSegments : width;
        const halfSegment = segmentWidth / 2;
        const rawPoints = [];

        for (let i = 0; i < totalSegments; i += 1) {
          const entry = i < evaluationTimeline.length ? evaluationTimeline[i] : null;
          let probability = 0.5;
          if (entry && typeof entry.whiteWinProbability === 'number' && !Number.isNaN(entry.whiteWinProbability)) {
            probability = Math.max(0, Math.min(1, entry.whiteWinProbability));
          } else if (entry) {
            probability = Math.max(0, Math.min(1, computeAdvantageRatio(entry)));
          }
          const centerX = totalSegments > 0 ? (i + 0.5) * segmentWidth : width / 2;
          const x = Math.max(halfSegment, Math.min(width - halfSegment, centerX));
          const y = height - probability * height;
          rawPoints.push({ x, y, probability, entry });
        }

        const pathPoints = rawPoints.length === 1
          ? [{ x: 0, y: rawPoints[0].y }, { x: width, y: rawPoints[0].y }]
          : rawPoints;
        const areaPoints = rawPoints.length
          ? [{ x: 0, y: rawPoints[0].y }, ...rawPoints, { x: width, y: rawPoints[rawPoints.length - 1].y }]
          : [];

        const toCommandString = pts => pts.map((pt, idx) => {
          const command = idx === 0 ? 'M' : 'L';
          return `${command}${pt.x.toFixed(2)},${pt.y.toFixed(2)}`;
        }).join(' ');

        const toAreaCommand = pts => {
          if (!pts.length) return '';
          const commands = [`M${pts[0].x.toFixed(2)},${height.toFixed(2)}`, `L${pts[0].x.toFixed(2)},${pts[0].y.toFixed(2)}`];
          for (let i = 1; i < pts.length; i += 1) {
            commands.push(`L${pts[i].x.toFixed(2)},${pts[i].y.toFixed(2)}`);
          }
          commands.push(`L${pts[pts.length - 1].x.toFixed(2)},${height.toFixed(2)}`);
          commands.push('Z');
          return commands.join(' ');
        };

        const lineCommands = pathPoints.length ? toCommandString(pathPoints) : '';
        const areaCommand = areaPoints.length ? toAreaCommand(areaPoints) : '';
        const baselineY = height - 0.5 * height;

        const svgNS = 'http://www.w3.org/2000/svg';
        const svg = document.createElementNS(svgNS, 'svg');
        svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
        svg.setAttribute('preserveAspectRatio', 'none');
        svg.setAttribute('width', width.toString());
        svg.setAttribute('height', height.toString());
        svg.classList.add('evaluation-nav__graph');

        if (areaCommand) {
          const area = document.createElementNS(svgNS, 'path');
          area.setAttribute('d', areaCommand);
          area.setAttribute('class', 'evaluation-nav__area');
          svg.appendChild(area);
        }

        const baseline = document.createElementNS(svgNS, 'line');
        baseline.setAttribute('x1', '0');
        baseline.setAttribute('y1', baselineY.toFixed(2));
        baseline.setAttribute('x2', width.toFixed(2));
        baseline.setAttribute('y2', baselineY.toFixed(2));
        baseline.setAttribute('class', 'evaluation-nav__baseline');
        svg.appendChild(baseline);

        if (lineCommands) {
          const linePath = document.createElementNS(svgNS, 'path');
          linePath.setAttribute('d', lineCommands);
          linePath.setAttribute('class', 'evaluation-nav__line');
          svg.appendChild(linePath);

          const currentPoint = rawPoints[Math.min(navigationIndex, rawPoints.length - 1)];
          if (currentPoint) {
            const marker = document.createElementNS(svgNS, 'circle');
            marker.setAttribute('cx', currentPoint.x.toFixed(2));
            marker.setAttribute('cy', currentPoint.y.toFixed(2));
            marker.setAttribute('r', '4');
            marker.setAttribute('class', 'evaluation-nav__marker');
            svg.appendChild(marker);
          }
        }

        const overlay = document.createElement('div');
        overlay.className = 'evaluation-nav__overlay';
        overlay.style.display = 'grid';
        overlay.style.gridTemplateColumns = `repeat(${totalSegments}, 1fr)`;
        overlay.style.alignItems = 'stretch';

        for (let i = 0; i < totalSegments; i += 1) {
          const entry = i < evaluationTimeline.length ? evaluationTimeline[i] : null;
          const segment = document.createElement('button');
          segment.type = 'button';
          segment.className = 'evaluation-nav__segment';
          segment.tabIndex = 0;
          segment.setAttribute('role', 'button');
          segment.dataset.index = String(i);
          segment.classList.toggle('is-current', i === navigationIndex);
          if (i === navigationIndex) {
            segment.setAttribute('aria-current', 'true');
          } else {
            segment.removeAttribute('aria-current');
          }
          const probability = entry && typeof entry.whiteWinProbability === 'number'
            ? Math.max(0, Math.min(1, entry.whiteWinProbability))
            : rawPoints[i] && typeof rawPoints[i].probability === 'number'
              ? Math.max(0, Math.min(1, rawPoints[i].probability))
              : 0.5;
          const probabilityPercent = formatWinProbability(probability);
          segment.title = `Ply ${i}: White win probability ${probabilityPercent}`;
          segment.setAttribute('aria-label', `Ply ${i} white win probability ${probabilityPercent}`);
          segment.dataset.probability = probability.toFixed(4);
          overlay.appendChild(segment);
        }

        evaluationNavElement.appendChild(svg);
        evaluationNavElement.appendChild(overlay);
      }

      function scheduleEvaluationNavigationRender() {
        if (!evaluationNavElement) return;
        requestAnimationFrame(() => {
          renderEvaluationNavigation();
          if (evaluationNavNeedsVisibleRender) {
            requestAnimationFrame(() => {
              renderEvaluationNavigation();
            });
          }
        });
      }

      const evaluationNavResizeObserver = typeof ResizeObserver === 'function' && evaluationNavElement
        ? new ResizeObserver(entries => {
            for (const entry of entries) {
              if (entry.contentRect.width > 0 && entry.contentRect.height > 0) {
                renderEvaluationNavigation();
                evaluationNavNeedsVisibleRender = false;
                break;
              }
            }
          })
        : null;
      if (evaluationNavResizeObserver && evaluationNavElement) {
        evaluationNavResizeObserver.observe(evaluationNavElement);
      }

      function applyEvaluationEntry(entry) {
        if (!entry) return;
        updateEvaluationDisplay(entry);
        setTimelineEntry(navigationIndex, entry);
        setAdvantageBarLoading(false);
        updateAdvantageBar(entry);
      }

      function applyStoredEvaluationIfAvailable() {
        const entry = getTimelineEntry(navigationIndex);
        if (entry) {
          updateEvaluationDisplay(entry);
          setAdvantageBarLoading(false);
          updateAdvantageBar(entry);
        } else {
          setEvaluationText('Win chance --', 0.5);
          setAdvantageBarLoading(false);
          updateAdvantageBar(null, { neutral: true, message: 'Awaiting evaluation' });
        }
      }

      function syncEvalBarWidth() {
        if (!advantageBarElement) return;
        const container = boardEl && typeof boardEl.closest === 'function'
          ? boardEl.closest('.board-container')
          : null;
        const refEl = container && container.length ? container.get(0) : null;
        if (!refEl) return;
        const bounds = refEl.getBoundingClientRect();
        if (!bounds || !bounds.width) return;
        advantageBarElement.style.maxWidth = `${Math.round(bounds.width)}px`;
      }

      function getFenTurn(fen) {
        if (typeof fen !== 'string') return null;
        const trimmed = fen.trim();
        if (!trimmed.length) return null;
        const parts = trimmed.split(/\s+/);
        if (parts.length < 2) return null;
        return parts[1] === 'b' ? 'b' : 'w';
      }

      function normalizeFenTurn(fen, turn) {
        if (typeof fen !== 'string') return fen;
        const trimmed = fen.trim();
        if (!trimmed.length) return fen;
        const parts = trimmed.split(/\s+/);
        if (parts.length < 2) return trimmed;
        parts[1] = turn === 'b' ? 'b' : 'w';
        return parts.join(' ');
      }

      function sanitizeFenForStockfish(fen) {
        try {
          const g = new Chess();
          if (!g.load(fen)) return fen;

          const parts = fen.trim().split(/\s+/);
          if (parts.length < 4) return fen;

          const ep = parts[3];
          if (ep === '-') return fen;

          const hasEp = g.moves({ verbose: true }).some(m => m.flags && m.flags.includes('e'));
          if (!hasEp) {
            parts[3] = '-';
            return parts.join(' ');
          }
          return fen;
        } catch {
          return fen;
        }
      }

      function updateBestMoveDisplay() {
        if (!bestMoveVisible) {
          if (!pieceMovesMode) {
            clearHighlights();
          }
          return;
        }

        if (pieceMovesMode) {
          return;
        }

        if (currentBestMove && shouldHighlightBest) {
          visualize(currentBestMove);
        } else if (!currentBestMove) {
          clearHighlights();
        }
      }

      function updateNavigationButtons() {
        const hasFutureMove = navigationIndex < moveHistory.length;
        const prevDisabled = navigationIndex === 0 || pieceMovesMode || editMode || waitingForAutoBestMove;
        const nextDisabled = autoPlayPending || waitingForAutoBestMove || pieceMovesMode || editMode || (!hasFutureMove && !engineReady);
        $('#prev-button').prop('disabled', prevDisabled);
        $('#next-button').prop('disabled', nextDisabled);
      }

      function cancelReplayTimer() {
        if (replayTimer) {
          clearTimeout(replayTimer);
          replayTimer = null;
        }
      }

      function stopReplay() {
        replayMode = false;
        replayPendingIndex = null;
        replayAdvanceScheduled = false;
        cancelReplayTimer();
        pendingReplayStart = null;
        updateEvaluationProgressLabel();
      }

      function scheduleReplayAdvance() {
        if (!replayMode) return;
        if (replayAdvanceScheduled) return;
        replayAdvanceScheduled = true;
        cancelReplayTimer();
        replayTimer = setTimeout(() => {
          replayTimer = null;
          replayAdvanceScheduled = false;
          if (!replayMode) return;
          const nextIndex = navigationIndex + 1;
          if (nextIndex > moveHistory.length) {
            stopReplay();
            return;
          }
          rebuildPosition(nextIndex, {
            highlight: shouldHighlightBest && bestMoveVisible,
            revealBest: bestMoveVisible,
            depth: replayTargetDepth,
            replay: true
          });
        }, REPLAY_STEP_DELAY_MS);
      }

      function startReplayFromIndex(index = 0, depth = engineConfig.depth) {
        const clampedIndex = Math.max(0, Math.min(index, moveHistory.length));
        const resolvedDepth = typeof depth === 'number' && depth > 0 ? depth : engineConfig.depth;
        if (!engineReady || !engine) {
          replayMode = true;
          replayTargetDepth = Math.max(PGN_REPLAY_DEPTH, resolvedDepth);
          replayPendingIndex = clampedIndex;
          replayAdvanceScheduled = false;
          cancelReplayTimer();
          updateEvaluationProgressLabel();
          pendingReplayStart = { index: clampedIndex, depth: Math.max(PGN_REPLAY_DEPTH, resolvedDepth) };
          scheduleEngineAutostart();
          return;
        }
        pendingReplayStart = null;
        stopReplay();
        replayTargetDepth = Math.max(PGN_REPLAY_DEPTH, resolvedDepth);
        cancelReplayTimer();
        replayAdvanceScheduled = false;
        rebuildPosition(clampedIndex, {
          highlight: shouldHighlightBest && bestMoveVisible,
          revealBest: bestMoveVisible,
          depth: replayTargetDepth,
          replay: true
        });
      }

      function recordMove(move) {
        if (!move) return;
        lastImportWasPgn = false;
        releasePlayerSummaryLock();
        if (navigationIndex < moveHistory.length) {
          moveHistory = moveHistory.slice(0, navigationIndex);
          evaluationTimeline = evaluationTimeline.slice(0, navigationIndex + 1);
        }
        moveHistory.push({ from: move.from, to: move.to, promotion: move.promotion });
        navigationIndex = moveHistory.length;
        ensureTimelineCapacity(navigationIndex + 1);
        updateNavigationButtons();
        scheduleEvaluationNavigationRender();
        if (probabilityPanelVisible) {
          scheduleProbabilityEvaluation();
        }
        updatePlayerSummaryFromGame();
      }

      function resetHistory(newBaseFen = null) {
        moveHistory = [];
        navigationIndex = 0;
        autoPlayPending = false;
        waitingForAutoBestMove = false;
        autoMoveCandidate = null;
        autoPlayFen = null;
        autoPlayDepthSatisfied = false;
        stopReplay();
        cancelBackgroundEvaluation();
        if (autoPlayDelayTimer) {
          clearTimeout(autoPlayDelayTimer);
          autoPlayDelayTimer = null;
        }
        invalidateAnalysisCache();
        updateLastObservedFen(game.fen());
        if (typeof newBaseFen === 'string' && newBaseFen.length) {
          baseFen = newBaseFen;
        }
        clearEvaluationTimeline(1);
        setEvaluationText('Win chance --', 0.5);
        currentBestMove = null;
        latestAnalysisFen = null;
        setAdvantageBarLoading(false);
        updateAdvantageBar(null, { neutral: true, message: 'Awaiting evaluation' });
        updateBestMoveDisplay();
        updateNavigationButtons();
        scheduleEvaluationNavigationRender();
        if (probabilityPanelVisible) {
          scheduleProbabilityEvaluation();
        }
      }

      function rebuildPosition(targetIndex, analysisOptions = null) {
        const clamped = Math.max(0, Math.min(targetIndex, moveHistory.length));
        const loaded = game.load(baseFen);
        if (!loaded) {
          game.reset();
          baseFen = game.fen();
        }
        for (let i = 0; i < clamped; i += 1) {
          const entry = moveHistory[i];
          if (!entry) continue;
          const move = game.move({ from: entry.from, to: entry.to, promotion: entry.promotion || 'q' });
          if (!move) break;
        }
        invalidateAnalysisCache();
        updateLastObservedFen(game.fen());
        navigationIndex = clamped;
        if (pieceMovesMode) {
          pieceMovesMode = false;
          freezeMode = false;
          syncPieceMovesButton();
        }
        moveSourceSquare = null;
        selectedSquare = null;
        updateNavigationButtons();
        renderBoard();
        updateStatus();
        applyStoredEvaluationIfAvailable();
        scheduleEvaluationNavigationRender();
        const requestOptions = analysisOptions || {
          highlight: shouldHighlightBest && bestMoveVisible,
          revealBest: bestMoveVisible
        };
        requestAnalysis(requestOptions);
        updateEvaluationProgressLabel();
      }

      function applyAutoMove(uciMove) {
        if (!uciMove || uciMove === '(none)') {
          return;
        }
        const from = uciMove.slice(0, 2);
        const to = uciMove.slice(2, 4);
        const promotion = uciMove.length > 4 ? uciMove.slice(4, 5) : undefined;
        const move = game.move({ from, to, promotion });
        if (move) {
          playMoveSound(move);
          moveSourceSquare = null;
          selectedSquare = null;
          recordMove(move);
          renderBoard();
          updateStatus();
          requestAnalysis({ highlight: shouldHighlightBest && bestMoveVisible, revealBest: bestMoveVisible });
        }
      }

  function clearSelectionHighlight() {
    boardEl.find('.highlight-selection').removeClass('highlight-selection');
  }

  function highlightSelection(square) {
    if (!square) return;
    boardEl.find(`.square-${square}`).addClass('highlight-selection');
  }

  function applySelectionHighlights() {
    clearSelectionHighlight();
    if (editMode) {
      if (editSelectionSource === 'board' && editSelectedSquare) {
        highlightSelection(editSelectedSquare);
      }
      return;
    }
    if (pieceMovesMode && selectedSquare) {
      highlightSelection(selectedSquare);
    } else if (!pieceMovesMode && moveSourceSquare) {
      highlightSelection(moveSourceSquare);
    }
  }

  function clearSpareSelectionHighlight() {
    $('.board-container .selected-spare-piece').removeClass('selected-spare-piece');
  }

  function applySpareSelection() {
    clearSpareSelectionHighlight();
    if (!editMode || editSelectionSource !== 'spare' || !editSelectedPiece) return;
    const pieceCode = `${editSelectedPiece.color}${editSelectedPiece.type.toUpperCase()}`;
    $(sparePiecesContainerSelector).find(sparePieceSelector).filter(`[data-piece='${pieceCode}']`).first().addClass('selected-spare-piece');
  }

  function clearEditSelection() {
    editSelectedPiece = null;
    editSelectedSquare = null;
    editSelectionSource = null;
    applySelectionHighlights();
    applySpareSelection();
  }

  function commitEditedBoardState() {
    lastImportWasPgn = false;
    resetHistory(game.fen());
    renderBoard();
    updateStatus();
    requestAnalysis({ highlight: shouldHighlightBest && bestMoveVisible, revealBest: bestMoveVisible });
  }

  function toggleEditingTurn() {
    if (!editMode) return;
    const fen = game.fen();
    if (typeof fen !== 'string' || !fen.length) return;
    const parts = fen.trim().split(/\s+/);
    if (parts.length < 2) return;
    parts[1] = parts[1] === 'w' ? 'b' : 'w';
    const updatedFen = parts.join(' ');
    const loaded = game.load(updatedFen);
    if (!loaded) return;
    commitEditedBoardState();
  }

  function clonePiece(piece) {
    if (!piece) return null;
    return { type: piece.type, color: piece.color };
  }

  function attemptPlacePiece(square, piece) {
    if (!square || !piece) {
      return { success: false, changed: false };
    }
    const existing = game.get(square);
    if (existing && existing.type === piece.type && existing.color === piece.color) {
      return { success: true, changed: false };
    }
    const backup = clonePiece(existing);
    if (existing) {
      game.remove(square);
    }
    const placed = game.put({ type: piece.type, color: piece.color }, square);
    if (!placed) {
      if (backup) {
        game.put(backup, square);
      }
      return { success: false, changed: false };
    }
    return { success: true, changed: true };
  }

  function removePieceAtSquare(square) {
    if (!square) return false;
    const existing = game.get(square);
    if (!existing) return false;
    const removed = game.remove(square);
    if (!removed) return false;
    commitEditedBoardState();
    return true;
  }

  function handleSparePieceClick(pieceCode) {
    if (!editMode || !pieceCode || pieceCode.length < 2) return;
    editSelectedPiece = { color: pieceCode[0], type: pieceCode[1].toLowerCase() };
    editSelectedSquare = null;
    editSelectionSource = 'spare';
    applySelectionHighlights();
    applySpareSelection();
  }

  function handleEditSquareClick(square) {
    if (!editMode) return;
    if (!square) return;

    const piece = game.get(square);

    if (!editSelectedPiece) {
      if (piece) {
        editSelectedPiece = { type: piece.type, color: piece.color };
        editSelectedSquare = square;
        editSelectionSource = 'board';
        applySelectionHighlights();
      }
      return;
    }

    if (editSelectionSource === 'spare') {
      const result = attemptPlacePiece(square, editSelectedPiece);
      if (!result.success) {
        applySelectionHighlights();
        applySpareSelection();
        return;
      }
      if (result.changed) {
        commitEditedBoardState();
      }
      return;
    }

    if (editSelectionSource === 'board') {
      const sourceSquare = editSelectedSquare;
      if (!sourceSquare) {
        clearEditSelection();
        return;
      }
      if (sourceSquare === square) {
        clearEditSelection();
        return;
      }

      const destinationBackup = clonePiece(piece);
      const removedSource = game.remove(sourceSquare);
      if (!removedSource) {
        applySelectionHighlights();
        return;
      }
      if (destinationBackup) {
        game.remove(square);
      }
      const movingPiece = { type: removedSource.type, color: removedSource.color };
      const placed = game.put(movingPiece, square);
      if (!placed) {
        game.put({ type: removedSource.type, color: removedSource.color }, sourceSquare);
        if (destinationBackup) {
          game.put(destinationBackup, square);
        }
        applySelectionHighlights();
        return;
      }
      clearEditSelection();
      commitEditedBoardState();
    }
  }

  function handleOutsideBoardClick(event) {
    if (!editMode) return;
    const $target = $(event.target);
    if ($target.closest('.board-container').length) return;
    if (editSelectionSource) {
      clearEditSelection();
    }
  }

  function handleSquareClick(square) {
    if (!square) return;
    if (editMode) {
      handleEditSquareClick(square);
      return;
    }

    if (pieceMovesMode) {
      selectedSquare = square;
      applySelectionHighlights();
      analyzeMoves();
      return;
    }

    if (freezeMode || game.game_over()) return;

    const piece = game.get(square);
    const turn = game.turn();

    if (!moveSourceSquare) {
      if (!piece || piece.color !== turn) return;
      moveSourceSquare = square;
      applySelectionHighlights();
      return;
    }

    if (moveSourceSquare === square) {
      moveSourceSquare = null;
      applySelectionHighlights();
      return;
    }

    clearHighlights();
    clearRatings();

    const move = game.move({ from: moveSourceSquare, to: square, promotion: 'q' });

    if (move) {
      playMoveSound(move);
      recordMove(move);
      moveSourceSquare = null;
      renderBoard();
      updateStatus();
      requestAnalysis({ highlight: shouldHighlightBest && bestMoveVisible, revealBest: bestMoveVisible });
    } else {
      if (piece && piece.color === turn) {
        moveSourceSquare = square;
      }
      applySelectionHighlights();
    }
  }

  function handleSquareDoubleClick(square) {
    if (!square) return;
    if (!editMode) return;
    const removed = removePieceAtSquare(square);
    if (removed) {
      clearEditSelection();
    }
  }

  function renderBoard() {
    const fen = game.fen();
    const needsRecreate = !board
      || lastBoardConfig.editMode !== editMode
      || lastBoardConfig.orientation !== orientation;

    if (needsRecreate) {
      lastBoardConfig = { editMode, orientation };
      if (board) {
        board.destroy();
      }
      board = Chessboard('board', {
        position: fen,
        draggable: editMode,
        sparePieces: editMode,
        orientation,
        onDragStart,
        onDrop,
        onSnapEnd,
        pieceTheme: p => {
          if (!p) return '';
          const color = p[0] === 'w' ? 'white' : 'black';
          const map = { K: 'king', Q: 'queen', R: 'rook', B: 'bishop', N: 'knight', P: 'pawn' };
          return `pieces/${color}-${map[p[1]]}.png`;
        }
      });
      $('.board-container').toggleClass('editing', editMode);
      rebindBoardHandlers();
    } else if (board) {
      board.position(fen);
    }

    if (!board) return;

    board.resize();
    syncEvalBarWidth();
    requestAnimationFrame(() => {
      if (!board) return;
      board.resize();
      syncEvalBarWidth();
    });
    applySelectionHighlights();
    applySpareSelection();
    if (!editMode && !pieceMovesMode && shouldHighlightBest && currentBestMove) {
      visualize(currentBestMove);
    }
    updateNavigationButtons();
    updateBestMoveDisplay();
  }

  function rebindBoardHandlers() {
    boardEl.off('click.square').on('click.square', CHESSBOARD_SELECTORS.square, function() {
      const cls = $(this).attr('class').split(/\s+/);
      const sq = cls.find(c => /^square-[a-h][1-8]$/.test(c));
      if (!sq) return;
      handleSquareClick(sq.replace('square-', ''));
    });
    boardEl.off('dblclick.square').on('dblclick.square', CHESSBOARD_SELECTORS.square, function() {
      const cls = $(this).attr('class').split(/\s+/);
      const sq = cls.find(c => /^square-[a-h][1-8]$/.test(c));
      if (!sq) return;
      handleSquareDoubleClick(sq.replace('square-', ''));
    });
    $(sparePiecesContainerSelector).off('click.spare').on('click.spare', sparePieceSelector, function() {
      const pieceCode = $(this).attr('data-piece');
      handleSparePieceClick(pieceCode);
    });
  }

  function updateStatus() {
    if (!statusElement) return;
    const turnColor = game.turn() === 'b' ? 'black' : 'white';
    const turnLabel = turnColor === 'white' ? 'White' : 'Black';
    let state = 'normal';
    let label = '';
    if (game.in_checkmate()) {
      state = 'mate';
      label = `Game over, ${turnLabel} is checkmated.`;
    } else if (game.in_draw()) {
      state = 'draw';
      label = 'Game over, drawn position';
    } else if (game.in_check()) {
      state = 'check';
      label = `${turnLabel} to move, ${turnLabel} is in check`;
    } else {
      label = `${turnLabel} to move`;
    }
    statusElement.dataset.turn = turnColor;
    statusElement.dataset.state = state;
    statusElement.classList.toggle('is-editing', editMode);
    statusElement.setAttribute('aria-label', label);
    const labelElement = statusElement.querySelector('.status-text__label');
    if (labelElement) {
      labelElement.textContent = label;
    } else {
      statusElement.textContent = label;
    }
    if (editMode) {
      statusElement.setAttribute('role', 'button');
      statusElement.setAttribute('tabindex', '0');
      statusElement.setAttribute('aria-pressed', turnColor === 'black' ? 'true' : 'false');
    } else {
      statusElement.removeAttribute('role');
      statusElement.removeAttribute('tabindex');
      statusElement.removeAttribute('aria-pressed');
    }
    updatePlayerSummaryFromGame();
  }

  function onDragStart(src, piece) {
    if (replayMode) stopReplay();
    if (editMode) return false;
    if (freezeMode) return false;
    return !game.game_over() && ((game.turn() === 'w' && piece[0] === 'w') || (game.turn() === 'b' && piece[0] === 'b'));
  }

  function onDrop(src, tgt, piece, newPos) {
    if (replayMode) stopReplay();
    clearHighlights(); clearRatings();
    if (editMode) {
      const previousFen = game.fen();
      const entries = Object.entries(newPos);
      game.clear();
      let placementFailed = false;
      for (const [square, pieceCode] of entries) {
        if (!pieceCode) continue;
        const color = pieceCode[0];
        const type = pieceCode[1] ? pieceCode[1].toLowerCase() : null;
        if (!type || (color !== 'w' && color !== 'b')) continue;
        const placed = game.put({ type, color }, square);
        if (!placed) {
          placementFailed = true;
          break;
        }
      }
      if (placementFailed) {
        game.load(previousFen);
        renderBoard();
        updateStatus();
        return;
      }
      lastImportWasPgn = false;
      resetHistory(game.fen());
      renderBoard(); updateStatus(); requestAnalysis({ highlight: shouldHighlightBest && bestMoveVisible, revealBest: bestMoveVisible });
      return;
    }
    if (freezeMode && !editMode) return 'snapback';
    const m = game.move({from:src,to:tgt,promotion:'q'});
    if (!m) return 'snapback';
    playMoveSound(m);
    recordMove(m);
    renderBoard(); updateStatus(); requestAnalysis({ highlight: shouldHighlightBest && bestMoveVisible, revealBest: bestMoveVisible });
  }

  function onSnapEnd() { if (!editMode) board.position(game.fen()); }
  function clearHighlights() {
    boardEl
      .find('.highlight-move-from, .highlight-move-to, .highlight-piece-move-target')
      .removeClass('highlight-move-from highlight-move-to highlight-piece-move-target');
  }
  function clearRatings() {
    boardEl.find('.move-rating').remove();
    pieceMoveRatings.clear();
  }

  function resetPieceAnalysisState() {
    pieceAnalysisMode = null;
    pieceAnalysisFen = null;
    pieceAnalysisTargetDepth = 0;
    pieceAnalysisTurn = null;
    pieceAnalysisCurrentRequestId = 0;
    pieceAnalysisPendingRequestId = 0;
    pieceAnalysisMoveSet.clear();
    pieceAnalysisResults.clear();
    pieceAnalysisSearchInFlight = false;
  }

  function ensurePieceMoveRatingElement(moveKey) {
    if (!moveKey) return null;
    let ratingEl = pieceMoveRatings.get(moveKey);
    if (ratingEl) return ratingEl;
    const destination = moveKey.slice(2, 4);
    if (!destination) return null;
    const squareEl = boardEl.find(`.square-${destination}`);
    if (!squareEl.length) return null;
    ratingEl = $('<div class="move-rating"></div>').appendTo(squareEl);
    pieceMoveRatings.set(moveKey, ratingEl);
    return ratingEl;
  }

  function setPieceMoveRating(moveKey, label) {
    if (!moveKey) return;
    const ratingEl = ensurePieceMoveRatingElement(moveKey);
    if (!ratingEl) return;
    ratingEl.text(label);
  }

  function applyPieceMoveEvaluation(moveKey, entry) {
    if (!moveKey || !entry) return;
    if (!pieceAnalysisMoveSet.has(moveKey)) return;
    if (typeof entry.whiteWinProbability !== 'number' || Number.isNaN(entry.whiteWinProbability)) {
      return;
    }
    const moverTurn = pieceAnalysisTurn === 'b' ? 'b' : 'w';
    const moverWinProbability = moverTurn === 'w'
      ? clampProbability(entry.whiteWinProbability)
      : clampProbability(1 - entry.whiteWinProbability);
    const label = formatWinProbability(moverWinProbability);
    pieceAnalysisResults.set(moveKey, moverWinProbability);
    setPieceMoveRating(moveKey, label);
  }

  function beginPieceAnalysisSearch({ fen, moves = [], depth = engineConfig.depth, turn = game.turn() }) {
    resetPieceAnalysisState();
    const filteredMoves = Array.isArray(moves) ? moves.filter(Boolean) : [];
    if (!filteredMoves.length || !engineReady || !engine) {
      return false;
    }
    pieceAnalysisMode = PIECE_ANALYSIS_MODE_MULTIPV;
    pieceAnalysisTurn = turn === 'b' ? 'b' : 'w';
    pieceAnalysisFen = typeof fen === 'string' ? fen : normalizeFenTurn(game.fen(), pieceAnalysisTurn);
    pieceAnalysisTargetDepth = Math.max(1, Math.floor(typeof depth === 'number' ? depth : engineConfig.depth));
    pieceAnalysisMoveSet = new Set(filteredMoves);
    pieceAnalysisResults = new Map();
    pieceAnalysisActiveRequestId += 1;
    pieceAnalysisPendingRequestId = pieceAnalysisActiveRequestId;
    const safeFen = sanitizeFenForStockfish(pieceAnalysisFen);
    const multiPv = Math.max(1, Math.min(50, filteredMoves.length));
    postEngineCommand(`setoption name MultiPV value ${multiPv}`);
    pendingSearchContext = { type: 'piece', metadata: { requestId: pieceAnalysisPendingRequestId, moveCount: filteredMoves.length } };
    postEngineCommand(`position fen ${safeFen}`);
    postEngineCommand(`go searchmoves ${filteredMoves.join(' ')} infinite`);
    return true;
  }

  function finalizePieceAnalysis() {
    resetPieceAnalysisState();
    isPieceAnalysis = false;
    if (engine) {
      postEngineCommand('setoption name MultiPV value 1');
    }
    if (!pieceMovesMode) {
      requestAnalysis({ highlight: shouldHighlightBest && bestMoveVisible, revealBest: bestMoveVisible, depth: engineConfig.depth });
    }
  }

  function handleMultipvPieceAnalysisInfo(line) {
    if (pieceAnalysisMode !== PIECE_ANALYSIS_MODE_MULTIPV) return false;
    if (!pieceAnalysisSearchInFlight || !pieceAnalysisCurrentRequestId) return false;
    if (!line.startsWith('info') || !line.includes('multipv')) return false;
    const pvIndex = line.indexOf(' pv ');
    if (pvIndex === -1) return false;
    const pvMoves = line.slice(pvIndex + 4).trim().split(' ');
    const moveKey = pvMoves[0];
    if (!moveKey || !pieceAnalysisMoveSet.has(moveKey)) return true;
    const cp = line.match(/score cp (-?\d+)/);
    const mate = line.match(/score mate (-?\d+)/);
    if (!cp && !mate) return true;
    const entry = buildEvaluationEntryFromScore({
      cp: cp ? parseInt(cp[1], 10) : null,
      mate: mate ? parseInt(mate[1], 10) : null,
      turn: pieceAnalysisTurn || game.turn()
    });
    applyPieceMoveEvaluation(moveKey, entry);
    return true;
  }

  function stopEngine(options = {}) {
    const { silent = false, preserveAutostartAttempts = false } = options || {};
    cancelEngineAutostart();
    engineStarting = false;
    engineLastStartWasAutostart = false;
    resetEngineCommandQueue();
    if (!preserveAutostartAttempts) {
      engineAutostartAttempts = 0;
    }
    if (engine) {
      postEngineCommand('stop', { queueIfPending: false });
      try {
        engine.terminate();
      } catch (terminateError) {
        console.warn('Failed to terminate engine worker', terminateError);
      }
    }
    engine = null;
    engineReady = false;
    waitingForAutoBestMove = false;
    autoMoveCandidate = null;
    autoPlayPending = false;
    autoPlayDepthSatisfied = false;
    resetPieceAnalysisState();
    $('#best-move-button').prop('disabled', true);
    updateNavigationButtons();
    if (!silent) {
      setEngineStatusDisplay('idle', 'Stopped');
      setEngineErrorMessage('', { source: '' });
    }
    updateEngineControls({ loading: false });
    currentBestMove = null;
    updateBestMoveDisplay();
    if (!pieceMovesMode) {
      setEvaluationText('Win chance --', 0.5);
      setAdvantageBarLoading(false);
      updateAdvantageBar(null, { neutral: true, message: silent ? 'Awaiting evaluation' : 'Engine stopped' });
    }
    shutdownBackgroundEngine();
  }

  function startEngine(options = {}) {
    const { autostart = false } = options || {};
    if (engineStarting) {
      return;
    }
    cancelEngineAutostart();
    const sanitizedConfig = applyEngineConfig(engineConfig);
    displayEngineConfigWarnings(sanitizedConfig);
    stopEngine({ silent: true, preserveAutostartAttempts: autostart });
    engineStarting = true;
    engineLastStartWasAutostart = !!autostart;
    setEngineStatusDisplay('loading', 'Starting…');
    const hasConfigWarnings = sanitizedConfig && Array.isArray(sanitizedConfig.warnings) && sanitizedConfig.warnings.length > 0;
    if (!hasConfigWarnings) {
      setEngineErrorMessage('', { source: '' });
    }
    updateEngineControls({ loading: true });
    let worker;
    try {
      worker = createStockfishWorker();
    } catch (error) {
      console.error('Unable to initialize Stockfish worker', error);
      engineStarting = false;
      const errorMessage = buildWorkerInitializationErrorMessage(error, { stage: 'load' });
      setEngineErrorMessage(errorMessage, { source: 'engine-error' });
      if (autostart && engineAutostartAttempts < ENGINE_AUTOSTART_MAX_ATTEMPTS) {
        setEngineStatusDisplay('loading', 'Retrying…');
        scheduleEngineAutostart();
      } else {
        setEngineStatusDisplay('error', 'Failed to start');
        updateEngineControls({ loading: false });
      }
      engineLastStartWasAutostart = false;
      return;
    }
    engine = worker;
    engineReady = false;
    resetEngineCommandQueue();
    $('#best-move-button').prop('disabled', true);
    updateNavigationButtons();
    worker.addEventListener('error', event => {
      const message = event && event.message ? event.message : 'Unknown error';
      console.error('Stockfish worker error', message, event);
      if (engine === worker) {
        engineReady = false;
        engineStarting = false;
        const shouldRetry = engineLastStartWasAutostart && engineAutostartAttempts < ENGINE_AUTOSTART_MAX_ATTEMPTS;
        try {
          worker.terminate();
        } catch (terminateError) {
          console.warn('Failed to terminate errored Stockfish worker', terminateError);
        }
        engine = null;
        resetEngineCommandQueue();
        $('#best-move-button').prop('disabled', true);
        updateNavigationButtons();
        setAdvantageBarLoading(false);
        setEvaluationText('Win chance --', 0.5);
        const statusMessage = shouldRetry ? 'Retrying…' : 'Engine error';
        updateAdvantageBar(null, { neutral: true, message: statusMessage });
        const errorForMessage = event && event.error instanceof Error
          ? event.error
          : new Error(message || 'Unknown Stockfish worker error');
        const errorStage = determineWorkerErrorStage(event, message);
        const friendlyMessage = buildWorkerInitializationErrorMessage(errorForMessage, { stage: errorStage });
        if (errorStage === 'runtime' && isMemoryAccessOutOfBoundsError(errorForMessage)) {
          applyEngineMemoryFallback();
        }
        setEngineErrorMessage(friendlyMessage, { source: 'engine-error' });
        if (shouldRetry) {
          setEngineStatusDisplay('loading', 'Retrying…');
          updateEngineControls({ loading: true });
          scheduleEngineAutostart();
        } else {
          setEngineStatusDisplay('error', 'Engine error');
          updateEngineControls({ loading: false });
        }
        engineLastStartWasAutostart = false;
      }
    });
    worker.onmessage = e => {
      const line = String(e.data).trim();

      if (line === 'uciok') {
        worker.postMessage(`setoption name Threads value ${engineConfig.threads}`);
        worker.postMessage(`setoption name Hash value ${engineConfig.hash}`);
        worker.postMessage('isready');
        return;
      }

      if (line === 'readyok') {
        if (engine !== worker) return;
        if (engineStopPending) {
          engineStopPending = false;
        }
        const hadPendingCommands = engineAwaitingReadyAfterStop;
        const wasStarting = engineStarting;
        engineReady = true;
        engineStarting = false;
        if (wasStarting) {
          engineLastStartWasAutostart = false;
          engineAutostartAttempts = 0;
          setEngineStatusDisplay('ready', 'Ready');
          setEngineErrorMessage('', { source: '', force: true });
          updateEngineControls({ loading: false });
          $('#best-move-button').prop('disabled', false);
          updateNavigationButtons();
          restartBackgroundEngine();
          if (pendingReplayStart) {
            const pending = pendingReplayStart;
            pendingReplayStart = null;
            startReplayFromIndex(pending.index, pending.depth);
          } else if (pieceMovesMode) {
            analyzeMoves();
          } else {
            requestAnalysis({ highlight: shouldHighlightBest && bestMoveVisible, revealBest: bestMoveVisible, depth: engineConfig.depth });
          }
        }
        if (hadPendingCommands) {
          resolveEngineReadyWait();
        }
        return;
      }

      if (!line.length) return;

      if (isPieceAnalysis) {
        if (handleMultipvPieceAnalysisInfo(line)) {
          return;
        }
      }

      if (line.startsWith('bestmove')) {
        if (engine === worker && engineStopPending) {
          engineStopPending = false;
        }
        if (isPieceAnalysis) {
          pieceAnalysisSearchInFlight = false;
          if (pieceAnalysisMode === PIECE_ANALYSIS_MODE_MULTIPV) {
            const hasActiveRequest = !!pieceAnalysisCurrentRequestId && !pieceAnalysisPendingRequestId;
            currentSearchContext = null;
            if (!hasActiveRequest) {
              return;
            }
            finalizePieceAnalysis();
            return;
          }
        }

        if (!latestAnalysisFen || latestAnalysisFen !== game.fen()) {
          resetAutoPlayState();
          updateNavigationButtons();
          return;
        }

        const parts = line.split(' ');
        const move = parts[1];

        if (waitingForAutoBestMove) {
          const fallback = autoMoveCandidate && autoMoveCandidate !== '(none)' ? autoMoveCandidate : null;
          const moveToPlay = move && move !== '(none)' ? move : fallback;

          const finalizeAutoMove = () => {
            resetAutoPlayState();
            if (moveToPlay) {
              applyAutoMove(moveToPlay);
            }
            updateNavigationButtons();
          };

          if (!moveToPlay) {
            finalizeAutoMove();
            return;
          }

          const elapsed = Date.now() - autoPlayRequestedAt;
          const remaining = Math.max(0, AUTO_PLAY_MIN_WAIT_MS - elapsed);

          if (!autoPlayDepthSatisfied || remaining <= 0) {
            finalizeAutoMove();
          } else {
            if (autoPlayDelayTimer) {
              clearTimeout(autoPlayDelayTimer);
            }
            autoPlayDelayTimer = setTimeout(() => {
              autoPlayDelayTimer = null;
              finalizeAutoMove();
            }, remaining);
          }
          return;
        }

        if (move && move !== '(none)') {
          currentBestMove = move;
          updateBestMoveDisplay();
        }
        currentSearchContext = null;
        return;
      }

      if (!line.startsWith('info') || !line.includes('score')) {
        return;
      }

      if (!latestAnalysisFen || latestAnalysisFen !== game.fen()) return;
      if (isPieceAnalysis) return;

      const depthMatch = line.match(/depth (\d+)/);
      if (depthMatch) {
        currentDepth = parseInt(depthMatch[1], 10);
      }

      const cpMatch = line.match(/score cp (-?\d+)/);
      const mateMatch = line.match(/score mate (-?\d+)/);
      const turn = game.turn();

      if (cpMatch || mateMatch) {
        const cpValue = cpMatch ? parseInt(cpMatch[1], 10) : null;
        const mateValue = mateMatch ? parseInt(mateMatch[1], 10) : null;
        const entry = buildEvaluationEntryFromScore({ cp: cpValue, mate: mateValue, turn });
        if (entry) {
          applyEvaluationEntry(entry);
        }
      }

      const pvIndex = line.indexOf(' pv ');
      if (pvIndex !== -1) {
        const pvMoves = line.slice(pvIndex + 4).trim().split(' ');
        if (pvMoves.length) {
          currentBestMove = pvMoves[0];
          updateBestMoveDisplay();
        }
      }

      if (replayMode && replayPendingIndex === navigationIndex && currentDepth >= replayTargetDepth) {
        scheduleReplayAdvance();
      }

      if (autoPlayPending && autoPlayFen === latestAnalysisFen && currentDepth >= autoPlayTargetDepth && currentBestMove && !game.game_over()) {
        const searchStartedAt = currentSearchContext && currentSearchContext.type === 'autoPlay'
          ? currentSearchContext.startedAt
          : null;
        const elapsed = searchStartedAt ? Date.now() - searchStartedAt : null;
        const thinkSatisfied = elapsed !== null ? elapsed >= MIN_THINK_TIME_MS : false;
        const triggerAutoPlayStop = () => {
          autoPlayPending = false;
          autoPlayFen = null;
          autoPlayDepthSatisfied = true;
          waitingForAutoBestMove = true;
          autoMoveCandidate = currentBestMove;
          if (autoPlayMinThinkTimer) {
            clearTimeout(autoPlayMinThinkTimer);
            autoPlayMinThinkTimer = null;
          }
          postEngineCommand('stop');
          engineStopPending = true;
          updateNavigationButtons();
        };

        if (thinkSatisfied || !searchStartedAt) {
          triggerAutoPlayStop();
        } else if (!autoPlayMinThinkTimer) {
          const waitTime = Math.max(0, MIN_THINK_TIME_MS - elapsed);
          autoPlayMinThinkTimer = setTimeout(() => {
            autoPlayMinThinkTimer = null;
            if (autoPlayPending && autoPlayFen === latestAnalysisFen && currentBestMove && !game.game_over() && currentDepth >= autoPlayTargetDepth) {
              triggerAutoPlayStop();
            }
          }, waitTime);
        }
      }
    };
    worker.postMessage('uci');
  }


  function visualize(u) {
    clearHighlights();
    if (!u || u.length < 4) return;
    const from = u.slice(0, 2);
    const to = u.slice(2, 4);
    boardEl.find(`.square-${from}`).addClass('highlight-move-from');
    boardEl.find(`.square-${to}`).addClass('highlight-move-to');
  }

  function requestAnalysis(options = {}) {
    const currentFen = game.fen();
    if (lastObservedPositionFen !== currentFen) {
      invalidateAnalysisCache();
    }
    updateLastObservedFen(currentFen);

    if (!engineReady || !engine) {
      scheduleEngineAutostart();
      return;
    }

    const {
      highlight = false,
      revealBest = false,
      depth = engineConfig.depth,
      autoPlay = false,
      searchMoves = null,
      multiPv = 1,
      pieceAnalysis = false,
      replay = false,
      analysisFen = null,
      forceRefresh = false
    } = options;

    latestAnalysisFen = currentFen;
    shouldHighlightBest = highlight && revealBest;
    isPieceAnalysis = pieceAnalysis;
    if (!pieceAnalysis) {
      resetPieceAnalysisState();
    }

    const fenOverride = typeof analysisFen === 'string' ? analysisFen : null;
    const fenTurn = pieceAnalysis ? (getFenTurn(fenOverride) || game.turn()) : game.turn();
    const normalizedFenForCache = pieceAnalysis
      ? normalizeFenTurn(fenOverride || latestAnalysisFen, fenTurn)
      : normalizeFenTurn(latestAnalysisFen, game.turn());
    const searchMovesForCache = pieceAnalysis
      ? (Array.isArray(searchMoves) ? searchMoves : [])
      : (Array.isArray(searchMoves) ? searchMoves : null);
    const requestCacheEntry = createAnalysisRequestCacheEntry({
      fen: normalizedFenForCache,
      pieceAnalysis,
      searchMoves: searchMovesForCache,
      multiPv,
      autoPlay,
      depth
    });
    const cacheMatches = lastAnalysisRequest && analysisRequestsMatch(lastAnalysisRequest, requestCacheEntry);
    const engineBusy = !!engine && (
      engineStopPending || engineAwaitingReadyAfterStop || (lastAnalysisRequest && lastAnalysisRequest.active)
    );
    const shouldRestart = forceRefresh || !cacheMatches || !engineBusy;

    if (replay) {
      replayMode = true;
      replayTargetDepth = Math.max(PGN_REPLAY_DEPTH, depth);
      replayPendingIndex = navigationIndex;
      replayAdvanceScheduled = false;
      cancelReplayTimer();
      updateEvaluationProgressLabel();
    } else if (!pieceAnalysis) {
      if (replayMode) {
        stopReplay();
      }
    }

    if (autoPlay) {
      autoPlayPending = true;
      const depthFloor = Math.max(1, Math.floor(depth));
      autoPlayTargetDepth = Math.max(PGN_REPLAY_DEPTH, depthFloor);
      autoPlayFen = latestAnalysisFen;
      autoPlayRequestedAt = Date.now();
      autoPlayDepthSatisfied = false;
      if (autoPlayDelayTimer) {
        clearTimeout(autoPlayDelayTimer);
        autoPlayDelayTimer = null;
      }
    } else if (!pieceAnalysis) {
      autoPlayPending = false;
      autoPlayFen = null;
      autoPlayDepthSatisfied = false;
      if (autoPlayDelayTimer) {
        clearTimeout(autoPlayDelayTimer);
        autoPlayDelayTimer = null;
      }
    }

    if (revealBest) {
      bestMoveVisible = true;
    } else if (!bestMoveVisible) {
      shouldHighlightBest = false;
    }
    syncBestMoveButton();

    if (!shouldRestart) {
      return;
    }

    currentBestMove = null;
    currentDepth = 0;
    waitingForAutoBestMove = false;
    autoMoveCandidate = null;

    if (!pieceAnalysis && !pieceMovesMode) {
      clearHighlights();
    }
    if (!pieceAnalysis) {
      clearRatings();
    }

    if (pieceAnalysis) {
      setEvaluationText('Win chance --', 0.5);
    } else {
      const stored = getTimelineEntry(navigationIndex);
      if (!stored || typeof stored.value !== 'number') {
        setEvaluationText('Win chance --', 0.5);
      }
    }
    setAdvantageBarLoading(true, { reset: !pieceAnalysis });
    updateBestMoveDisplay();
    if (replay) {
      updateEvaluationProgressLabel();
    }

    deactivateLastAnalysisRequest();

    const normalizedFen = normalizeFenTurn(latestAnalysisFen, game.turn());
    const safeFen = sanitizeFenForStockfish(normalizedFen);
    const stopHandshakePending = engineAwaitingReadyAfterStop || engineStopPending;

    if (!stopHandshakePending) {
      postEngineCommand('stop', { queueIfPending: false });
      engineStopPending = true;
    }
    engineCommandQueue = [];
    beginEngineReadyWait();
    if (pieceAnalysis) {
      const moveList = Array.isArray(searchMoves) ? searchMoves.slice() : [];
      const targetFen = normalizedFenForCache;
      const started = beginPieceAnalysisSearch({ fen: targetFen, moves: moveList, depth, turn: fenTurn });
      if (started) {
        markAnalysisRequestActive(requestCacheEntry);
      } else {
        isPieceAnalysis = false;
        invalidateAnalysisCache();
      }
      updateNavigationButtons();
      return;
    }
    const resolvedDepth = Math.floor(typeof depth === 'number' ? depth : engineConfig.depth);
    const depthLimit = Math.max(PGN_REPLAY_DEPTH, Math.max(1, resolvedDepth));
    const goCommand = autoPlay
      ? 'go infinite'
      : (searchMoves && searchMoves.length
        ? `go searchmoves ${searchMoves.join(' ')} infinite`
        : 'go infinite');
    pendingSearchContext = {
      type: autoPlay ? 'autoPlay' : 'analysis',
      metadata: {
        fen: safeFen,
        depth: depthLimit,
        searchMoves: searchMoves && searchMoves.length ? searchMoves.slice() : null
      }
    };
    const queuedCommands = [
      'ucinewgame',
      `setoption name MultiPV value ${multiPv}`,
      `position fen ${safeFen}`,
      goCommand
    ];
    markAnalysisRequestActive(requestCacheEntry);
    queueEngineCommands(queuedCommands);
    updateNavigationButtons();
  }

  function analyzeMoves() {
    clearRatings();
    let analysisGame = game;
    let analysisFenOverride = null;
    let moves = [];

    if (selectedSquare) {
      const piece = game.get(selectedSquare);
      if (!piece) return;

      if (piece.color !== game.turn()) {
        const candidateFen = normalizeFenTurn(game.fen(), piece.color);
        const tempGame = new Chess();
        if (tempGame.load(candidateFen)) {
          analysisGame = tempGame;
          analysisFenOverride = candidateFen;
        }
      }

      moves = analysisGame.moves({ verbose: true, square: selectedSquare });
    } else {
      moves = analysisGame.moves({ verbose: true });
    }

    if (!moves.length) return;
    clearHighlights();
    const destinationSquares = new Set();
    const pendingLabel = engineReady ? '…' : '—';
    moves.forEach(move => {
      const destination = move.to;
      if (destination && !destinationSquares.has(destination)) {
        destinationSquares.add(destination);
        boardEl.find(`.square-${destination}`).addClass('highlight-piece-move-target');
      }
      const moveKey = move.from + move.to + (move.promotion ? move.promotion : '');
      setPieceMoveRating(moveKey, pendingLabel);
    });
    applySelectionHighlights();
    const searchMoves = moves.map(m => m.from + m.to + (m.promotion ? m.promotion : ''));
    requestAnalysis({
      depth: engineConfig.depth,
      searchMoves,
      multiPv: moves.length,
      pieceAnalysis: true,
      analysisFen: analysisFenOverride
    });
  }

  // UI hooks
  function goToPreviousMove() {
    if (replayMode) stopReplay();
    if (navigationIndex === 0) return;
    rebuildPosition(navigationIndex - 1);
  }

  function goToNextMove() {
    if (replayMode) stopReplay();
    if (autoPlayPending) return;
    if (game.game_over()) return;
    if (navigationIndex < moveHistory.length) {
      rebuildPosition(navigationIndex + 1);
      return;
    }
    if (!engineReady) {
      scheduleEngineAutostart();
      return;
    }
    requestAnalysis({
      highlight: shouldHighlightBest && bestMoveVisible,
      revealBest: bestMoveVisible,
      depth: engineConfig.depth,
      autoPlay: true
    });
  }

  function importPositionFromText(rawInput) {
    if (typeof rawInput !== 'string') {
      return { success: false, error: 'Please enter a FEN or PGN.' };
    }
    const trimmed = rawInput.trim();
    if (!trimmed.length) {
      return { success: false, error: 'Please enter a FEN or PGN.' };
    }

    const looksLikePgn = /\d+\./.test(trimmed) || /\[\w+\s+".*"\]/.test(trimmed) || trimmed.includes('\n');

      const loadFen = () => {
        const fenTest = new Chess();
        if (!fenTest.load(trimmed)) {
          return false;
        }
        const canonicalFen = fenTest.fen();
        if (!game.load(canonicalFen)) {
          return false;
        }
        resetHistory(game.fen());
        lastImportWasPgn = false;
        resetPlayerSummaryState({ locked: false });
        updatePlayerSummaryFromGame();
        return true;
      };

    const loadPgn = () => {
      const normalizePgn = input => {
        let normalized = input;
        const headerMatch = normalized.match(/^((?:\s*\[[^\]]+\][^\S\r\n]*\r?\n)+)([\s\S]*)$/);
        if (headerMatch) {
          const headerBlock = headerMatch[1];
          const remainder = headerMatch[2];
          const hasBlankLine = /^\s*(?:\r?\n)/.test(remainder);
          const startsWithMoveText = /^\s*\d+\./.test(remainder);
          if (!hasBlankLine && startsWithMoveText) {
            const newline = headerBlock.includes('\r\n') ? '\r\n' : '\n';
            normalized = `${headerBlock}${newline}${remainder}`;
          }
        }
        return normalized;
      };

      const normalizedPgn = normalizePgn(trimmed);

      let importGame = new Chess();
      let loaded = false;
      if (typeof importGame.load_pgn === 'function') {
        loaded = importGame.load_pgn(normalizedPgn, { sloppy: true });
        if (!loaded) {
          importGame = new Chess();
          loaded = importGame.load_pgn(normalizedPgn);
        }
      }
      if (!loaded) return false;

      const header = typeof importGame.header === 'function' ? importGame.header() : {};
      const history = importGame.history({ verbose: true }) || [];
      applyPlayerSummaryFromPgn(header, history);
      let initialFen = null;
      if (header && header.SetUp === '1' && header.FEN) {
        initialFen = header.FEN;
      }

      const baseCandidate = new Chess();
      if (initialFen) {
        if (!baseCandidate.load(initialFen)) {
          return false;
        }
      }
      const basePositionFen = baseCandidate.fen();
      const moves = history.map(m => ({ from: m.from, to: m.to, promotion: m.promotion }));

      const verificationGame = new Chess();
      if (!verificationGame.load(basePositionFen)) {
        return false;
      }
      for (const mv of moves) {
        const moveConfig = { from: mv.from, to: mv.to };
        if (mv.promotion) {
          moveConfig.promotion = mv.promotion;
        }
        const applied = verificationGame.move(moveConfig);
        if (!applied) {
          return false;
        }
      }

      resetHistory(basePositionFen);
      moveHistory = moves;
      navigationIndex = 0;
      clearEvaluationTimeline(moveHistory.length + 1);
      if (!game.load(basePositionFen)) {
        return false;
      }
      updateNavigationButtons();
      scheduleEvaluationNavigationRender();
      lastImportWasPgn = true;
      return true;
    };

    lastImportWasPgn = false;
    const loaders = looksLikePgn ? [loadPgn, loadFen] : [loadFen, loadPgn];
    let loaded = false;
    for (const loader of loaders) {
      if (loader()) {
        loaded = true;
        break;
      }
    }

    if (!loaded) {
      return { success: false, error: 'Invalid FEN or PGN.' };
    }

    moveSourceSquare = null;
    selectedSquare = null;
    editSelectedPiece = null;
    editSelectedSquare = null;
    editSelectionSource = null;
    applySelectionHighlights();
    applySpareSelection();
    renderBoard();
    updateStatus();
    updateNavigationButtons();
    if (lastImportWasPgn) {
      stopReplay();
      replayTargetDepth = engineConfig.depth;
      pendingReplayStart = null;
      probabilityPanelVisible = true;
      if (probabilityPanel) {
        probabilityPanel.hidden = false;
        probabilityPanel.setAttribute('aria-hidden', 'false');
      }
      syncProbabilityButton();
      scheduleEvaluationNavigationRender();
      scheduleProbabilityEvaluation(PGN_IMPORT_ANALYSIS_DEPTH);
    } else {
      requestAnalysis({ highlight: shouldHighlightBest && bestMoveVisible, revealBest: bestMoveVisible });
    }

    return { success: true };
  }

  $('#best-move-button').on('click', () => {
    if (replayMode) stopReplay();
    bestMoveVisible = !bestMoveVisible;
    shouldHighlightBest = bestMoveVisible;
    syncBestMoveButton();
    updateBestMoveDisplay();
    if (bestMoveVisible) {
      requestAnalysis({ highlight: shouldHighlightBest, revealBest: true });
    }
  });
  $('#advantage-toggle-button').on('click', () => {
    advantageBarVisible = !advantageBarVisible;
    if (advantageBarElement) {
      advantageBarElement.hidden = !advantageBarVisible;
      if (advantageBarVisible) {
        advantageBarElement.style.removeProperty('display');
      } else {
        advantageBarElement.style.display = 'none';
      }
      advantageBarElement.setAttribute('aria-hidden', advantageBarVisible ? 'false' : 'true');
      if (advantageBarVisible) {
        syncEvalBarWidth();
      }
    }
    if (evaluationContainer) {
      evaluationContainer.hidden = !advantageBarVisible;
      if (advantageBarVisible) {
        evaluationContainer.style.removeProperty('display');
      } else {
        evaluationContainer.style.display = 'none';
      }
      evaluationContainer.setAttribute('aria-hidden', advantageBarVisible ? 'false' : 'true');
    }
    setEvaluationLiveMode(advantageBarVisible);
    syncAdvantageButton();
  });
  $('#probability-button').on('click', () => {
    probabilityPanelVisible = !probabilityPanelVisible;
    if (probabilityPanel) {
      probabilityPanel.hidden = !probabilityPanelVisible;
      probabilityPanel.setAttribute('aria-hidden', probabilityPanelVisible ? 'false' : 'true');
    }
    if (probabilityPanelVisible) {
      scheduleEvaluationNavigationRender();
      scheduleProbabilityEvaluation();
    } else {
      cancelBackgroundEvaluation();
    }
    syncProbabilityButton();
  });
  $('#engine-button').on('click', () => {
    enginePanelVisible = !enginePanelVisible;
    syncEnginePanelVisibility();
  });

  const collectEngineFormValues = () => ({
    threads: engineThreadsInput ? engineThreadsInput.value : engineConfig.threads,
    hash: engineHashInput ? engineHashInput.value : engineConfig.hash,
    depth: engineDepthInput ? engineDepthInput.value : engineConfig.depth
  });

  $('#engine-start-button').on('click', () => {
    cancelEngineAutostart();
    engineAutostartAttempts = 0;
    const result = applyEngineConfig(collectEngineFormValues());
    displayEngineConfigWarnings(result);
    startEngine({ autostart: false });
  });

  $('#engine-stop-button').on('click', () => {
    cancelEngineAutostart();
    stopEngine();
  });

  if (engineAutostartToggle) {
    engineAutostartToggle.addEventListener('change', () => {
      engineAutostartDisabled = !engineAutostartToggle.checked;
      persistAutostartPreference();
      if (engineAutostartDisabled) {
        cancelEngineAutostart();
      } else {
        engineAutostartAttempts = 0;
        if (!engineReady && !engineStarting) {
          scheduleEngineAutostart({ resetAttempts: true });
        }
      }
    });
  }

  const engineFormInputs = [engineThreadsInput, engineHashInput, engineDepthInput].filter(Boolean);
  const handleEngineInputUpdate = () => {
    const result = applyEngineConfig(collectEngineFormValues());
    displayEngineConfigWarnings(result);
    if (engineReady && result && result.changed) {
      setEngineStatusDisplay('ready', 'Ready (restart to apply)');
    }
    updateEngineControls({ loading: false });
  };
  engineFormInputs.forEach(input => {
    input.addEventListener('change', handleEngineInputUpdate);
    input.addEventListener('blur', handleEngineInputUpdate);
  });
  $('#prev-button').on('click', goToPreviousMove);
  $('#next-button').on('click', goToNextMove);
  $('#status').on('click', () => {
    if (!editMode) return;
    toggleEditingTurn();
  });
  $('#status').on('keydown', event => {
    if (!editMode) return;
    if (event.key === 'Enter' || event.key === ' ') {
      event.preventDefault();
      toggleEditingTurn();
    }
  });

  $(document).on('keydown', event => {
    const activeElement = document.activeElement;
    if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.isContentEditable)) {
      return;
    }

    if (event.ctrlKey || event.metaKey || event.altKey) {
      return;
    }

    const key = event.key.toLowerCase();

    if (editMode && (key === 'delete' || key === 'backspace')) {
      if (editSelectionSource === 'board' && editSelectedSquare) {
        event.preventDefault();
        const targetSquare = editSelectedSquare;
        if (removePieceAtSquare(targetSquare)) {
          clearEditSelection();
        }
      }
      return;
    }

    if (key === 'arrowleft') {
      if (prevButtonElement && prevButtonElement.disabled) {
        return;
      }
      event.preventDefault();
      goToPreviousMove();
    } else if (key === 'arrowright') {
      if (nextButtonElement && nextButtonElement.disabled) {
        return;
      }
      event.preventDefault();
      goToNextMove();
    } else if (key === 'f') {
      if (!flipButtonElement) {
        return;
      }
      event.preventDefault();
      flipButtonElement.click();
    } else if (key === 'g') {
      if (!advantageToggleButton || advantageToggleButton.disabled) {
        return;
      }
      event.preventDefault();
      advantageToggleButton.click();
    } else if (key === 'p') {
      if (!pieceMovesButtonElement) {
        return;
      }
      event.preventDefault();
      pieceMovesButtonElement.click();
    } else if (key === 'b') {
      if (!bestMoveButtonElement || bestMoveButtonElement.disabled) {
        return;
      }
      event.preventDefault();
      bestMoveButtonElement.click();
    } else if (key === 'l') {
      if (!probabilityButtonElement) {
        return;
      }
      event.preventDefault();
      probabilityButtonElement.click();
    } else if (key === 'e') {
      if (!editButtonElement) {
        return;
      }
      event.preventDefault();
      editButtonElement.click();
    } else if (key === 'i') {
      if (!fenButtonElement) {
        return;
      }
      event.preventDefault();
      fenButtonElement.click();
    }
  });
  $('#piece-moves-button').on('click', () => {
    if (replayMode) stopReplay();
    pieceMovesMode = !pieceMovesMode;
    freezeMode = pieceMovesMode;
    if (!pieceMovesMode) {
      requestAnalysis({ highlight: shouldHighlightBest && bestMoveVisible, revealBest: bestMoveVisible });
    }
    selectedSquare = null;
    moveSourceSquare = null;
    syncPieceMovesButton();
    clearHighlights();
    clearRatings();
    renderBoard();
    updateStatus();
    if (pieceMovesMode) {
      analyzeMoves();
    }
  });
  $('#flip-button').on('click', () => {
    orientation = orientation === 'white' ? 'black' : 'white';
    renderBoard();
    updateStatus();
  });
  $('#edit-button').on('click', () => {
    if (replayMode) stopReplay();
    editMode = !editMode;
    moveSourceSquare = null;
    selectedSquare = null;
    if (editMode) {
      if (engine) {
        postEngineCommand('stop', { queueIfPending: false });
        resetEngineCommandQueue();
      }
      $(document).on('click.editOutside', handleOutsideBoardClick);
      clearEditSelection();
      clearHighlights();
      clearRatings();
      latestAnalysisFen = null;
      currentBestMove = null;
      setEvaluationText('Win chance --', 0.5);
      updateBestMoveDisplay();
      setAdvantageBarLoading(false);
      updateAdvantageBar(null, { neutral: true, message: 'Editing' });
    } else {
      $(document).off('click.editOutside');
      clearEditSelection();
      currentBestMove = null;
      updateBestMoveDisplay();
      requestAnalysis({ highlight: shouldHighlightBest && bestMoveVisible, revealBest: bestMoveVisible });
    }
    syncEditButton();
    renderBoard();
    updateStatus();
  });
  $('#fen-button').on('click', () => {
    if (replayMode) stopReplay();
    const presetValue = lastImportWasPgn ? '' : game.fen();
    openInputModal(presetValue);
  });

  if (inputModalApplyButton) {
    inputModalApplyButton.addEventListener('click', handleInputModalSubmit);
  }

  if (inputModalCancelButton) {
    inputModalCancelButton.addEventListener('click', () => closeInputModal());
  }

  if (inputModalTextarea) {
    inputModalTextarea.addEventListener('input', () => {
      if (inputModalErrorElement && !inputModalErrorElement.hidden) {
        clearInputModalError();
      }
    });
    inputModalTextarea.addEventListener('keydown', event => {
      if ((event.ctrlKey || event.metaKey) && event.key === 'Enter') {
        event.preventDefault();
        handleInputModalSubmit();
      }
    });
  }

  if (archiveChesscomButton) {
    archiveChesscomButton.addEventListener('click', () => handleArchiveSearch(ARCHIVE_SEARCH_SOURCES.CHESSCOM));
  }

  if (archiveLichessButton) {
    archiveLichessButton.addEventListener('click', () => handleArchiveSearch(ARCHIVE_SEARCH_SOURCES.LICHESS));
  }

  if (archiveSearchInput) {
    archiveSearchInput.addEventListener('keydown', event => {
      if (event.key === 'Enter') {
        event.preventDefault();
        handleArchiveSearch(archiveSearchLastSource || ARCHIVE_SEARCH_SOURCES.CHESSCOM);
      }
    });
  }

  if (archiveResultsElement) {
    archiveResultsElement.addEventListener('click', event => {
      const trigger = event.target && typeof event.target.closest === 'function'
        ? event.target.closest('button[data-archive-index]')
        : null;
      if (!trigger) {
        return;
      }
      event.preventDefault();
      const indexValue = Number(trigger.getAttribute('data-archive-index'));
      if (!Number.isInteger(indexValue) || indexValue < 0 || indexValue >= archiveSearchEntries.length) {
        return;
      }
      const entry = archiveSearchEntries[indexValue];
      handleArchiveResultSelection(entry);
    });
  }

  initializeArchiveSearch();

  if (inputModalElement) {
    inputModalElement.addEventListener('keydown', event => {
      if (event.key === 'Escape') {
        event.preventDefault();
        closeInputModal();
        return;
      }
      if (event.key === 'Tab') {
        trapInputModalFocus(event);
      }
    });
    inputModalElement.addEventListener('mousedown', event => {
      if (event.target === inputModalElement) {
        event.preventDefault();
        closeInputModal();
      }
    });
  }

  clearEvaluationTimeline(1);
  updateAdvantageBar(null, { neutral: true, message: 'Awaiting evaluation' });
  setAdvantageBarLoading(false);
  scheduleEvaluationNavigationRender();
  renderBoard();
  applyEngineConfig(engineConfig);
  syncEngineInputs();
  setEngineStatusDisplay('idle', 'Not started');
  setEngineErrorMessage('', { source: '' });
  updateEngineControls({ loading: false });
  syncEnginePanelVisibility();
  syncEngineButton();
  updateStatus();
  scheduleEngineAutostart({ immediate: true, resetAttempts: true });
  $(window).off('resize.board').on('resize.board', () => {
    if (!board) return;
    board.resize();
    syncEvalBarWidth();
    scheduleEvaluationNavigationRender();
  });

  if (evaluationNavElement) {
    evaluationNavElement.addEventListener('click', event => {
      if (replayMode) stopReplay();
      if (editMode || pieceMovesMode) return;
      const segment = event.target.closest('.evaluation-nav__segment');
      if (!segment) return;
      const { index } = segment.dataset;
      const targetIndex = Number.parseInt(index, 10);
      if (!Number.isInteger(targetIndex)) return;
      if (targetIndex === navigationIndex) return;
      rebuildPosition(Math.max(0, Math.min(targetIndex, moveHistory.length)));
    });
    evaluationNavElement.addEventListener('keydown', event => {
      if (editMode || pieceMovesMode) return;
      let targetIndex = null;
      if (event.key === 'ArrowLeft') {
        targetIndex = Math.max(0, navigationIndex - 1);
      } else if (event.key === 'ArrowRight') {
        targetIndex = Math.min(moveHistory.length, navigationIndex + 1);
      } else if (event.key === 'Home') {
        targetIndex = 0;
      } else if (event.key === 'End') {
        targetIndex = moveHistory.length;
      }
      if (targetIndex === null || targetIndex === navigationIndex) return;
      event.preventDefault();
      if (replayMode) stopReplay();
      rebuildPosition(targetIndex);
    });
  }
      }

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initialize, { once: true });
      } else {
        initialize();
      }
    })();

  </script>
</body>
</html>
